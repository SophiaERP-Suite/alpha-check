import{i as u,F as l,E as w,u as qi,v as Hi,y as ji,x as kt,w as Ka,z as Ki,D as Ji,G as Yi,H as ls,K as Se,L as ze,N as x,O as Xi,n as ne,Q as Zi,R as Qi,S as ec,U as qe,k as Ja,X as Ya,Y as tc,Z as ke,_ as nn,$ as nc,a0 as sc,a1 as Xa,a2 as Ys,a3 as Za,a4 as pt,a5 as Wn,a6 as Ht,a7 as Vn,a8 as qn,a9 as Hn,B as ac,aa as rc,ab as Pt,ac as Xs,ad as oc,ae as ic,af as cc}from"./secp256k1-EokEu98p.js";var dc=Object.defineProperty,Q=(e,t)=>dc(e,"name",{value:t,configurable:!0}),Qa=Q((e,t)=>{const n=[];for(let i=0;i<e.length;i+=t){const c=new Uint8Array(t);c.set(e.slice(i,i+t)),n.push(c)}const s=n[n.length-1],a=e.length%t,r=a+(8-a%8)%8,o=s.slice(0,r);return n[n.length-1]=o,n},"chunkAndPadBytes"),v=Q((e,t,n=!0)=>{if(e instanceof Uint8Array)return n?new Uint8Array(e):e;if(typeof e=="string"&&e.match(/^0x([0-9a-f][0-9a-f])*$/i)){const r=new Uint8Array((e.length-2)/2);let o=2;for(let i=0;i<r.length;i++)r[i]=parseInt(e.substring(o,o+2),16),o+=2;return r}const a=`invalid data:${t?` ${t} -`:""} ${e}
If you are attempting to transform a hex value, please make sure it is being passed as a string and wrapped in quotes.`;throw new l(w.INVALID_DATA,a)},"arrayify"),pn=Q(e=>{const t=e.map(a=>a instanceof Uint8Array?a:Uint8Array.from(a)),n=t.reduce((a,r)=>a+r.length,0),s=new Uint8Array(n);return t.reduce((a,r)=>(s.set(r,a),a+r.length),0),s},"concatBytes"),B=Q(e=>{const t=e.map(n=>v(n));return pn(t)},"concat"),Zs="0123456789abcdef";function S(e){const t=v(e);let n="0x";for(let s=0;s<t.length;s++){const a=t[s];n+=Zs[(a&240)>>4]+Zs[a&15]}return n}Q(S,"hexlify");var uc=37,er=BigInt(2**62)+BigInt(uc),lc=Q(e=>Math.floor(e/1e3),"msToSeconds"),tr=Q(e=>e*1e3,"secondsToMs"),hc=Q(e=>Number(BigInt(e)-er),"tai64ToUnixSeconds"),pc=Q(e=>String(BigInt(e)+er),"unixSecondsToTai64"),fc=Q(e=>tr(hc(e)),"tai64ToUnixMilliseconds"),nr=class jt extends Date{static{Q(this,"DateTime")}static TAI64_NULL="";static fromTai64(t){return new jt(fc(t))}static fromUnixMilliseconds(t){return new jt(t)}static fromUnixSeconds(t){return new jt(tr(t))}constructor(t){super(t)}toTai64(){return pc(this.toUnixSeconds())}toUnixMilliseconds(){return this.getTime()}toUnixSeconds(){return lc(this.getTime())}};function hs(e){return new Promise(t=>{setTimeout(()=>{t(!0)},e)})}Q(hs,"sleep");function he(e){return e!==void 0}Q(he,"isDefined");var sr=u(0),jn=u(58),sn="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",Vt=null;function ar(e){if(Vt==null){Vt={};for(let n=0;n<sn.length;n++)Vt[sn[n]]=u(n)}const t=Vt[e];if(t==null)throw new l(w.INVALID_DATA,`invalid base58 value ${e}`);return u(t)}Q(ar,"getAlpha");function ps(e){const t=v(e);let n=u(t),s="";for(;n.gt(sr);)s=sn[Number(n.mod(jn))]+s,n=n.div(jn);for(let a=0;a<t.length&&!t[a];a++)s=sn[0]+s;return s}Q(ps,"encodeBase58");function rr(e){let t=sr;for(let n=0;n<e.length;n++)t=t.mul(jn),t=t.add(ar(e[n].toString()));return t}Q(rr,"decodeBase58");function fn(e,t,n){const s=v(e);if(n!=null&&n>s.length)throw new l(w.INVALID_DATA,"cannot slice beyond data bounds");return S(s.slice(t??0,n??s.length))}Q(fn,"dataSlice");function Ce(e,t=!0){let n=e;t&&(n=e.normalize("NFC"));const s=[];for(let a=0;a<n.length;a+=1){const r=n.charCodeAt(a);if(r<128)s.push(r);else if(r<2048)s.push(r>>6|192),s.push(r&63|128);else if((r&64512)===55296){a+=1;const o=n.charCodeAt(a);if(a>=n.length||(o&64512)!==56320)throw new l(w.INVALID_INPUT_PARAMETERS,"Invalid UTF-8 in the input string.");const i=65536+((r&1023)<<10)+(o&1023);s.push(i>>18|240),s.push(i>>12&63|128),s.push(i>>6&63|128),s.push(i&63|128)}else s.push(r>>12|224),s.push(r>>6&63|128),s.push(r&63|128)}return new Uint8Array(s)}Q(Ce,"toUtf8Bytes");function Ue(e,t,n,s,a){return console.log(`invalid codepoint at offset ${t}; ${e}, bytes: ${n}`),t}Q(Ue,"onError");function or(e){return e.map(t=>t<=65535?String.fromCharCode(t):(t-=65536,String.fromCharCode((t>>10&1023)+55296,(t&1023)+56320))).join("")}Q(or,"helper");function ir(e){const t=v(e,"bytes"),n=[];let s=0;for(;s<t.length;){const a=t[s++];if(a>>7===0){n.push(a);continue}let r=null,o=null;if((a&224)===192)r=1,o=127;else if((a&240)===224)r=2,o=2047;else if((a&248)===240)r=3,o=65535;else{(a&192)===128?s+=Ue("UNEXPECTED_CONTINUE",s-1,t):s+=Ue("BAD_PREFIX",s-1,t);continue}if(s-1+r>=t.length){s+=Ue("OVERRUN",s-1,t);continue}let i=a&(1<<8-r-1)-1;for(let c=0;c<r;c++){const d=t[s];if((d&192)!==128){s+=Ue("MISSING_CONTINUE",s,t),i=null;break}i=i<<6|d&63,s++}if(i!==null){if(i>1114111){s+=Ue("OUT_OF_RANGE",s-1-r,t);continue}if(i>=55296&&i<=57343){s+=Ue("UTF16_SURROGATE",s-1-r,t);continue}if(i<=o){s+=Ue("OVERLONG",s-1-r,t);continue}n.push(i)}}return n}Q(ir,"getUtf8CodePoints");function mn(e){return or(ir(e))}Q(mn,"toUtf8String");var mc=Q(e=>{const t=atob(e),n=new Uint8Array(t.length).map((a,r)=>t.charCodeAt(r));return qi(n)},"decompressBytecode");function gn(e){throw new Error("Didn't expect to get here")}Q(gn,"assertUnreachable");var gc=Object.defineProperty,de=(e,t)=>gc(e,"name",{value:t,configurable:!0}),yc=de(e=>{const{password:t,salt:n,n:s,p:a,r,dklen:o}=e;return Ji(t,n,{N:s,r,p:a,dkLen:o})},"scrypt"),wc=de(e=>Yi(e),"keccak256");function cr(e){const t=v(e,"data");return Ki(t)}de(cr,"ripemd160");var mt=de((e,t="base64")=>{switch(t){case"utf-8":return new TextEncoder().encode(e);case"base64":{const n=atob(e),s=n.length;return new Uint8Array(s).map((r,o)=>n.charCodeAt(o))}case"hex":default:{const n=e.length/2;return new Uint8Array(n).map((a,r)=>{const o=r*2;return parseInt(e.substring(o,o+2),16)})}}},"bufferFromString"),dr=de((e,t,n,s,a)=>{const r={sha256:kt,sha512:Ka}[a];return S(Hi(r,e,t,{c:n,dkLen:s}))},"pbkdf2"),{crypto:Ut,btoa:ur}=globalThis;if(!Ut)throw new l(w.ENV_DEPENDENCY_MISSING,"Could not find 'crypto' in current browser environment.");if(!ur)throw new l(w.ENV_DEPENDENCY_MISSING,"Could not find 'btoa' in current browser environment.");var Kn=de(e=>Ut.getRandomValues(new Uint8Array(e)),"randomBytes"),Kt=de((e,t="base64")=>{switch(t){case"utf-8":return new TextDecoder().decode(e);case"base64":{const n=String.fromCharCode.apply(null,new Uint8Array(e));return ur(n)}case"hex":default:{let n="";for(let s=0;s<e.length;s+=1){const a=e[s].toString(16);n+=a.length===1?`0${a}`:a}return n}}},"stringFromBuffer"),lr="AES-CTR",hr=de((e,t)=>{const n=mt(String(e).normalize("NFKC"),"utf-8"),s=dr(n,t,1e5,32,"sha256");return v(s)},"keyFromPassword"),bc=de(async(e,t)=>{const n=Kn(16),s=Kn(32),a=hr(e,s),r=JSON.stringify(t),o=mt(r,"utf-8"),i={name:lr,counter:n,length:64},c=await crypto.subtle.importKey("raw",a,i,!1,["encrypt"]),d=await crypto.subtle.encrypt(i,c,o);return{data:Kt(new Uint8Array(d)),iv:Kt(n),salt:Kt(s)}},"encrypt"),Ic=de(async(e,t)=>{const n=mt(t.iv),s=mt(t.salt),a=hr(e,s),r=mt(t.data),o={name:lr,counter:n,length:64},i=await crypto.subtle.importKey("raw",a,o,!1,["decrypt"]),c=await crypto.subtle.decrypt(o,i,r),d=new TextDecoder().decode(c);try{return JSON.parse(d)}catch{throw new l(w.INVALID_CREDENTIALS,"Invalid credentials.")}},"decrypt"),Cc=de(async(e,t,n)=>{const s=Ut.subtle,a=new Uint8Array(t.subarray(0,16)),r=n,o=e,i=await s.importKey("raw",a,{name:"AES-CTR",length:128},!1,["encrypt","decrypt"]),c=await s.encrypt({name:"AES-CTR",counter:r,length:128},i,o);return new Uint8Array(c)},"encryptJsonWalletData"),Sc=de(async(e,t,n)=>{const s=Ut.subtle,a=new Uint8Array(t.subarray(0,16)).buffer,r=new Uint8Array(n).buffer,o=new Uint8Array(e).buffer,i=await s.importKey("raw",a,{name:"AES-CTR",length:128},!1,["encrypt","decrypt"]),c=await s.decrypt({name:"AES-CTR",counter:r,length:128},i,o);return new Uint8Array(c)},"decryptJsonWalletData"),vc=de((e,t,n)=>{const s=e==="sha256"?kt:Ka,a=ji.create(s,t).update(n).digest();return S(a)},"computeHmac"),Tc=de(()=>Ut.randomUUID(),"randomUUID"),Rc={bufferFromString:mt,stringFromBuffer:Kt,decrypt:Ic,encrypt:bc,randomBytes:Kn,scrypt:yc,keccak256:wc,decryptJsonWalletData:Sc,encryptJsonWalletData:Cc,computeHmac:vc,pbkdf2:dr,ripemd160:cr,randomUUID:Tc},xc=Rc,{bufferFromString:Ye,decrypt:Ac,encrypt:Pc,randomBytes:we,stringFromBuffer:Et,scrypt:pr,keccak256:fr,decryptJsonWalletData:Ec,encryptJsonWalletData:Oc,pbkdf2:Dc,computeHmac:mr,ripemd160:Nc,randomUUID:Fc}=xc,_c=Object.defineProperty,yn=(e,t)=>_c(e,"name",{value:t,configurable:!0}),Bc=`Fuel Signed Message:
`;function te(e){return S(kt(v(e)))}yn(te,"sha256");function Te(e){return te(e)}yn(Te,"hash");function gr(e){const t=BigInt(e),n=new ArrayBuffer(8),s=new DataView(n);return s.setBigUint64(0,t,!1),new Uint8Array(s.buffer)}yn(gr,"uint64ToBytesBE");function yr(e){if(typeof e=="string")return te(Ce(e));const{personalSign:t}=e,n=typeof t=="string"?Ce(t):t,s=B([Ce(Bc),Ce(String(n.length)),n]);return S(te(s))}yn(yr,"hashMessage");var Mc=Object.defineProperty,U=(e,t)=>Mc(e,"name",{value:t,configurable:!0}),z=class{static{U(this,"Coder")}name;type;encodedLength;constructor(e,t,n){this.name=e,this.type=t,this.encodedLength=n}},Lc="u8",kc="u16",Uc="u32",Gc="u64",$c="u256",zc="raw untyped ptr",Wc="raw untyped slice",Vc="bool",qc="b256",Hc="struct std::b512::B512",an="enum std::option::Option",jc="struct std::vec::Vec",Kc="struct std::bytes::Bytes",Jc="struct std::string::String",Yc="str",Gt="()",wr=/^enum (std::option::)?Option$/m,br=/^str\[(?<length>[0-9]+)\]/,Jn=/^\[(?<item>[\w\s\\[\]]+);\s*(?<length>[0-9]+)\]/,Ir=/^struct.+/,Cr=/^enum.+$/,Xc=/^\((?<items>.*)\)$/,Zc=/^generic.+$/,Qc=/([^\s]+)$/m,gt="1",V=8,We=32,rn=We+2,on=We,Yn=We,Sr=2**32-1,vr=U(({maxInputs:e})=>We+on+e*(on+V)+V,"calculateVmTxMemory"),Tr=V+V+V+V+V+V+V+V+We,Qs=U(e=>e instanceof Uint8Array,"isUint8Array"),It=U(e=>{const t=Array.isArray(e)?e:Object.values(e);for(const n of t)if(n.type===an||"coder"in n&&n.coder.type===an||"coders"in n&&It(n.coders))return!0;return!1},"hasNestedOption"),$=class extends z{static{U(this,"ArrayCoder")}coder;length;#e;constructor(e,t){super("array",`[${e.type}; ${t}]`,t*e.encodedLength),this.coder=e,this.length=t,this.#e=It([e])}encode(e){if(!Array.isArray(e))throw new l(w.ENCODE_ERROR,"Expected array value.");if(this.length!==e.length)throw new l(w.ENCODE_ERROR,"Types/values length mismatch.");return B(Array.from(e).map(t=>this.coder.encode(t)))}decode(e,t){if(!this.#e&&e.length<this.encodedLength||e.length>Sr)throw new l(w.DECODE_ERROR,"Invalid array data size.");let n=t;return[Array(this.length).fill(0).map(()=>{let a;return[a,n]=this.coder.decode(e,n),a}),n]}},F=class extends z{static{U(this,"B256Coder")}constructor(){super("b256","b256",V*4)}encode(e){let t;try{t=v(e)}catch{throw new l(w.ENCODE_ERROR,`Invalid ${this.type}.`)}if(t.length!==this.encodedLength)throw new l(w.ENCODE_ERROR,`Invalid ${this.type}.`);return t}decode(e,t){if(e.length<this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid b256 data size.");let n=e.slice(t,t+this.encodedLength);if(u(n).isZero()&&(n=new Uint8Array(32)),n.length!==this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid b256 byte data size.");return[ls(n,32),t+32]}},ed=class extends z{static{U(this,"B512Coder")}constructor(){super("b512","struct B512",V*8)}encode(e){let t;try{t=v(e)}catch{throw new l(w.ENCODE_ERROR,`Invalid ${this.type}.`)}if(t.length!==this.encodedLength)throw new l(w.ENCODE_ERROR,`Invalid ${this.type}.`);return t}decode(e,t){if(e.length<this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid b512 data size.");let n=e.slice(t,t+this.encodedLength);if(u(n).isZero()&&(n=new Uint8Array(64)),n.length!==this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid b512 byte data size.");return[ls(n,this.encodedLength),t+this.encodedLength]}},td={u64:V,u256:V*4},O=class extends z{static{U(this,"BigNumberCoder")}constructor(e){super("bigNumber",e,td[e])}encode(e){let t;if(typeof e=="number"&&e>Number.MAX_SAFE_INTEGER)throw new l(w.ENCODE_ERROR,`Invalid ${this.type} type - number value is too large. Number can only safely handle up to 53 bits.`);try{t=Se(e,this.encodedLength)}catch{throw new l(w.ENCODE_ERROR,`Invalid ${this.type}.`)}return t}decode(e,t){if(e.length<this.encodedLength)throw new l(w.DECODE_ERROR,`Invalid ${this.type} data size.`);let n=e.slice(t,t+this.encodedLength);if(n=n.slice(0,this.encodedLength),n.length!==this.encodedLength)throw new l(w.DECODE_ERROR,`Invalid ${this.type} byte data size.`);return[u(n),t+this.encodedLength]}},nd=class extends z{static{U(this,"BooleanCoder")}options;constructor(e={padToWordSize:!1}){const t=e.padToWordSize?V:1;super("boolean","boolean",t),this.options=e}encode(e){if(!(e===!0||e===!1))throw new l(w.ENCODE_ERROR,"Invalid boolean value.");return Se(e?1:0,this.encodedLength)}decode(e,t){if(e.length<this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid boolean data size.");const n=u(e.slice(t,t+this.encodedLength));if(n.isZero())return[!1,t+this.encodedLength];if(!n.eq(u(1)))throw new l(w.DECODE_ERROR,"Invalid boolean value.");return[!0,t+this.encodedLength]}},sd=class extends z{static{U(this,"ByteCoder")}static memorySize=1;constructor(){super("struct","struct Bytes",V)}encode(e){const t=e instanceof Uint8Array?e:new Uint8Array(e),n=new O("u64").encode(t.length);return new Uint8Array([...n,...t])}decode(e,t){if(e.length<V)throw new l(w.DECODE_ERROR,"Invalid byte data size.");const n=t+V,s=e.slice(t,n),a=u(new O("u64").decode(s,0)[0]).toNumber(),r=e.slice(n,n+a);if(r.length!==a)throw new l(w.DECODE_ERROR,"Invalid bytes byte data size.");return[r,n+a]}},Rr=class extends z{static{U(this,"EnumCoder")}name;coders;#e;#n;#t;constructor(e,t){const n=new O("u64"),s=Object.values(t).reduce((a,r)=>Math.min(a,r.encodedLength),0);super(`enum ${e}`,`enum ${e}`,n.encodedLength+s),this.name=e,this.coders=t,this.#e=n,this.#n=s,this.#t=!(wr.test(this.type)||It(t))}#s(e){return this.type!==an&&e.type===Gt}#a(e){const t=this.coders[e],n=t.encode([]),s=Object.keys(this.coders).indexOf(e),a=new Uint8Array(this.#n-t.encodedLength);return B([this.#e.encode(s),a,n])}encode(e){if(typeof e=="string"&&this.coders[e])return this.#a(e);const[t,...n]=Object.keys(e);if(!t)throw new l(w.INVALID_DECODE_VALUE,"A field for the case must be provided.");if(n.length!==0)throw new l(w.INVALID_DECODE_VALUE,"Only one field must be provided.");const s=this.coders[t],a=Object.keys(this.coders).indexOf(t);if(a===-1){const o=Object.keys(this.coders).map(i=>`'${i}'`).join(", ");throw new l(w.INVALID_DECODE_VALUE,`Invalid case '${t}'. Valid cases: ${o}.`)}const r=s.encode(e[t]);return new Uint8Array([...this.#e.encode(a),...r])}#r(e,t){return[e,t]}decode(e,t){if(this.#t&&e.length<this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid enum data size.");const n=new O("u64").decode(e,t)[0],s=ze(n),a=Object.keys(this.coders)[s];if(!a)throw new l(w.INVALID_DECODE_VALUE,`Invalid caseIndex "${s}". Valid cases: ${Object.keys(this.coders)}.`);const r=this.coders[a],o=t+this.#e.encodedLength;if(this.#t&&e.length<o+r.encodedLength)throw new l(w.DECODE_ERROR,"Invalid enum data size.");const[i,c]=r.decode(e,o);return this.#s(this.coders[a])?this.#r(a,c):[{[a]:i},c]}},ad=U(e=>{switch(e){case"u8":return 1;case"u16":return 2;case"u32":return 4;default:throw new l(w.TYPE_NOT_SUPPORTED,`Invalid number type: ${e}`)}},"getLength"),P=class extends z{static{U(this,"NumberCoder")}baseType;options;constructor(e,t={padToWordSize:!1}){const n=t.padToWordSize?V:ad(e);super("number",e,n),this.baseType=e,this.options=t}encode(e){let t;try{t=Se(e)}catch{throw new l(w.ENCODE_ERROR,`Invalid ${this.baseType}.`)}if(t.length>this.encodedLength)throw new l(w.ENCODE_ERROR,`Invalid ${this.baseType}, too many bytes.`);return Se(t,this.encodedLength)}decode(e,t){if(e.length<this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid number data size.");const n=e.slice(t,t+this.encodedLength);if(n.length!==this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid number byte data size.");return[ze(n),t+this.encodedLength]}},xr=class extends Rr{static{U(this,"OptionCoder")}encode(e){return super.encode(this.toSwayOption(e))}toSwayOption(e){return e!==void 0?{Some:e}:{None:[]}}decode(e,t){const[n,s]=super.decode(e,t);return[this.toOption(n),s]}toOption(e){if(e&&"Some"in e)return e.Some}},rd=class extends z{static{U(this,"RawSliceCoder")}constructor(){super("raw untyped slice","raw untyped slice",V)}encode(e){if(!Array.isArray(e))throw new l(w.ENCODE_ERROR,"Expected array value.");const n=new $(new P("u8"),e.length).encode(e),s=new O("u64").encode(n.length);return new Uint8Array([...s,...n])}decode(e,t){if(e.length<this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid raw slice data size.");const n=t+V,s=e.slice(t,n),a=u(new O("u64").decode(s,0)[0]).toNumber(),r=e.slice(n,n+a);if(r.length!==a)throw new l(w.DECODE_ERROR,"Invalid raw slice byte data size.");const o=new $(new P("u8"),a),[i]=o.decode(r,0);return[i,n+a]}},fs=class extends z{static{U(this,"StdStringCoder")}static memorySize=1;constructor(){super("struct","struct String",V)}encode(e){const t=Ce(e),n=new O("u64").encode(e.length);return new Uint8Array([...n,...t])}decode(e,t){if(e.length<this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid std string data size.");const n=t+V,s=e.slice(t,n),a=u(new O("u64").decode(s,0)[0]).toNumber(),r=e.slice(n,n+a);if(r.length!==a)throw new l(w.DECODE_ERROR,"Invalid std string byte data size.");return[mn(r),n+a]}},od=class extends z{static{U(this,"StrSliceCoder")}static memorySize=1;constructor(){super("strSlice","str",V)}encode(e){const t=Ce(e),n=new O("u64").encode(e.length);return new Uint8Array([...n,...t])}decode(e,t){if(e.length<this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid string slice data size.");const n=t+V,s=e.slice(t,n),a=u(new O("u64").decode(s,0)[0]).toNumber(),r=e.slice(n,n+a);if(r.length!==a)throw new l(w.DECODE_ERROR,"Invalid string slice byte data size.");return[mn(r),n+a]}},id=class extends z{static{U(this,"StringCoder")}constructor(e){super("string",`str[${e}]`,e)}encode(e){if(e.length!==this.encodedLength)throw new l(w.ENCODE_ERROR,"Value length mismatch during encode.");return Ce(e)}decode(e,t){if(e.length<this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid string data size.");const n=e.slice(t,t+this.encodedLength);if(n.length!==this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid string byte data size.");return[mn(n),t+this.encodedLength]}},wn=class extends z{static{U(this,"StructCoder")}name;coders;#e;constructor(e,t){const n=Object.values(t).reduce((s,a)=>s+a.encodedLength,0);super("struct",`struct ${e}`,n),this.name=e,this.coders=t,this.#e=It(t)}encode(e){return pn(Object.keys(this.coders).map(t=>{const n=this.coders[t],s=e[t];if(!(n instanceof xr)&&s==null)throw new l(w.ENCODE_ERROR,`Invalid ${this.type}. Field "${t}" not present.`);return n.encode(s)}))}decode(e,t){if(!this.#e&&e.length<this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid struct data size.");let n=t;return[Object.keys(this.coders).reduce((a,r)=>{const o=this.coders[r];let i;return[i,n]=o.decode(e,n),a[r]=i,a},{}),n]}},Ar=class extends z{static{U(this,"TupleCoder")}coders;#e;constructor(e){const t=e.reduce((n,s)=>n+s.encodedLength,0);super("tuple",`(${e.map(n=>n.type).join(", ")})`,t),this.coders=e,this.#e=It(e)}encode(e){if(this.coders.length!==e.length)throw new l(w.ENCODE_ERROR,"Types/values length mismatch.");return pn(this.coders.map((t,n)=>t.encode(e[n])))}decode(e,t){if(!this.#e&&e.length<this.encodedLength)throw new l(w.DECODE_ERROR,"Invalid tuple data size.");let n=t;return[this.coders.map(a=>{let r;return[r,n]=a.decode(e,n),r}),n]}},cd=class extends z{static{U(this,"VecCoder")}coder;#e;constructor(e){super("struct","struct Vec",V),this.coder=e,this.#e=It([e])}encode(e){if(!Array.isArray(e)&&!Qs(e))throw new l(w.ENCODE_ERROR,"Expected array value, or a Uint8Array. You can use arrayify to convert a value to a Uint8Array.");const t=new O("u64");if(Qs(e))return new Uint8Array([...t.encode(e.length),...e]);const n=e.map(a=>this.coder.encode(a)),s=t.encode(e.length);return new Uint8Array([...s,...pn(n)])}decode(e,t){if(!this.#e&&e.length<this.encodedLength||e.length>Sr)throw new l(w.DECODE_ERROR,"Invalid vec data size.");const n=t+V,s=e.slice(t,n),a=u(new O("u64").decode(s,0)[0]).toNumber(),r=a*this.coder.encodedLength,o=e.slice(n,n+r);if(!this.#e&&o.length!==r)throw new l(w.DECODE_ERROR,"Invalid vec byte data size.");let i=n;const c=[];for(let d=0;d<a;d++){const[h,f]=this.coder.decode(e,i);c.push(h),i=f}return[c,i]}},Pr=U(e=>{switch(e){case void 0:case gt:return gt;default:throw new l(w.UNSUPPORTED_ENCODING_VERSION,`Encoding version '${e}' is unsupported.`)}},"getEncodingVersion"),_t=U((e,t)=>{const n=e.types.find(s=>s.typeId===t);if(!n)throw new l(w.TYPE_NOT_FOUND,`Type with typeId '${t}' doesn't exist in the ABI.`);return n},"findTypeById"),dd=U((e,t)=>t.filter(n=>_t(e,n.type).type!==Gt),"findNonVoidInputs"),ud=U(e=>{const t=e.find(s=>s.name==="buf"),n=t?.originalTypeArguments?.[0];if(!t||!n)throw new l(w.INVALID_COMPONENT,"The Vec type provided is missing or has a malformed 'buf' component.");return n},"findVectorBufferArgument"),ms=class ct{static{U(this,"ResolvedAbiType")}abi;name;type;originalTypeArguments;components;constructor(t,n){this.abi=t,this.name=n.name;const s=_t(t,n.type);if(s.type.length>256)throw new l(w.INVALID_COMPONENT,`The provided ABI type is too long: ${s.type}.`);this.type=s.type,this.originalTypeArguments=n.typeArguments,this.components=ct.getResolvedGenericComponents(t,n,s.components,s.typeParameters??ct.getImplicitGenericTypeParameters(t,s.components))}static getResolvedGenericComponents(t,n,s,a){if(s===null)return null;if(a===null||a.length===0)return s.map(i=>new ct(t,i));const r=a.reduce((i,c,d)=>{const h={...i};return h[c]=structuredClone(n.typeArguments?.[d]),h},{});return this.resolveGenericArgTypes(t,s,r).map(i=>new ct(t,i))}static resolveGenericArgTypes(t,n,s){return n.map(a=>{if(s[a.type]!==void 0)return{...s[a.type],name:a.name};if(a.typeArguments)return{...structuredClone(a),typeArguments:this.resolveGenericArgTypes(t,a.typeArguments,s)};const r=_t(t,a.type),o=this.getImplicitGenericTypeParameters(t,r.components);return o&&o.length>0?{...structuredClone(a),typeArguments:o.map(i=>s[i])}:a})}static getImplicitGenericTypeParameters(t,n,s){if(!Array.isArray(n))return null;const a=s??[];return n.forEach(r=>{const o=_t(t,r.type);if(Zc.test(o.type)){a.push(o.typeId);return}Array.isArray(r.typeArguments)&&this.getImplicitGenericTypeParameters(t,r.typeArguments,a)}),a.length>0?a:null}getSignature(){const t=this.getArgSignaturePrefix(),n=this.getArgSignatureContent();return`${t}${n}`}getArgSignaturePrefix(){return Ir.test(this.type)?"s":Jn.test(this.type)?"a":Cr.test(this.type)?"e":""}getArgSignatureContent(){if(this.type==="raw untyped ptr")return"rawptr";if(this.type==="raw untyped slice")return"rawslice";const t=br.exec(this.type)?.groups;if(t)return`str[${t.length}]`;if(this.components===null)return this.type;const n=Jn.exec(this.type)?.groups;if(n)return`[${this.components[0].getSignature()};${n.length}]`;const s=this.originalTypeArguments!==null?`<${this.originalTypeArguments.map(r=>new ct(this.abi,r).getSignature()).join(",")}>`:"",a=`(${this.components.map(r=>r.getSignature()).join(",")})`;return`${s}${a}`}},ld=class extends z{static{U(this,"VoidCoder")}constructor(){super("void",Gt,0)}encode(e){return new Uint8Array([])}decode(e,t){return[void 0,t]}};function Xn(e,t){const{getCoder:n}=t;return e.reduce((s,a)=>{const r=s;return r[a.name]=n(a,t),r},{})}U(Xn,"getCoders");var dt=U((e,t)=>{switch(e.type){case Lc:case kc:case Uc:return new P(e.type);case Gc:case zc:return new O("u64");case $c:return new O("u256");case Wc:return new rd;case Vc:return new nd;case qc:return new F;case Hc:return new ed;case Kc:return new sd;case Jc:return new fs;case Yc:return new od;case Gt:return new ld}const n=br.exec(e.type)?.groups;if(n){const d=parseInt(n.length,10);return new id(d)}const s=e.components,a=Jn.exec(e.type)?.groups;if(a){const d=parseInt(a.length,10),h=s[0];if(!h)throw new l(w.INVALID_COMPONENT,"The provided Array type is missing an item of 'component'.");const f=dt(h);return new $(f,d)}if(e.type===jc){const d=ud(s),h=new ms(e.abi,d),f=dt(h,{encoding:gt});return new cd(f)}const r=e.type.match(Qc)?.[0];if(Ir.test(e.type)&&r){const d=Xn(s,{getCoder:dt});return new wn(r,d)}if(Cr.test(e.type)&&r){const d=Xn(s,{getCoder:dt});return e.type===an?new xr(r,d):new Rr(r,d)}if(Xc.exec(e.type)?.groups){const d=s.map(h=>dt(h,{encoding:gt}));return new Ar(d)}throw new l(w.CODER_NOT_FOUND,`Coder not found: ${JSON.stringify(e)}.`)},"getCoder");function Er(e=gt){switch(e){case gt:return dt;default:throw new l(w.UNSUPPORTED_ENCODING_VERSION,`Encoding version ${e} is unsupported.`)}}U(Er,"getCoderForEncoding");var Xe=class{static{U(this,"AbiCoder")}static getCoder(e,t,n={padToWordSize:!1}){const s=new ms(e,t);return Er(n.encoding)(s,n)}static encode(e,t,n,s){return this.getCoder(e,t,s).encode(n)}static decode(e,t,n,s,a){return this.getCoder(e,t,a).decode(n,s)}},hd=U(e=>{const{jsonAbi:t,inputs:n}=e;let s=!1;return n.reduceRight((a,r)=>{const o=_t(t,r.type);return s=s||o.type!==Gt&&!wr.test(o.type),[{...r,isOptional:!s},...a]},[])},"getFunctionInputs"),pd=U((e,t)=>{if(e.length>=t.length)return e;const n=e.slice();return n.length=t.length,n.fill(void 0,e.length),n},"padValuesWithUndefined"),fd=class Zn{static{U(this,"FunctionFragment")}signature;selector;selectorBytes;encoding;name;jsonFn;attributes;jsonAbiOld;jsonFnOld;constructor(t,n){this.jsonFn=n,this.jsonAbiOld=t,this.jsonFnOld=t.functions.find(s=>s.name===n.name),this.name=n.name,this.signature=Zn.getSignature(this.jsonAbiOld,this.jsonFnOld),this.selector=Zn.getFunctionSelector(this.signature),this.selectorBytes=new fs().encode(this.name),this.encoding=Pr(t.encoding),this.attributes=this.jsonFn.attributes??[]}static getSignature(t,n){const s=n.inputs.map(a=>new ms(t,a).getSignature());return`${n.name}(${s.join(",")})`}static getFunctionSelector(t){const n=te(Ye(t,"utf-8"));return u(n.slice(0,10)).toHex(8)}encodeArguments(t){const s=hd({jsonAbi:this.jsonAbiOld,inputs:this.jsonFnOld.inputs}).filter(o=>!o.isOptional).length;if(t.length<s)throw new l(w.ABI_TYPES_AND_VALUES_MISMATCH,`Invalid number of arguments. Expected a minimum of ${s} arguments, received ${t.length}`);const a=this.jsonFnOld.inputs.map(o=>Xe.getCoder(this.jsonAbiOld,o,{encoding:this.encoding})),r=pd(t,this.jsonFn.inputs);return new Ar(a).encode(r)}decodeArguments(t){const n=v(t),s=dd(this.jsonAbiOld,this.jsonFnOld.inputs);if(s.length===0){if(n.length===0)return;throw new l(w.DECODE_ERROR,`Types/values length mismatch during decode. ${JSON.stringify({count:{types:this.jsonFn.inputs.length,nonVoidInputs:s.length,values:n.length},value:{args:this.jsonFn.inputs,nonVoidInputs:s,values:n}})}`)}return this.jsonFnOld.inputs.reduce((r,o)=>{const i=Xe.getCoder(this.jsonAbiOld,o,{encoding:this.encoding}),[c,d]=i.decode(n,r.offset);return{decoded:[...r.decoded,c],offset:d}},{decoded:[],offset:0}).decoded}decodeOutput(t){const n=v(t);return Xe.getCoder(this.jsonAbiOld,this.jsonFnOld.output,{encoding:this.encoding}).decode(n,0)}isReadOnly(){return!this.attributes.find(n=>n.name==="storage")?.arguments?.includes("write")}},md=U((e,t)=>e.find(n=>n.concreteTypeId===t),"findTypeByConcreteId"),gs=U((e,t)=>e.concreteTypes.find(n=>n.concreteTypeId===t),"findConcreteTypeById");function bn(e,t,n){const s=gs(e,n);if(s.metadataTypeId!==void 0)return s.metadataTypeId;const a=md(t,n);return a?a.typeId:(t.push({typeId:t.length,type:s.type,components:In(s.components),concreteTypeId:n,typeParameters:s.typeParameters??null,originalConcreteTypeId:s?.concreteTypeId}),t.length-1)}U(bn,"finsertTypeIdByConcreteTypeId");function ys(e,t,n){return n.typeArguments?.map(s=>{const a=gs(e,s);return{name:"",type:isNaN(s)?bn(e,t,s):s,typeArguments:ys(e,t,a)}})??null}U(ys,"parseFunctionTypeArguments");function Ze(e,t,n,s){const a=bn(e,t,n),r=gs(e,n);return{name:s??"",type:a,typeArguments:ys(e,t,r)}}U(Ze,"parseConcreteType");function In(e,t,n){return n?.map(s=>{const{typeId:a,name:r,typeArguments:o}=s,i=isNaN(a)?bn(e,t,a):a;return{name:r,type:i,typeArguments:In(e,t,o)}})??null}U(In,"parseComponents");function Or(e){if(!e.specVersion)return e;const t=[];e.metadataTypes.forEach(o=>{const i={typeId:o.metadataTypeId,type:o.type,components:o.components??(o.type==="()"?[]:null),typeParameters:o.typeParameters??null};t.push(i)}),t.forEach(o=>{o.components=In(e,t,o.components)});const n=e.functions.map(o=>{const i=o.inputs.map(({concreteTypeId:d,name:h})=>Ze(e,t,d,h)),c=Ze(e,t,o.output,"");return{...o,inputs:i,output:c}}),s=e.configurables.map(o=>({name:o.name,configurableType:Ze(e,t,o.concreteTypeId),offset:o.offset})),a=e.loggedTypes.map(o=>({logId:o.logId,loggedType:Ze(e,t,o.concreteTypeId)}));return{encoding:e.encodingVersion,types:t,functions:n,loggedTypes:a,messagesTypes:e.messagesTypes,configurables:s,errorCodes:e.errorCodes}}U(Or,"transpileAbi");var be=class{static{U(this,"Interface")}functions;configurables;jsonAbi;encoding;jsonAbiOld;constructor(e){this.jsonAbi=e,this.encoding=Pr(e.encodingVersion),this.jsonAbiOld=Or(e),this.functions=Object.fromEntries(this.jsonAbi.functions.map(t=>[t.name,new fd(this.jsonAbiOld,t)])),this.configurables=Object.fromEntries(this.jsonAbi.configurables.map(t=>[t.name,t]))}getFunction(e){const t=Object.values(this.functions).find(n=>n.name===e||n.signature===e||n.selector===e);if(t!==void 0)return t;throw new l(w.FUNCTION_NOT_FOUND,`function ${e} not found: ${JSON.stringify(t)}.`)}decodeFunctionResult(e,t){return(typeof e=="string"?this.getFunction(e):e).decodeOutput(t)}decodeLog(e,t){const n=this.jsonAbiOld.loggedTypes.find(s=>s.logId===t);if(!n)throw new l(w.LOG_TYPE_NOT_FOUND,`Log type with logId '${t}' doesn't exist in the ABI.`);return Xe.decode(this.jsonAbiOld,n.loggedType,v(e),0,{encoding:this.encoding})}encodeConfigurable(e,t){const n=this.jsonAbiOld.configurables.find(s=>s.name===e);if(!n)throw new l(w.CONFIGURABLE_NOT_FOUND,`A configurable with the '${e}' was not found in the ABI.`);return Xe.encode(this.jsonAbiOld,n.configurableType,t,{encoding:this.encoding})}encodeType(e,t){const n=Ze(this.jsonAbi,this.jsonAbiOld.types,e,"");return Xe.encode(this.jsonAbiOld,n,t,{encoding:this.encoding})}decodeType(e,t){const n=Ze(this.jsonAbi,this.jsonAbiOld.types,e,"");return Xe.decode(this.jsonAbiOld,n,t,0,{encoding:this.encoding})}},gd=Object.defineProperty,pe=(e,t)=>gd(e,"name",{value:t,configurable:!0});function tt(e){return e.length===66&&/(0x)[0-9a-f]{64}$/i.test(e)}pe(tt,"isB256");function ws(e){return e.length===130&&/(0x)[0-9a-f]{128}$/i.test(e)}pe(ws,"isPublicKey");function Cn(e){return e.length===42&&/(0x)[0-9a-f]{40}$/i.test(e)}pe(Cn,"isEvmAddress");function Dr(e){return e.toLowerCase()}pe(Dr,"normalizeB256");function Jt(e){return"b256Address"in e}pe(Jt,"isAddress");var Ot=pe(e=>{if(Jt(e))return e;if("address"in e&&Jt(e.address))return e.address;if("id"in e&&Jt(e.id))return e.id;throw new l(l.CODES.INVALID_ADDRESS,"Invalid address")},"addressify"),yd=pe(()=>S(we(32)),"getRandomB256"),wd=pe(e=>{try{if(!tt(e))throw new l(l.CODES.INVALID_B256_ADDRESS,`Invalid B256 Address: ${e}.`);const t=v(e).slice(12),n=new Uint8Array(12).fill(0);return S(B([n,t]))}catch{throw new l(l.CODES.PARSE_FAILED,`Cannot generate EVM Address B256 from: ${e}.`)}},"toB256AddressEvm"),bd=pe(e=>{if(!Cn(e))throw new l(l.CODES.INVALID_EVM_ADDRESS,"Invalid EVM address format.");return e.replace("0x","0x000000000000000000000000")},"padFirst12BytesOfEvmAddress"),Id=pe(e=>bd(e),"fromEvmAddressToB256"),Nr=pe(e=>{if(!ws(e))throw new l(l.CODES.INVALID_PUBLIC_KEY,`Invalid Public Key: ${e}.`);return S(kt(v(e)))},"fromPublicKeyToB256"),Cd=pe(e=>{if(typeof e!="string"&&"toB256"in e)return e.toB256();if(tt(e))return e;if(ws(e))return Nr(e);if(Cn(e))return Id(e);throw new l(l.CODES.PARSE_FAILED,"Unknown address format: only 'B256', 'Public Key (512)', or 'EVM Address' are supported.")},"fromDynamicInputToB256"),G=class Re{static{pe(this,"Address")}b256Address;constructor(t){const n=Cd(t);this.b256Address=Dr(n)}toChecksum(){return Re.toChecksum(this.b256Address)}toAddress(){return this.b256Address}toB256(){return this.b256Address}toBytes(){return v(this.b256Address)}toHexString(){return this.toB256()}toString(){return this.toChecksum()}toJSON(){return this.b256Address}toEvmAddress(){return{bits:wd(this.b256Address)}}toAssetId(){return{bits:this.b256Address}}valueOf(){return this.toChecksum()}equals(t){return this.toChecksum()===t.toChecksum()}static fromPublicKey(t){const n=Nr(t);return new Re(n)}static fromB256(t){if(!tt(t))throw new l(l.CODES.INVALID_B256_ADDRESS,`Invalid B256 Address: ${t}.`);return new Re(t)}static fromRandom(){return new Re(yd())}static fromString(t){return new Re(t)}static fromAddressOrString(t){return new Re(t)}static fromDynamicInput(t){return new Re(t)}static fromEvmAddress(t){if(!Cn(t))throw new l(l.CODES.INVALID_EVM_ADDRESS,`Invalid Evm Address: ${t}.`);return new Re(t)}static isChecksumValid(t){let n=t;return t.startsWith("0x")||(n=`0x${t}`),n.trim().length!==66?!1:Re.toChecksum(S(n))===n}static toChecksum(t){if(!tt(t))throw new l(l.CODES.INVALID_B256_ADDRESS,`Invalid B256 Address: ${t}.`);const n=S(t).toLowerCase().slice(2),s=kt(n);let a="0x";for(let r=0;r<32;++r){const o=s[r],i=n.charAt(r*2),c=n.charAt(r*2+1);a+=(o&240)>=128?i.toUpperCase():i,a+=(o&15)>=8?c.toUpperCase():c}return a}},Sd=Object.defineProperty,X=(e,t)=>Sd(e,"name",{value:t,configurable:!0}),Z=class extends z{static{X(this,"ByteArrayCoder")}length;#e;constructor(e){const t=(8-e%8)%8,n=e+t;super("ByteArray",`[u64; ${n/4}]`,n),this.length=e,this.#e=t}encode(e){const t=[],n=v(e);return t.push(n),this.#e&&t.push(new Uint8Array(this.#e)),B(t)}decode(e,t){let n,s=t;[n,s]=[S(e.slice(s,s+this.length)),s+this.length];const a=n;return this.#e&&([n,s]=[null,s+this.#e]),[a,s]}},nt=class extends wn{static{X(this,"TxPointerCoder")}constructor(){super("TxPointer",{blockHeight:new P("u32",{padToWordSize:!0}),txIndex:new P("u16",{padToWordSize:!0})})}static decodeFromGqlScalar(e){if(e.length!==12)throw new l(w.DECODE_ERROR,`Invalid TxPointer scalar string length ${e.length}. It must have length 12.`);const[t,n]=[e.substring(0,8),e.substring(8)];return{blockHeight:parseInt(t,16),txIndex:parseInt(n,16)}}},H=(e=>(e[e.Coin=0]="Coin",e[e.Contract=1]="Contract",e[e.Message=2]="Message",e))(H||{}),ea=class extends z{static{X(this,"InputCoinCoder")}constructor(){super("InputCoin","struct InputCoin",0)}encode(e){const t=[];return t.push(new F().encode(e.txID)),t.push(new P("u16",{padToWordSize:!0}).encode(e.outputIndex)),t.push(new F().encode(e.owner)),t.push(new O("u64").encode(e.amount)),t.push(new F().encode(e.assetId)),t.push(new nt().encode(e.txPointer)),t.push(new P("u16",{padToWordSize:!0}).encode(e.witnessIndex)),t.push(new O("u64").encode(e.predicateGasUsed)),t.push(new O("u64").encode(e.predicateLength)),t.push(new O("u64").encode(e.predicateDataLength)),t.push(new Z(e.predicateLength.toNumber()).encode(e.predicate)),t.push(new Z(e.predicateDataLength.toNumber()).encode(e.predicateData)),B(t)}decode(e,t){let n,s=t;[n,s]=new F().decode(e,s);const a=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const r=n;[n,s]=new F().decode(e,s);const o=n;[n,s]=new O("u64").decode(e,s);const i=n;[n,s]=new F().decode(e,s);const c=n;[n,s]=new nt().decode(e,s);const d=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const h=Number(n);[n,s]=new O("u64").decode(e,s);const f=n;[n,s]=new O("u64").decode(e,s);const b=n;[n,s]=new O("u64").decode(e,s);const g=n;[n,s]=new Z(b.toNumber()).decode(e,s);const I=n;return[n,s]=new Z(g.toNumber()).decode(e,s),[{type:0,txID:a,outputIndex:r,owner:o,amount:i,assetId:c,txPointer:d,witnessIndex:h,predicateGasUsed:f,predicateLength:b,predicateDataLength:g,predicate:I,predicateData:n},s]}},cn=class extends z{static{X(this,"InputContractCoder")}constructor(){super("InputContract","struct InputContract",0)}encode(e){const t=[];return t.push(new F().encode(e.txID)),t.push(new P("u16",{padToWordSize:!0}).encode(e.outputIndex)),t.push(new F().encode(e.balanceRoot)),t.push(new F().encode(e.stateRoot)),t.push(new nt().encode(e.txPointer)),t.push(new F().encode(e.contractID)),B(t)}decode(e,t){let n,s=t;[n,s]=new F().decode(e,s);const a=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const r=n;[n,s]=new F().decode(e,s);const o=n;[n,s]=new F().decode(e,s);const i=n;[n,s]=new nt().decode(e,s);const c=n;return[n,s]=new F().decode(e,s),[{type:1,txID:a,outputIndex:r,balanceRoot:o,stateRoot:i,txPointer:c,contractID:n},s]}},Qe=class Fr extends z{static{X(this,"InputMessageCoder")}constructor(){super("InputMessage","struct InputMessage",0)}static getMessageId(t){const n=[];return n.push(new Z(32).encode(t.sender)),n.push(new Z(32).encode(t.recipient)),n.push(new Z(32).encode(t.nonce)),n.push(new O("u64").encode(t.amount)),n.push(v(t.data||"0x")),te(B(n))}static encodeData(t){const n=v(t||"0x"),s=n.length;return new Z(s).encode(n)}encode(t){const n=[],s=Fr.encodeData(t.data);return n.push(new Z(32).encode(t.sender)),n.push(new Z(32).encode(t.recipient)),n.push(new O("u64").encode(t.amount)),n.push(new Z(32).encode(t.nonce)),n.push(new P("u16",{padToWordSize:!0}).encode(t.witnessIndex)),n.push(new O("u64").encode(t.predicateGasUsed)),n.push(new O("u64").encode(s.length)),n.push(new O("u64").encode(t.predicateLength)),n.push(new O("u64").encode(t.predicateDataLength)),n.push(new Z(s.length).encode(s)),n.push(new Z(t.predicateLength.toNumber()).encode(t.predicate)),n.push(new Z(t.predicateDataLength.toNumber()).encode(t.predicateData)),B(n)}static decodeData(t){const n=v(t),s=n.length,[a]=new Z(s).decode(n,0);return v(a)}decode(t,n){let s,a=n;[s,a]=new F().decode(t,a);const r=s;[s,a]=new F().decode(t,a);const o=s;[s,a]=new O("u64").decode(t,a);const i=s;[s,a]=new F().decode(t,a);const c=s;[s,a]=new P("u16",{padToWordSize:!0}).decode(t,a);const d=Number(s);[s,a]=new O("u64").decode(t,a);const h=s;[s,a]=new P("u32",{padToWordSize:!0}).decode(t,a);const f=s;[s,a]=new O("u64").decode(t,a);const b=s;[s,a]=new O("u64").decode(t,a);const g=s;[s,a]=new Z(f).decode(t,a);const I=s;[s,a]=new Z(b.toNumber()).decode(t,a);const m=s;return[s,a]=new Z(g.toNumber()).decode(t,a),[{type:2,sender:r,recipient:o,amount:i,witnessIndex:d,nonce:c,predicateGasUsed:h,dataLength:f,predicateLength:b,predicateDataLength:g,data:I,predicate:m,predicateData:s},a]}},Ee=class extends z{static{X(this,"InputCoder")}constructor(){super("Input","struct Input",0)}encode(e){const t=[];t.push(new P("u8",{padToWordSize:!0}).encode(e.type));const{type:n}=e;switch(n){case 0:{t.push(new ea().encode(e));break}case 1:{t.push(new cn().encode(e));break}case 2:{t.push(new Qe().encode(e));break}default:throw new l(w.INVALID_TRANSACTION_INPUT,`Invalid transaction input type: ${n}.`)}return B(t)}decode(e,t){let n,s=t;[n,s]=new P("u8",{padToWordSize:!0}).decode(e,s);const a=n;switch(a){case 0:return[n,s]=new ea().decode(e,s),[n,s];case 1:return[n,s]=new cn().decode(e,s),[n,s];case 2:return[n,s]=new Qe().decode(e,s),[n,s];default:throw new l(w.INVALID_TRANSACTION_INPUT,`Invalid transaction input type: ${a}.`)}}},k=(e=>(e[e.Coin=0]="Coin",e[e.Contract=1]="Contract",e[e.Change=2]="Change",e[e.Variable=3]="Variable",e[e.ContractCreated=4]="ContractCreated",e))(k||{}),ta=class extends z{static{X(this,"OutputCoinCoder")}constructor(){super("OutputCoin","struct OutputCoin",0)}encode(e){const t=[];return t.push(new F().encode(e.to)),t.push(new O("u64").encode(e.amount)),t.push(new F().encode(e.assetId)),B(t)}decode(e,t){let n,s=t;[n,s]=new F().decode(e,s);const a=n;[n,s]=new O("u64").decode(e,s);const r=n;return[n,s]=new F().decode(e,s),[{type:0,to:a,amount:r,assetId:n},s]}},dn=class extends z{static{X(this,"OutputContractCoder")}constructor(){super("OutputContract","struct OutputContract",0)}encode(e){const t=[];return t.push(new P("u8",{padToWordSize:!0}).encode(e.inputIndex)),t.push(new F().encode(e.balanceRoot)),t.push(new F().encode(e.stateRoot)),B(t)}decode(e,t){let n,s=t;[n,s]=new P("u8",{padToWordSize:!0}).decode(e,s);const a=n;[n,s]=new F().decode(e,s);const r=n;return[n,s]=new F().decode(e,s),[{type:1,inputIndex:a,balanceRoot:r,stateRoot:n},s]}},na=class extends z{static{X(this,"OutputChangeCoder")}constructor(){super("OutputChange","struct OutputChange",0)}encode(e){const t=[];return t.push(new F().encode(e.to)),t.push(new O("u64").encode(e.amount)),t.push(new F().encode(e.assetId)),B(t)}decode(e,t){let n,s=t;[n,s]=new F().decode(e,s);const a=n;[n,s]=new O("u64").decode(e,s);const r=n;return[n,s]=new F().decode(e,s),[{type:2,to:a,amount:r,assetId:n},s]}},sa=class extends z{static{X(this,"OutputVariableCoder")}constructor(){super("OutputVariable","struct OutputVariable",0)}encode(e){const t=[];return t.push(new F().encode(e.to)),t.push(new O("u64").encode(e.amount)),t.push(new F().encode(e.assetId)),B(t)}decode(e,t){let n,s=t;[n,s]=new F().decode(e,s);const a=n;[n,s]=new O("u64").decode(e,s);const r=n;return[n,s]=new F().decode(e,s),[{type:3,to:a,amount:r,assetId:n},s]}},aa=class extends z{static{X(this,"OutputContractCreatedCoder")}constructor(){super("OutputContractCreated","struct OutputContractCreated",0)}encode(e){const t=[];return t.push(new F().encode(e.contractId)),t.push(new F().encode(e.stateRoot)),B(t)}decode(e,t){let n,s=t;[n,s]=new F().decode(e,s);const a=n;return[n,s]=new F().decode(e,s),[{type:4,contractId:a,stateRoot:n},s]}},Oe=class extends z{static{X(this,"OutputCoder")}constructor(){super("Output"," struct Output",0)}encode(e){const t=[];t.push(new P("u8",{padToWordSize:!0}).encode(e.type));const{type:n}=e;switch(n){case 0:{t.push(new ta().encode(e));break}case 1:{t.push(new dn().encode(e));break}case 2:{t.push(new na().encode(e));break}case 3:{t.push(new sa().encode(e));break}case 4:{t.push(new aa().encode(e));break}default:throw new l(w.INVALID_TRANSACTION_OUTPUT,`Invalid transaction output type: ${n}.`)}return B(t)}decode(e,t){let n,s=t;[n,s]=new P("u8",{padToWordSize:!0}).decode(e,s);const a=n;switch(a){case 0:return[n,s]=new ta().decode(e,s),[n,s];case 1:return[n,s]=new dn().decode(e,s),[n,s];case 2:return[n,s]=new na().decode(e,s),[n,s];case 3:return[n,s]=new sa().decode(e,s),[n,s];case 4:return[n,s]=new aa().decode(e,s),[n,s];default:throw new l(w.INVALID_TRANSACTION_OUTPUT,`Invalid transaction output type: ${a}.`)}}},ie=(e=>(e[e.Tip=1]="Tip",e[e.WitnessLimit=2]="WitnessLimit",e[e.Maturity=4]="Maturity",e[e.MaxFee=8]="MaxFee",e[e.Expiration=16]="Expiration",e))(ie||{}),vd=X(e=>e.sort((t,n)=>t.type-n.type),"sortPolicies");function _r(e){const t=new Set;e.forEach(n=>{if(t.has(n.type))throw new l(w.DUPLICATED_POLICY,"Duplicate policy type found: 8");t.add(n.type)})}X(_r,"validateDuplicatedPolicies");var De=class extends z{static{X(this,"PoliciesCoder")}constructor(){super("Policies","array Policy",0)}encode(e){_r(e);const t=vd(e),n=[];return t.forEach(({data:s,type:a})=>{switch(a){case 8:case 1:case 2:n.push(new O("u64").encode(s));break;case 4:case 16:n.push(new P("u32",{padToWordSize:!0}).encode(s));break;default:throw new l(w.INVALID_POLICY_TYPE,`Invalid policy type: ${a}`)}}),B(n)}decode(e,t,n){let s=t;const a=[];if(n&1){const[r,o]=new O("u64").decode(e,s);s=o,a.push({type:1,data:r})}if(n&2){const[r,o]=new O("u64").decode(e,s);s=o,a.push({type:2,data:r})}if(n&4){const[r,o]=new P("u32",{padToWordSize:!0}).decode(e,s);s=o,a.push({type:4,data:r})}if(n&8){const[r,o]=new O("u64").decode(e,s);s=o,a.push({type:8,data:r})}if(n&16){const[r,o]=new P("u32",{padToWordSize:!0}).decode(e,s);s=o,a.push({type:16,data:r})}return[a,s]}},L=(e=>(e[e.Call=0]="Call",e[e.Return=1]="Return",e[e.ReturnData=2]="ReturnData",e[e.Panic=3]="Panic",e[e.Revert=4]="Revert",e[e.Log=5]="Log",e[e.LogData=6]="LogData",e[e.Transfer=7]="Transfer",e[e.TransferOut=8]="TransferOut",e[e.ScriptResult=9]="ScriptResult",e[e.MessageOut=10]="MessageOut",e[e.Mint=11]="Mint",e[e.Burn=12]="Burn",e))(L||{}),ra=X((e,t)=>{const n=v(e),s=v(t);return te(B([n,s]))},"getMintedAssetId"),oa=class extends wn{static{X(this,"StorageSlotCoder")}constructor(){super("StorageSlot",{key:new F,value:new F})}},me=(e=>(e[e.ConsensusParameters=0]="ConsensusParameters",e[e.StateTransition=1]="StateTransition",e))(me||{}),ia=class extends z{static{X(this,"UpgradePurposeCoder")}constructor(){super("UpgradePurpose","UpgradePurpose",0)}encode(e){const t=[],{type:n}=e;switch(t.push(new P("u8",{padToWordSize:!0}).encode(n)),n){case 0:{const s=e.data;t.push(new P("u16",{padToWordSize:!0}).encode(s.witnessIndex)),t.push(new F().encode(s.checksum));break}case 1:{const s=e.data;t.push(new F().encode(s.bytecodeRoot));break}default:throw new l(w.UNSUPPORTED_TRANSACTION_TYPE,`Unsupported transaction type: ${n}`)}return B(t)}decode(e,t){let n=t,s;[s,n]=new P("u8",{padToWordSize:!0}).decode(e,n);const a=s;switch(a){case 0:{[s,n]=new P("u16",{padToWordSize:!0}).decode(e,n);const r=s;return[s,n]=new F().decode(e,n),[{type:a,data:{witnessIndex:r,checksum:s}},n]}case 1:return[s,n]=new F().decode(e,n),[{type:a,data:{bytecodeRoot:s}},n];default:throw new l(w.UNSUPPORTED_TRANSACTION_TYPE,`Unsupported transaction type: ${a}`)}}},Ne=class extends z{static{X(this,"WitnessCoder")}constructor(){super("Witness","unknown",0)}encode(e){const t=[];return t.push(new P("u32",{padToWordSize:!0}).encode(e.dataLength)),t.push(new Z(e.dataLength).encode(e.data)),B(t)}decode(e,t){let n,s=t;[n,s]=new P("u32",{padToWordSize:!0}).decode(e,s);const a=n;return[n,s]=new Z(a).decode(e,s),[{dataLength:a,data:n},s]}},j=(e=>(e[e.Script=0]="Script",e[e.Create=1]="Create",e[e.Mint=2]="Mint",e[e.Upgrade=3]="Upgrade",e[e.Upload=4]="Upload",e[e.Blob=5]="Blob",e))(j||{}),ca=class extends z{static{X(this,"TransactionScriptCoder")}constructor(){super("TransactionScript","struct TransactionScript",0)}encode(e){const t=[];return t.push(new O("u64").encode(e.scriptGasLimit)),t.push(new F().encode(e.receiptsRoot)),t.push(new O("u64").encode(e.scriptLength)),t.push(new O("u64").encode(e.scriptDataLength)),t.push(new P("u32",{padToWordSize:!0}).encode(e.policyTypes)),t.push(new P("u16",{padToWordSize:!0}).encode(e.inputsCount)),t.push(new P("u16",{padToWordSize:!0}).encode(e.outputsCount)),t.push(new P("u16",{padToWordSize:!0}).encode(e.witnessesCount)),t.push(new Z(e.scriptLength.toNumber()).encode(e.script)),t.push(new Z(e.scriptDataLength.toNumber()).encode(e.scriptData)),t.push(new De().encode(e.policies)),t.push(new $(new Ee,e.inputsCount).encode(e.inputs)),t.push(new $(new Oe,e.outputsCount).encode(e.outputs)),t.push(new $(new Ne,e.witnessesCount).encode(e.witnesses)),B(t)}decode(e,t){let n,s=t;[n,s]=new O("u64").decode(e,s);const a=n;[n,s]=new F().decode(e,s);const r=n;[n,s]=new O("u64").decode(e,s);const o=n;[n,s]=new O("u64").decode(e,s);const i=n;[n,s]=new P("u32",{padToWordSize:!0}).decode(e,s);const c=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const d=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const h=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const f=n;[n,s]=new Z(o.toNumber()).decode(e,s);const b=n;[n,s]=new Z(i.toNumber()).decode(e,s);const g=n;[n,s]=new De().decode(e,s,c);const I=n;[n,s]=new $(new Ee,d).decode(e,s);const m=n;[n,s]=new $(new Oe,h).decode(e,s);const y=n;return[n,s]=new $(new Ne,f).decode(e,s),[{type:0,scriptGasLimit:a,scriptLength:o,scriptDataLength:i,policyTypes:c,inputsCount:d,outputsCount:h,witnessesCount:f,receiptsRoot:r,script:b,scriptData:g,policies:I,inputs:m,outputs:y,witnesses:n},s]}},da=class extends z{static{X(this,"TransactionCreateCoder")}constructor(){super("TransactionCreate","struct TransactionCreate",0)}encode(e){const t=[];return t.push(new P("u16",{padToWordSize:!0}).encode(e.bytecodeWitnessIndex)),t.push(new F().encode(e.salt)),t.push(new O("u64").encode(e.storageSlotsCount)),t.push(new P("u32",{padToWordSize:!0}).encode(e.policyTypes)),t.push(new P("u16",{padToWordSize:!0}).encode(e.inputsCount)),t.push(new P("u16",{padToWordSize:!0}).encode(e.outputsCount)),t.push(new P("u16",{padToWordSize:!0}).encode(e.witnessesCount)),t.push(new $(new oa,e.storageSlotsCount.toNumber()).encode(e.storageSlots)),t.push(new De().encode(e.policies)),t.push(new $(new Ee,e.inputsCount).encode(e.inputs)),t.push(new $(new Oe,e.outputsCount).encode(e.outputs)),t.push(new $(new Ne,e.witnessesCount).encode(e.witnesses)),B(t)}decode(e,t){let n,s=t;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const a=n;[n,s]=new F().decode(e,s);const r=n;[n,s]=new O("u64").decode(e,s);const o=n;[n,s]=new P("u32",{padToWordSize:!0}).decode(e,s);const i=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const c=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const d=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const h=n;[n,s]=new $(new oa,o.toNumber()).decode(e,s);const f=n;[n,s]=new De().decode(e,s,i);const b=n;[n,s]=new $(new Ee,c).decode(e,s);const g=n;[n,s]=new $(new Oe,d).decode(e,s);const I=n;return[n,s]=new $(new Ne,h).decode(e,s),[{type:1,bytecodeWitnessIndex:a,policyTypes:i,storageSlotsCount:o,inputsCount:c,outputsCount:d,witnessesCount:h,salt:r,policies:b,storageSlots:f,inputs:g,outputs:I,witnesses:n},s]}},ua=class extends z{static{X(this,"TransactionMintCoder")}constructor(){super("TransactionMint","struct TransactionMint",0)}encode(e){const t=[];return t.push(new nt().encode(e.txPointer)),t.push(new cn().encode(e.inputContract)),t.push(new dn().encode(e.outputContract)),t.push(new O("u64").encode(e.mintAmount)),t.push(new F().encode(e.mintAssetId)),t.push(new O("u64").encode(e.gasPrice)),B(t)}decode(e,t){let n,s=t;[n,s]=new nt().decode(e,s);const a=n;[n,s]=new cn().decode(e,s);const r=n;[n,s]=new dn().decode(e,s);const o=n;[n,s]=new O("u64").decode(e,s);const i=n;[n,s]=new F().decode(e,s);const c=n;return[n,s]=new O("u64").decode(e,s),[{type:2,txPointer:a,inputContract:r,outputContract:o,mintAmount:i,mintAssetId:c,gasPrice:n},s]}},la=class extends z{static{X(this,"TransactionUpgradeCoder")}constructor(){super("TransactionUpgrade","struct TransactionUpgrade",0)}encode(e){const t=[];return t.push(new ia().encode(e.upgradePurpose)),t.push(new P("u32",{padToWordSize:!0}).encode(e.policyTypes)),t.push(new P("u16",{padToWordSize:!0}).encode(e.inputsCount)),t.push(new P("u16",{padToWordSize:!0}).encode(e.outputsCount)),t.push(new P("u16",{padToWordSize:!0}).encode(e.witnessesCount)),t.push(new De().encode(e.policies)),t.push(new $(new Ee,e.inputsCount).encode(e.inputs)),t.push(new $(new Oe,e.outputsCount).encode(e.outputs)),t.push(new $(new Ne,e.witnessesCount).encode(e.witnesses)),B(t)}decode(e,t){let n,s=t;[n,s]=new ia().decode(e,s);const a=n;[n,s]=new P("u32",{padToWordSize:!0}).decode(e,s);const r=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const o=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const i=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const c=n;[n,s]=new De().decode(e,s,r);const d=n;[n,s]=new $(new Ee,o).decode(e,s);const h=n;[n,s]=new $(new Oe,i).decode(e,s);const f=n;return[n,s]=new $(new Ne,c).decode(e,s),[{type:3,upgradePurpose:a,policyTypes:r,inputsCount:o,outputsCount:i,witnessesCount:c,policies:d,inputs:h,outputs:f,witnesses:n},s]}},ha=class extends z{static{X(this,"TransactionUploadCoder")}constructor(){super("TransactionUpload","struct TransactionUpload",0)}encode(e){const t=[];return t.push(new F().encode(e.root)),t.push(new P("u16",{padToWordSize:!0}).encode(e.witnessIndex)),t.push(new P("u16",{padToWordSize:!0}).encode(e.subsectionIndex)),t.push(new P("u16",{padToWordSize:!0}).encode(e.subsectionsNumber)),t.push(new P("u16",{padToWordSize:!0}).encode(e.proofSetCount)),t.push(new P("u32",{padToWordSize:!0}).encode(e.policyTypes)),t.push(new P("u16",{padToWordSize:!0}).encode(e.inputsCount)),t.push(new P("u16",{padToWordSize:!0}).encode(e.outputsCount)),t.push(new P("u16",{padToWordSize:!0}).encode(e.witnessesCount)),t.push(new $(new F,e.proofSetCount).encode(e.proofSet)),t.push(new De().encode(e.policies)),t.push(new $(new Ee,e.inputsCount).encode(e.inputs)),t.push(new $(new Oe,e.outputsCount).encode(e.outputs)),t.push(new $(new Ne,e.witnessesCount).encode(e.witnesses)),B(t)}decode(e,t){let n,s=t;[n,s]=new F().decode(e,s);const a=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const r=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const o=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const i=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const c=n;[n,s]=new P("u32",{padToWordSize:!0}).decode(e,s);const d=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const h=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const f=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const b=n;[n,s]=new $(new F,c).decode(e,s);const g=n;[n,s]=new De().decode(e,s,d);const I=n;[n,s]=new $(new Ee,h).decode(e,s);const m=n;[n,s]=new $(new Oe,f).decode(e,s);const y=n;return[n,s]=new $(new Ne,b).decode(e,s),[{type:4,root:a,witnessIndex:r,subsectionIndex:o,subsectionsNumber:i,proofSetCount:c,policyTypes:d,inputsCount:h,outputsCount:f,witnessesCount:b,proofSet:g,policies:I,inputs:m,outputs:y,witnesses:n},s]}},pa=class extends z{static{X(this,"TransactionBlobCoder")}constructor(){super("TransactionBlob","struct TransactionBlob",0)}encode(e){const t=[];return t.push(new F().encode(e.blobId)),t.push(new P("u16",{padToWordSize:!0}).encode(e.witnessIndex)),t.push(new P("u32",{padToWordSize:!0}).encode(e.policyTypes)),t.push(new P("u16",{padToWordSize:!0}).encode(e.inputsCount)),t.push(new P("u16",{padToWordSize:!0}).encode(e.outputsCount)),t.push(new P("u16",{padToWordSize:!0}).encode(e.witnessesCount)),t.push(new De().encode(e.policies)),t.push(new $(new Ee,e.inputsCount).encode(e.inputs)),t.push(new $(new Oe,e.outputsCount).encode(e.outputs)),t.push(new $(new Ne,e.witnessesCount).encode(e.witnesses)),B(t)}decode(e,t){let n,s=t;[n,s]=new F().decode(e,s);const a=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const r=n;[n,s]=new P("u32",{padToWordSize:!0}).decode(e,s);const o=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const i=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const c=n;[n,s]=new P("u16",{padToWordSize:!0}).decode(e,s);const d=n;[n,s]=new De().decode(e,s,o);const h=n;[n,s]=new $(new Ee,i).decode(e,s);const f=n;[n,s]=new $(new Oe,c).decode(e,s);const b=n;return[n,s]=new $(new Ne,d).decode(e,s),[{type:5,blobId:a,witnessIndex:r,policyTypes:o,inputsCount:i,outputsCount:c,witnessesCount:d,policies:h,inputs:f,outputs:b,witnesses:n},s]}},ve=class extends z{static{X(this,"TransactionCoder")}constructor(){super("Transaction","struct Transaction",0)}encode(e){const t=[];t.push(new P("u8",{padToWordSize:!0}).encode(e.type));const{type:n}=e;switch(e.type){case 0:{t.push(new ca().encode(e));break}case 1:{t.push(new da().encode(e));break}case 2:{t.push(new ua().encode(e));break}case 3:{t.push(new la().encode(e));break}case 4:{t.push(new ha().encode(e));break}case 5:{t.push(new pa().encode(e));break}default:throw new l(w.UNSUPPORTED_TRANSACTION_TYPE,`Unsupported transaction type: ${n}`)}return B(t)}decode(e,t){let n,s=t;[n,s]=new P("u8",{padToWordSize:!0}).decode(e,s);const a=n;switch(a){case 0:return[n,s]=new ca().decode(e,s),[n,s];case 1:return[n,s]=new da().decode(e,s),[n,s];case 2:return[n,s]=new ua().decode(e,s),[n,s];case 3:return[n,s]=new la().decode(e,s),[n,s];case 4:return[n,s]=new ha().decode(e,s),[n,s];case 5:return[n,s]=new pa().decode(e,s),[n,s];default:throw new l(w.UNSUPPORTED_TRANSACTION_TYPE,`Unsupported transaction type: ${a}`)}}};(class extends wn{static{X(this,"UtxoIdCoder")}constructor(){super("UtxoId",{transactionId:new F,outputIndex:new P("u16",{padToWordSize:!0})})}});var K="0x0000000000000000000000000000000000000000000000000000000000000000",Br="0xffffffffffff0000",bs="0xffffffffffff0001",Mr="0xffffffffffff0003",Lr="0xffffffffffff0004",kr="0xffffffffffff0005",Td="0xffffffffffff0006",Rd=["ArithmeticError","ArithmeticOverflow","AssetIdNotFound","BalanceOverflow","BlobIdAlreadyUploaded","BlobNotFound","BytecodeAlreadyUploaded","CanNotGetGasPriceInPredicate","ContractIdAlreadyDeployed","ContractInstructionNotAllowed","ContractMaxSize","ContractMismatch","ContractNotFound","ContractNotInInputs","EcalError","ExpectedCoinInput","ExpectedInternalContext","ExpectedNestedCaller","ExpectedOutputVariable","ExpectedParentInternalContext","ExpectedUnallocatedStack","GasCostNotDefined","InputContractDoesNotExist","InputNotFound","InternalBalanceOverflow","InvalidBlockHeight","InvalidEllipticCurvePoint","InvalidFlags","InvalidImmediateValue","InvalidInstruction","InvalidMetadataIdentifier","InvalidUpgradePurposeType","MalformedCallStructure","MaxStaticContractsReached","MemoryGrowthOverlap","MemoryNotExecutable","MemoryOverflow","MemoryOwnership","MemoryWriteOverlap","MessageDataTooLong","NotEnoughBalance","OutOfGas","OutputNotFound","OverridingConsensusParameters","OverridingStateTransactionBytecode","PolicyIsNotSet","PolicyNotFound","PredicateReturnedNonOne","ProofInUploadNotFound","ReservedRegisterNotWritable","Revert","StorageSlotsNotFound","ThePartIsNotSequentiallyConnected","TooManyReceipts","TooManySlots","TransactionMaturity","TransactionValidity","TransferAmountCannotBeZero","TransferZeroCoins","UninitalizedMemoryAccess","UnknownPanicReason","UnknownStateTransactionBytecodeRoot","UnsupportedCurveId","UnsupportedOperationType","WitnessNotFound"],xd="https://docs.rs/fuel-asm/latest/fuel_asm/enum.PanicReason.html",Ad={FAILED_REQUIRE_SIGNAL:Br,FAILED_TRANSFER_TO_ADDRESS_SIGNAL:bs,FAILED_ASSERT_EQ_SIGNAL:Mr,FAILED_ASSERT_SIGNAL:Lr,FAILED_ASSERT_NE_SIGNAL:kr,REVERT_WITH_LOG_SIGNAL:Td},Pd=Object.defineProperty,se=(e,t)=>Pd(e,"name",{value:t,configurable:!0}),Ed="0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",Od=class{static{se(this,"Node")}left;right;parent;hash;data;index;constructor(e,t,n,s,a,r=0){this.left=e,this.right=t,this.parent=n,this.hash=s,this.data=a,this.index=r}},un=Od;function Is(e){return Te("0x00".concat(e.slice(2)))}se(Is,"hashLeaf");function Cs(e,t){return Te("0x01".concat(e.slice(2)).concat(t.slice(2)))}se(Cs,"hashNode");function Dd(e){const t=[];for(let o=0;o<e.length;o+=1){const i=Is(e[o]),c=new un(-1,-1,-1,i,e[o]);c.index=o,t.push(c)}const n=[...t];let s=[...t],a=t.length+1>>1,r=t.length&1;for(;;){let o=0;for(;o<a-r;o+=1){const i=o<<1,c=Cs(s[i].hash,s[i+1].hash);t[o]=new un(s[i].index,s[i+1].index,-1,c,"");const d=n.length;t[o].index=d,n[s[i].index].parent=d,n[s[i+1].index].parent=d,n.push(t[o])}if(a===1)break;r===1&&(t[o]=s[o<<1]),r=a&1,a=a+1>>1,s=[...t]}return n}se(Dd,"constructTree");function Ss(e){if(!e.length)return Ed;const t=[];for(let r=0;r<e.length;r+=1){const o=Is(e[r]);t.push(new un(-1,-1,-1,o,e[r]))}let n=t,s=t.length+1>>1,a=t.length&1;for(;;){let r=0;for(;r<s-a;r+=1){const o=r<<1,i=Cs(n[o].hash,n[o+1].hash);t[r]=new un(n[o].index,n[o+1].index,-1,i,"")}if(a===1&&(t[r]=n[r<<1]),s===1)break;a=s&1,s=s+1>>1,n=t}return t[0].hash}se(Ss,"calcRoot");function Nd(e,t){const n=[];for(let s=t,a=e[t].parent;a!==-1;s=a,a=e[a].parent)e[a].left===s?n.push(e[e[a].right].hash):n.push(e[e[a].left].hash);return n}se(Nd,"getProof");var Fd="0x00",Ur="0x01";function Gr(e,t){const n="0x00".concat(e.slice(2)).concat(Te(t).slice(2));return[Te(n),n]}se(Gr,"hashLeaf");function Ke(e,t){const n="0x01".concat(e.slice(2)).concat(t.slice(2));return[Te(n),n]}se(Ke,"hashNode");function Yt(e){const t=Ur.length;return["0x".concat(e.slice(t,t+64)),"0x".concat(e.slice(t+64))]}se(Yt,"parseLeaf");function $r(e){const t=Ur.length;return["0x".concat(e.slice(t,t+64)),"0x".concat(e.slice(t+64))]}se($r,"parseNode");function Xt(e){return e.slice(0,4)===Fd}se(Xt,"isLeaf");var _d=class{static{se(this,"SparseCompactMerkleProof")}SideNodes;NonMembershipLeafData;BitMask;NumSideNodes;SiblingData;constructor(e,t,n,s,a){this.SideNodes=e,this.NonMembershipLeafData=t,this.BitMask=n,this.NumSideNodes=s,this.SiblingData=a}},Bd=_d,Md=class{static{se(this,"SparseMerkleProof")}SideNodes;NonMembershipLeafData;SiblingData;constructor(e,t,n){this.SideNodes=e,this.NonMembershipLeafData=t,this.SiblingData=n}},Ld=Md,le="0x0000000000000000000000000000000000000000000000000000000000000000",Le=256;function et(e,t){const n=e.slice(2),s="0x".concat(n.slice(Math.floor(t/8)*2,Math.floor(t/8)*2+2));return(Number(s)&1<<7-t%8)>0?1:0}se(et,"getBitAtFromMSB");function zr(e){let t=0,n=e.length-1;const s=e;for(;t<n;)[s[t],s[n]]=[s[n],s[t]],t+=1,n-=1;return s}se(zr,"reverseSideNodes");function Wr(e,t){let n=0;for(let s=0;s<Le&&et(e,s)===et(t,s);s+=1)n+=1;return n}se(Wr,"countCommonPrefix");function Vr(e){const t=[],n=[];let s;for(let r=0;r<e.SideNodes.length;r+=1)s=e.SideNodes[r],s===le?t.push(0):(n.push(s),t.push(1));return new Bd(n,e.NonMembershipLeafData,t,e.SideNodes.length,e.SiblingData)}se(Vr,"compactProof");var kd=class{static{se(this,"SparseMerkleTree")}ms;root;constructor(){const e={};this.ms=e,this.root=le,this.ms[this.root]=le}get(e){return this.ms[e]}set(e,t){this.ms[e]=t}setRoot(e){this.root=e}sideNodesForRoot(e,t){const n=[];if(t===le)return[n,le,"",""];let s=this.get(t);if(Xt(s))return[n,t,s,""];let a,r,o="",i="";for(let d=0;d<Le;d+=1){if([a,r]=$r(s),et(e,d)===1?(i=a,o=r):(i=r,o=a),n.push(i),o===le){s="";break}if(s=this.get(o),Xt(s))break}const c=this.get(i);return[zr(n),o,s,c]}deleteWithSideNodes(e,t,n,s){if(n===le)return this.root;const[a]=Yt(s);if(a!==e)return this.root;let r="",o="",i="",c="",d=!1;for(let h=0;h<t.length;h+=1)if(t[h]!==""){if(i=t[h],o==="")if(c=this.get(i),Xt(c)){r=i,o=i;continue}else o=le,d=!0;!d&&i===le||(d||(d=!0),et(e,t.length-1-h)===1?[r,o]=Ke(i,o):[r,o]=Ke(o,i),this.set(r,o),o=r)}return r===""&&(r=le),r}updateWithSideNodes(e,t,n,s,a){let r,o;this.set(Te(t),t),[r,o]=Gr(e,t),this.set(r,o),o=r;let i;if(s===le)i=Le;else{const[c]=Yt(a);i=Wr(e,c)}i!==Le&&(et(e,i)===1?[r,o]=Ke(s,o):[r,o]=Ke(o,s),this.set(r,o),o=r);for(let c=0;c<Le;c+=1){let d;const h=Le-n.length;if(c-h<0||n[c-h]==="")if(i!==Le&&i>Le-1-c)d=le;else continue;else d=n[c-h];et(e,Le-1-c)===1?[r,o]=Ke(d,o):[r,o]=Ke(o,d),this.set(r,o),o=r}return r}update(e,t){const[n,s,a]=this.sideNodesForRoot(e,this.root),r=this.updateWithSideNodes(e,t,n,s,a);this.setRoot(r)}delete(e){const[t,n,s]=this.sideNodesForRoot(e,this.root),a=this.deleteWithSideNodes(e,t,n,s);this.setRoot(a)}prove(e){const[t,n,s,a]=this.sideNodesForRoot(e,this.root),r=[];for(let c=0;c<t.length;c+=1)t[c]!==""&&r.push(t[c]);let o="";if(n!==le){const[c]=Yt(s);c!==e&&(o=s)}return new Ld(r,o,a)}proveCompacted(e){const t=this.prove(e);return Vr(t)}},Ud=Object.defineProperty,p=(e,t)=>Ud(e,"name",{value:t,configurable:!0}),N={eth:{mainnet:1,sepolia:11155111,foundry:31337},fuel:{devnet:0,testnet:0,mainnet:9889}},Gd="/",$d=/^\/|\/$/g,zd=p((e="")=>e.replace($d,""),"trimPath");function qr(e,...t){const n=e!=null,s=e?.[0]==="/"&&e.length>1,a=[e,...t].filter(Boolean).map(zd);return s&&n&&a.unshift(""),a.join(Gd)}p(qr,"urlJoin");function Hr(e,t="./"){return e.map(n=>({...n,icon:qr(t,n.icon)}))}p(Hr,"resolveIconPaths");var Wd="https://assets.fuel.network/providers/",Vd=[{name:"Ethereum",symbol:"ETH",icon:"eth.svg",networks:[{type:"ethereum",chainId:N.eth.sepolia,decimals:18},{type:"ethereum",chainId:N.eth.foundry,decimals:18},{type:"ethereum",chainId:N.eth.mainnet,decimals:18},{type:"fuel",chainId:N.fuel.devnet,decimals:9,assetId:"0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"},{type:"fuel",chainId:N.fuel.testnet,decimals:9,assetId:"0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"},{type:"fuel",chainId:N.fuel.mainnet,decimals:9,assetId:"0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07"}]},{name:"WETH",symbol:"WETH",icon:"weth.svg",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0xa38a5a8beeb08d95744bc7f58528073f4052b254def59eba20c99c202b5acaa3",decimals:9}]},{name:"weETH",symbol:"weETH",icon:"weETH.webp",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x239ed6e12b7ce4089ee245244e3bf906999a6429c2a9a445a1e1faf56914a4ab",decimals:9}]},{name:"rsETH",symbol:"rsETH",icon:"rsETH.webp",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0xA1290d69c65A6Fe4DF752f95823fae25cB99e5A7",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0xbae80f7fb8aa6b90d9b01ef726ec847cc4f59419c4d5f2ea88fec785d1b0e849",decimals:9}]},{name:"rETH",symbol:"rETH",icon:"reth.svg",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0xae78736cd615f374d3085123a210448e74fc6393",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0xf3f9a0ed0ce8eac5f89d6b83e41b3848212d5b5f56108c54a205bb228ca30c16",decimals:9}]},{name:"wbETH",symbol:"wbETH",icon:"wbeth.png",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0xa2E3356610840701BDf5611a53974510Ae27E2e1",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x7843c74bef935e837f2bcf67b5d64ecb46dd53ff86375530b0caf3699e8ffafe",decimals:9}]},{name:"rstETH",symbol:"rstETH",icon:"rstETH.webp",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0x7a4EffD87C2f3C55CA251080b1343b605f327E3a",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x962792286fbc9b1d5860b4551362a12249362c21594c77abf4b3fe2bbe8d977a",decimals:9}]},{name:"amphrETH",symbol:"amphrETH",icon:"amphrETH.png",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0x5fD13359Ba15A84B76f7F87568309040176167cd",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x05fc623e57bd7bc1258efa8e4f62b05af5471d73df6f2c2dc11ecc81134c4f36",decimals:9}]},{name:"Manta mBTC",symbol:"Manta mBTC",icon:"manta-mbtc.svg",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0x4041381e947CFD3D483d67a25C6aa9Dc924250c5",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0xaf3111a248ff7a3238cdeea845bb2d43cf3835f1f6b8c9d28360728b55b9ce5b",decimals:9}]},{name:"Manta mETH",symbol:"Manta mETH",icon:"manta-meth.svg",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0x8CdF550C04Bc9B9F10938368349C9c8051A772b6",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0xafd219f513317b1750783c6581f55530d6cf189a5863fd18bd1b3ffcec1714b4",decimals:9}]},{name:"Manta mUSD",symbol:"Manta mUSD",icon:"manta-musd.svg",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0x3f24E1d7a973867fC2A03fE199E5502514E0e11E",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x89cb9401e55d49c3269654dd1cdfb0e80e57823a4a7db98ba8fc5953b120fef4",decimals:9}]},{name:"pumpBTC",symbol:"pumpBTC",icon:"pumpbtc.webp",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0xf469fbd2abcd6b9de8e169d128226c0fc90a012e",decimals:8},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x0aa5eb2bb97ca915288b653a2529355d4dc66de2b37533213f0e4aeee3d3421f",decimals:8}]},{name:"FBTC",symbol:"FBTC",icon:"fbtc.svg",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0xc96de26018a54d51c097160568752c4e3bd6c364",decimals:8},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0xb5ecb0a1e08e2abbabf624ffea089df933376855f468ade35c6375b00c33996a",decimals:8}]},{name:"SolvBTC",symbol:"SolvBTC",icon:"solvBTC.webp",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0x7a56e1c57c7475ccf742a1832b028f0456652f97",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x1186afea9affb88809c210e13e2330b5258c2cef04bb8fff5eff372b7bd3f40f",decimals:9}]},{name:"SolvBTC.BBN",symbol:"SolvBTC.BBN",icon:"SolvBTC.BBN.png",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0xd9d920aa40f578ab794426f5c90f6c731d159def",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x7a4f087c957d30218223c2baaaa365355c9ca81b6ea49004cfb1590a5399216f",decimals:9}]},{name:"Mantle mETH",symbol:"Mantle mETH",icon:"mantle-meth.svg",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0xd5F7838F5C461fefF7FE49ea5ebaF7728bB0ADfa",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x642a5db59ec323c2f846d4d4cf3e58d78aff64accf4f8f6455ba0aa3ef000a3b",decimals:9}]},{name:"sDAI",symbol:"sDAI",icon:"sdai.svg",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0x83f20f44975d03b1b09e64809b757c47f942beea",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x9e46f919fbf978f3cad7cd34cca982d5613af63ff8aab6c379e4faa179552958",decimals:9}]},{name:"USDT",symbol:"USDT",icon:"usdt.svg",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0xdAC17F958D2ee523a2206206994597C13D831ec7",decimals:6},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0xa0265fb5c32f6e8db3197af3c7eb05c48ae373605b8165b6f4a51c5b0ba4812e",decimals:6}]},{name:"USDC",symbol:"USDC",icon:"usdc.svg",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",decimals:6},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x286c479da40dc953bddc3bb4c453b608bba2e0ac483b077bd475174115395e6b",decimals:6}]},{name:"USDe",symbol:"USDe",icon:"USDe.svg",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0x4c9edd5852cd905f086c759e8383e09bff1e68b3",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0xb6133b2ef9f6153eb869125d23dcf20d1e735331b5e41b15a6a7a6cec70e8651",decimals:9}]},{name:"sUSDe",symbol:"sUSDe",icon:"sUSDe.webp",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0x9d39a5de30e57443bff2a8307a4256c8797a3497",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0xd05563025104fc36496c15c7021ad6b31034b0e89a356f4f818045d1f48808bc",decimals:9}]},{name:"rsUSDe",symbol:"rsUSDe",icon:"rsUSDe.svg",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0x82f5104b23FF2FA54C2345F821dAc9369e9E0B26",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x78d4522ec607f6e8efb66ea49439d1ee48623cf763f9688a8eada025def033d9",decimals:9}]},{name:"wstETH",symbol:"wstETH",icon:"wsteth.svg",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x1a7815cc9f75db5c24a5b0814bfb706bb9fe485333e98254015de8f48f84c67b",decimals:9}]},{name:"ezETH",symbol:"ezETH",icon:"ezeth.webp",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0xbf5495Efe5DB9ce00f80364C8B423567e58d2110",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x91b3559edb2619cde8ffb2aa7b3c3be97efd794ea46700db7092abeee62281b0",decimals:9}]},{name:"pzETH",symbol:"pzETH",icon:"pzETH.webp",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0x8c9532a60e0e7c6bbd2b2c1303f63ace1c3e9811",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x1493d4ec82124de8f9b625682de69dcccda79e882b89a55a8c737b12de67bd68",decimals:9}]},{name:"Re7LRT",symbol:"Re7LRT",icon:"Re7LRT.png",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0x84631c0d0081FDe56DeB72F6DE77abBbF6A9f93a",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0xf2fc648c23a5db24610a1cf696acc4f0f6d9a7d6028dd9944964ab23f6e35995",decimals:9}]},{name:"steakLRT",symbol:"steakLRT",icon:"steakLRT.png",networks:[{type:"ethereum",chainId:N.eth.mainnet,address:"0xBEEF69Ac7870777598A04B2bd4771c71212E6aBc",decimals:18},{type:"fuel",chainId:N.fuel.mainnet,contractId:"0x4ea6ccef1215d9479f1024dff70fc055ca538215d2c8c348beddffd54583d0e8",assetId:"0x4fc8ac9f101df07e2c2dec4a53c8c42c439bdbe5e36ea2d863a61ff60afafc30",decimals:9}]}];Hr(Vd,Wd);var vs=p(e=>{let t,n,s;return Array.isArray(e)?(n=e[0],t=e[1],s=e[2]??void 0):(n=e.amount,t=e.assetId,s=e.max??void 0),{assetId:S(t),amount:u(n),max:s?u(s):void 0}},"coinQuantityfy"),qd=p(e=>{const{amount:t,assetId:n}=e,s=[...e.coinQuantities],a=s.findIndex(r=>r.assetId===n);return a!==-1?s[a].amount=s[a].amount.add(t):s.push({assetId:n,amount:t}),s},"addAmountToCoinQuantities"),Hd=x`
    fragment InputCoinFragment on InputCoin {
  type: __typename
  utxoId
  owner
  amount
  assetId
  txPointer
  coinWitnessIndex: witnessIndex
  predicateGasUsed
  predicate
  predicateData
}
    `,jd=x`
    fragment InputMessageFragment on InputMessage {
  type: __typename
  sender
  recipient
  amount
  nonce
  messageWitnessIndex: witnessIndex
  predicateGasUsed
  data
  predicate
  predicateData
}
    `,Kd=x`
    fragment InputContractFragment on InputContract {
  type: __typename
  utxoId
  balanceRoot
  stateRoot
  txPointer
  contractId
}
    `,Jd=x`
    fragment OutputCoinFragment on CoinOutput {
  type: __typename
  to
  amount
  assetId
}
    `,Yd=x`
    fragment OutputContractFragment on ContractOutput {
  type: __typename
  inputIndex
  balanceRoot
  stateRoot
}
    `,Xd=x`
    fragment OutputChangeFragment on ChangeOutput {
  type: __typename
  to
  amount
  assetId
}
    `,Zd=x`
    fragment OutputVariableFragment on VariableOutput {
  type: __typename
  to
  amount
  assetId
}
    `,Qd=x`
    fragment OutputContractCreatedFragment on ContractCreated {
  type: __typename
  contract
  stateRoot
}
    `,Ts=x`
    fragment SubmittedStatusFragment on SubmittedStatus {
  type: __typename
  time
}
    `,st=x`
    fragment receiptFragment on Receipt {
  id
  pc
  is
  to
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `,jr=x`
    fragment SuccessStatusFragment on SuccessStatus {
  type: __typename
  time
  programState {
    returnType
    data
  }
  receipts {
    ...receiptFragment
  }
  totalGas
  totalFee
}
    ${st}`,Kr=x`
    fragment SuccessStatusWithBlockIdFragment on SuccessStatus {
  ...SuccessStatusFragment
  block {
    id
  }
}
    ${jr}`,eu=x`
    fragment malleableTransactionFieldsFragment on Transaction {
  receiptsRoot
  inputs {
    type: __typename
    ... on InputCoin {
      txPointer
    }
    ... on InputContract {
      txPointer
    }
  }
  outputs {
    type: __typename
    ... on CoinOutput {
      to
      amount
      assetId
    }
    ... on ContractOutput {
      inputIndex
      balanceRoot
      stateRoot
    }
    ... on ChangeOutput {
      to
      amount
      assetId
    }
    ... on VariableOutput {
      to
      amount
      assetId
    }
    ... on ContractCreated {
      contract
      stateRoot
    }
  }
}
    `,Jr=x`
    fragment FailureStatusFragment on FailureStatus {
  type: __typename
  totalGas
  totalFee
  time
  reason
  receipts {
    ...receiptFragment
  }
}
    ${st}`,Yr=x`
    fragment FailureStatusWithBlockIdFragment on FailureStatus {
  ...FailureStatusFragment
  block {
    id
  }
}
    ${Jr}`,Rs=x`
    fragment SqueezedOutStatusFragment on SqueezedOutStatus {
  type: __typename
  reason
}
    `,Xr=x`
    fragment PreconfirmationSuccessStatusFragment on PreconfirmationSuccessStatus {
  type: __typename
  totalGas
  totalFee
  resolvedOutputs {
    utxoId
    output {
      type: __typename
      ... on CoinOutput {
        to
        amount
        assetId
      }
      ... on ContractOutput {
        inputIndex
        balanceRoot
        stateRoot
      }
      ... on ChangeOutput {
        to
        amount
        assetId
      }
      ... on VariableOutput {
        to
        amount
        assetId
      }
      ... on ContractCreated {
        contract
        stateRoot
      }
    }
  }
  preconfirmationReceipts: receipts {
    ...receiptFragment
  }
}
    ${st}`,Zr=x`
    fragment PreconfirmationFailureStatusFragment on PreconfirmationFailureStatus {
  type: __typename
  reason
  totalGas
  totalFee
  resolvedOutputs {
    utxoId
    output {
      type: __typename
      ... on CoinOutput {
        to
        amount
        assetId
      }
      ... on ContractOutput {
        inputIndex
        balanceRoot
        stateRoot
      }
      ... on ChangeOutput {
        to
        amount
        assetId
      }
      ... on VariableOutput {
        to
        amount
        assetId
      }
      ... on ContractCreated {
        contract
        stateRoot
      }
    }
  }
  preconfirmationReceipts: receipts {
    ...receiptFragment
  }
}
    ${st}`,Qr=x`
    fragment transactionStatusSubscriptionFragment on TransactionStatus {
  ... on SubmittedStatus {
    ...SubmittedStatusFragment
  }
  ... on SuccessStatus {
    ...SuccessStatusWithBlockIdFragment
    transaction {
      ...malleableTransactionFieldsFragment
    }
  }
  ... on FailureStatus {
    ...FailureStatusWithBlockIdFragment
    transaction {
      ...malleableTransactionFieldsFragment
    }
  }
  ... on SqueezedOutStatus {
    ...SqueezedOutStatusFragment
  }
  ... on PreconfirmationSuccessStatus {
    ...PreconfirmationSuccessStatusFragment
  }
  ... on PreconfirmationFailureStatus {
    ...PreconfirmationFailureStatusFragment
  }
}
    ${Ts}
${Kr}
${eu}
${Yr}
${Rs}
${Xr}
${Zr}`,tu=x`
    fragment transactionStatusFragment on TransactionStatus {
  ... on SubmittedStatus {
    ...SubmittedStatusFragment
  }
  ... on SuccessStatus {
    ...SuccessStatusFragment
  }
  ... on FailureStatus {
    ...FailureStatusFragment
  }
  ... on SqueezedOutStatus {
    ...SqueezedOutStatusFragment
  }
}
    ${Ts}
${jr}
${Jr}
${Rs}`,eo=x`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  status {
    ...transactionStatusFragment
  }
}
    ${tu}`,nu=x`
    fragment transactionRawPayloadFragment on Transaction {
  id
  rawPayload
}
    `,su=x`
    fragment inputEstimatePredicatesFragment on Input {
  ... on InputCoin {
    predicateGasUsed
  }
  ... on InputMessage {
    predicateGasUsed
  }
}
    `,to=x`
    fragment transactionEstimatePredicatesFragment on Transaction {
  inputs {
    ...inputEstimatePredicatesFragment
  }
}
    ${su}`,au=x`
    fragment dryRunFailureAssembleTxFragment on DryRunFailureStatus {
  type: __typename
  reason
  receipts {
    ...receiptFragment
  }
}
    ${st}`,ru=x`
    fragment dryRunSuccessAssembleTxFragment on DryRunSuccessStatus {
  type: __typename
  receipts {
    ...receiptFragment
  }
}
    ${st}`,ou=x`
    fragment dryRunFailureStatusFragment on DryRunFailureStatus {
  type: __typename
  totalGas
  totalFee
  reason
  programState {
    returnType
    data
  }
}
    `,iu=x`
    fragment dryRunSuccessStatusFragment on DryRunSuccessStatus {
  type: __typename
  totalGas
  totalFee
  programState {
    returnType
    data
  }
}
    `,cu=x`
    fragment dryRunTransactionStatusFragment on DryRunTransactionStatus {
  ... on DryRunFailureStatus {
    ...dryRunFailureStatusFragment
  }
  ... on DryRunSuccessStatus {
    ...dryRunSuccessStatusFragment
  }
}
    ${ou}
${iu}`,du=x`
    fragment dryRunTransactionExecutionStatusFragment on DryRunTransactionExecutionStatus {
  id
  status {
    ...dryRunTransactionStatusFragment
  }
  receipts {
    ...receiptFragment
  }
}
    ${cu}
${st}`,Sn=x`
    fragment blockFragment on Block {
  id
  height
  header {
    time
    daHeight
    stateTransitionBytecodeVersion
    transactionsCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    prevRoot
    applicationHash
  }
  transactions {
    id
  }
}
    `,xs=x`
    fragment coinFragment on Coin {
  type: __typename
  utxoId
  amount
  assetId
  blockCreated
  txCreatedIdx
}
    `,uu=x`
    fragment messageCoinFragment on MessageCoin {
  type: __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `,no=x`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  daHeight
}
    `,lu=x`
    fragment getMessageFragment on Message {
  ...messageFragment
  nonce
}
    ${no}`,hu=x`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  commitBlockHeader {
    version
    id
    daHeight
    consensusParametersVersion
    stateTransitionBytecodeVersion
    transactionsCount
    messageReceiptCount
    transactionsRoot
    messageOutboxRoot
    eventInboxRoot
    height
    prevRoot
    time
    applicationHash
  }
  sender
  recipient
  amount
  data
}
    `,pu=x`
    fragment TxParametersFragment on TxParameters {
  version
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxSize
  maxBytecodeSubsections
}
    `,fu=x`
    fragment PredicateParametersFragment on PredicateParameters {
  version
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  maxMessageDataLength
}
    `,mu=x`
    fragment ScriptParametersFragment on ScriptParameters {
  version
  maxScriptLength
  maxScriptDataLength
}
    `,gu=x`
    fragment ContractParametersFragment on ContractParameters {
  version
  contractMaxSize
  maxStorageSlots
}
    `,yu=x`
    fragment FeeParametersFragment on FeeParameters {
  version
  gasPriceFactor
  gasPerByte
}
    `,wu=x`
    fragment DependentCostFragment on DependentCost {
  ... on LightOperation {
    type: __typename
    base
    unitsPerGas
  }
  ... on HeavyOperation {
    type: __typename
    base
    gasPerUnit
  }
}
    `,bu=x`
    fragment GasCostsFragment on GasCosts {
  contractRoot {
    ...DependentCostFragment
  }
  stateRoot {
    ...DependentCostFragment
  }
  vmInitialization {
    ...DependentCostFragment
  }
  s256 {
    ...DependentCostFragment
  }
  ecr1
  newStoragePerByte
}
    ${wu}`,Iu=x`
    fragment consensusParametersFragment on ConsensusParameters {
  version
  txParams {
    ...TxParametersFragment
  }
  predicateParams {
    ...PredicateParametersFragment
  }
  scriptParams {
    ...ScriptParametersFragment
  }
  contractParams {
    ...ContractParametersFragment
  }
  feeParams {
    ...FeeParametersFragment
  }
  gasCosts {
    ...GasCostsFragment
  }
  baseAssetId
  chainId
}
    ${pu}
${fu}
${mu}
${gu}
${yu}
${bu}`,so=x`
    fragment chainInfoFragment on ChainInfo {
  name
  daHeight
  consensusParameters {
    ...consensusParametersFragment
  }
  latestBlock {
    header {
      consensusParametersVersion
    }
  }
}
    ${Iu}`,Cu=x`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `,Ct=x`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `,ao=x`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  maxTx
  maxDepth
  nodeVersion
  indexation {
    balances
    coinsToSpend
    assetMetadata
  }
}
    `,Su=x`
    fragment relayedTransactionStatusFragment on RelayedTransactionStatus {
  ... on RelayedTransactionFailed {
    blockHeight
    failure
  }
}
    `,vu=x`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `,Tu=x`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${ao}`,Ru=x`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${so}`,xu=x`
    query getChainAndNodeInfo {
  chain {
    ...chainInfoFragment
  }
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${so}
${ao}`,Au=x`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${eo}`,Pu=x`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    id
    rawPayload
    status {
      ... on SubmittedStatus {
        ...SubmittedStatusFragment
      }
      ... on SuccessStatus {
        ...SuccessStatusWithBlockIdFragment
      }
      ... on FailureStatus {
        ...FailureStatusWithBlockIdFragment
      }
      ... on SqueezedOutStatus {
        ...SqueezedOutStatusFragment
      }
      ... on PreconfirmationSuccessStatus {
        ...PreconfirmationSuccessStatusFragment
      }
      ... on PreconfirmationFailureStatus {
        ...PreconfirmationFailureStatusFragment
      }
    }
  }
}
    ${Ts}
${Kr}
${Yr}
${Rs}
${Xr}
${Zr}`,Eu=x`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        rawPayload
      }
    }
    pageInfo {
      ...pageInfoFragment
    }
  }
}
    ${Ct}`,Ou=x`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${Ct}
${eo}`,Du=x`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
}
    ${to}`,Nu=x`
    query estimatePredicatesAndGasPrice($encodedTransaction: HexString!, $blockHorizon: U32!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionEstimatePredicatesFragment
  }
  estimateGasPrice(blockHorizon: $blockHorizon) {
    gasPrice
  }
}
    ${to}`,Fu=x`
    query getLatestBlock {
  chain {
    latestBlock {
      ...blockFragment
    }
  }
}
    ${Sn}`,_u=x`
    query getLatestBlockHeight {
  chain {
    latestBlock {
      height
    }
  }
}
    `,Bu=x`
    query getBlock($blockId: BlockId, $height: U32) {
  block(id: $blockId, height: $height) {
    ...blockFragment
  }
}
    ${Sn}`,Mu=x`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionRawPayloadFragment
    }
  }
}
    ${Sn}
${nu}`,Lu=x`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${Ct}
${Sn}`,ku=x`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
    owner
  }
}
    ${xs}`,Uu=x`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${Ct}
${xs}`,Gu=x`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${xs}
${uu}`,$u=x`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `,zu=x`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${Cu}`,Wu=x`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    amount
  }
}
    `,Vu=x`
    query getBalanceV2($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    amountU128
  }
}
    `,qu=x`
    query getLatestGasPrice {
  latestGasPrice {
    gasPrice
  }
}
    `,Hu=x`
    query estimateGasPrice($blockHorizon: U32!) {
  estimateGasPrice(blockHorizon: $blockHorizon) {
    gasPrice
  }
}
    `,ju=x`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        assetId
        amount
      }
    }
  }
}
    `,Ku=x`
    query getBalancesV2($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int, $supportsPagination: Boolean!) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo @include(if: $supportsPagination) {
      ...pageInfoFragment
    }
    edges {
      node {
        assetId
        amountU128
      }
    }
  }
}
    ${Ct}`,Ju=x`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...getMessageFragment
      }
    }
  }
}
    ${Ct}
${lu}`,Yu=x`
    query daCompressedBlock($height: U32!) {
  daCompressedBlock(height: $height) {
    bytes
  }
}
    `,Xu=x`
    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    nonce: $nonce
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${hu}`,Zu=x`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `,Qu=x`
    query getRelayedTransactionStatus($relayedTransactionId: RelayedTransactionId!) {
  relayedTransactionStatus(id: $relayedTransactionId) {
    ...relayedTransactionStatusFragment
  }
}
    ${Su}`,el=x`
    query getAssetDetails($assetId: AssetId!) {
  assetDetails(id: $assetId) {
    subId
    contractId
    totalSupply
  }
}
    `,tl=x`
    query assembleTx($tx: HexString!, $blockHorizon: U32!, $requiredBalances: [RequiredBalance!]!, $feeAddressIndex: U16!, $excludeInput: ExcludeInput, $estimatePredicates: Boolean, $reserveGas: U64) {
  assembleTx(
    tx: $tx
    blockHorizon: $blockHorizon
    requiredBalances: $requiredBalances
    feeAddressIndex: $feeAddressIndex
    excludeInput: $excludeInput
    estimatePredicates: $estimatePredicates
    reserveGas: $reserveGas
  ) {
    transaction {
      id
      inputs {
        ... on InputCoin {
          ...InputCoinFragment
        }
        ... on InputContract {
          ...InputContractFragment
        }
        ... on InputMessage {
          ...InputMessageFragment
        }
      }
      outputs {
        ... on CoinOutput {
          ...OutputCoinFragment
        }
        ... on ContractOutput {
          ...OutputContractFragment
        }
        ... on ChangeOutput {
          ...OutputChangeFragment
        }
        ... on VariableOutput {
          ...OutputVariableFragment
        }
        ... on ContractCreated {
          ...OutputContractCreatedFragment
        }
      }
      policies {
        tip
        witnessLimit
        maturity
        maxFee
      }
      witnesses
      scriptGasLimit
    }
    status {
      ... on DryRunFailureStatus {
        ...dryRunFailureAssembleTxFragment
      }
      ... on DryRunSuccessStatus {
        ...dryRunSuccessAssembleTxFragment
      }
    }
    gasPrice
  }
}
    ${Hd}
${Kd}
${jd}
${Jd}
${Yd}
${Xd}
${Zd}
${Qd}
${au}
${ru}`,nl=x`
    query dryRun($encodedTransactions: [HexString!]!, $utxoValidation: Boolean, $gasPrice: U64) {
  dryRun(
    txs: $encodedTransactions
    utxoValidation: $utxoValidation
    gasPrice: $gasPrice
  ) {
    ...dryRunTransactionExecutionStatusFragment
  }
}
    ${du}`,sl=x`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `,al=x`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `,rl=x`
    query getMessageByNonce($nonce: Nonce!) {
  message(nonce: $nonce) {
    ...messageFragment
  }
}
    ${no}`,ol=x`
    query isUserAccount($blobId: BlobId!, $contractId: ContractId!, $transactionId: TransactionId!) {
  blob(id: $blobId) {
    id
  }
  contract(id: $contractId) {
    id
  }
  transaction(id: $transactionId) {
    id
  }
}
    `,il=x`
    query getConsensusParametersVersion {
  chain {
    latestBlock {
      header {
        consensusParametersVersion
      }
    }
  }
}
    `,cl=x`
    subscription submitAndAwaitStatus($encodedTransaction: HexString!, $estimatePredicates: Boolean, $includePreConfirmation: Boolean) {
  submitAndAwaitStatus(
    tx: $encodedTransaction
    estimatePredicates: $estimatePredicates
    includePreconfirmation: $includePreConfirmation
  ) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${Qr}`,dl=x`
    subscription statusChange($transactionId: TransactionId!, $includePreConfirmation: Boolean) {
  statusChange(
    id: $transactionId
    includePreconfirmation: $includePreConfirmation
  ) {
    ...transactionStatusSubscriptionFragment
  }
}
    ${Qr}`;function ro(e){return{getVersion(t,n){return e(vu,t,n)},getNodeInfo(t,n){return e(Tu,t,n)},getChain(t,n){return e(Ru,t,n)},getChainAndNodeInfo(t,n){return e(xu,t,n)},getTransaction(t,n){return e(Au,t,n)},getTransactionWithReceipts(t,n){return e(Pu,t,n)},getTransactions(t,n){return e(Eu,t,n)},getTransactionsByOwner(t,n){return e(Ou,t,n)},estimatePredicates(t,n){return e(Du,t,n)},estimatePredicatesAndGasPrice(t,n){return e(Nu,t,n)},getLatestBlock(t,n){return e(Fu,t,n)},getLatestBlockHeight(t,n){return e(_u,t,n)},getBlock(t,n){return e(Bu,t,n)},getBlockWithTransactions(t,n){return e(Mu,t,n)},getBlocks(t,n){return e(Lu,t,n)},getCoin(t,n){return e(ku,t,n)},getCoins(t,n){return e(Uu,t,n)},getCoinsToSpend(t,n){return e(Gu,t,n)},getContract(t,n){return e($u,t,n)},getContractBalance(t,n){return e(zu,t,n)},getBalance(t,n){return e(Wu,t,n)},getBalanceV2(t,n){return e(Vu,t,n)},getLatestGasPrice(t,n){return e(qu,t,n)},estimateGasPrice(t,n){return e(Hu,t,n)},getBalances(t,n){return e(ju,t,n)},getBalancesV2(t,n){return e(Ku,t,n)},getMessages(t,n){return e(Ju,t,n)},daCompressedBlock(t,n){return e(Yu,t,n)},getMessageProof(t,n){return e(Xu,t,n)},getMessageStatus(t,n){return e(Zu,t,n)},getRelayedTransactionStatus(t,n){return e(Qu,t,n)},getAssetDetails(t,n){return e(el,t,n)},assembleTx(t,n){return e(tl,t,n)},dryRun(t,n){return e(nl,t,n)},submit(t,n){return e(sl,t,n)},produceBlocks(t,n){return e(al,t,n)},getMessageByNonce(t,n){return e(rl,t,n)},isUserAccount(t,n){return e(ol,t,n)},getConsensusParametersVersion(t,n){return e(il,t,n)},submitAndAwaitStatus(t,n){return e(cl,t,n)},statusChange(t,n){return e(dl,t,n)}}}p(ro,"getSdk");var fa=p(e=>{const t={};return"bytes"in e?t.predicate={predicate:S(e.bytes),predicateAddress:e.address.toB256(),predicateData:S(e.getPredicateData())}:t.address=e.address.toB256(),t},"resolveAccountForAssembleTxParams"),ft=p(async e=>{const{gasPrice:t,transactionRequest:n,setGasLimit:s,setMaxFee:a,provider:r}=e,o=he(s),i=he(a),c=n.type===j.Script;if(o&&c){const d=n.gasLimit;if(u(s).lt(u(d)))throw new l(w.GAS_LIMIT_TOO_LOW,`Gas limit '${s}' is lower than the required: '${d}'.`);n.gasLimit=u(s)}if(i){const d=n.maxFee;if(u(a).lt(d))throw new l(w.MAX_FEE_TOO_LOW,`Max fee '${a}' is lower than the required: '${d}'.`);n.maxFee=u(a)}if(o&&!i){const{maxFee:d}=await r.estimateTxGasAndFee({transactionRequest:n,gasPrice:t});n.maxFee=d}return n},"setAndValidateGasAndFeeForAssembledTx"),ma=/[0-9a-fA-F]{32,64}/g,Fe={RPC_CONSISTENCY:/The required fuel block height is higher than the current block height. Required: \d+, Current: \d+/,INSUFFICIENT_FUNDS:/the target cannot be met due to insufficient coins available for [0-9a-fA-F]{32,64}. Collected: \d+/,MAX_COINS_REACHED:/the target for [0-9a-fA-F]{32,64} cannot be met due to exceeding the \d+ coin limit. Collected: \d+./,NOT_ENOUGH_COINS_MAX_COINS:/the target cannot be met due to no coins available or exceeding the \d+ coin limit./,ASSET_NOT_FOUND:/resource was not found in table/,MULTIPLE_CHANGE_POLICIES:/The asset ([a-fA-F0-9]{64}) has multiple change policies/,DUPLICATE_CHANGE_OUTPUT_ACCOUNT:/required balances contain duplicate \(asset, account\) pair/,INSUFFICIENT_FEE_AMOUNT:/InsufficientFeeAmount { expected: (\d+), provided: (\d+) }/},ul=p(e=>{if(Fe.NOT_ENOUGH_COINS_MAX_COINS.test(e.message))return new l(w.INSUFFICIENT_FUNDS_OR_MAX_COINS,"Insufficient funds or too many small value coins. Consider combining UTXOs.",{},e);if(Fe.MAX_COINS_REACHED.test(e.message)){const t=e.message.match(ma),n=t?`0x${t[0]}`:null,s=t?`0x${t[1]}`:null;let a="";return n&&(a+=`
	Asset ID: '${n}'.`),s&&(a+=`
	Owner: '${s}'.`),new l(w.MAX_COINS_REACHED,`You have too many small value coins - consider combining UTXOs.${a}`,{assetId:n,owner:s},e)}if(Fe.INSUFFICIENT_FUNDS.test(e.message)){const t=e.message.match(ma),n=t?`0x${t[0]}`:null,s=t?`0x${t[1]}`:null;let a="";return n&&(a+=`
	Asset ID: '${n}'.`),s&&(a+=`
	Owner: '${s}'.`),new l(w.INSUFFICIENT_FUNDS,`Insufficient funds.${a}`,{assetId:n,owner:s},e)}if(Fe.MULTIPLE_CHANGE_POLICIES.test(e.message)){const n=e.message.match(/asset ([a-fA-F0-9]{64})/)?.[1]||"";return new l(w.CHANGE_OUTPUT_COLLISION,`OutputChange address for asset 0x${n} differs between transaction request and assembleTx parameters.`,{},e)}if(Fe.DUPLICATE_CHANGE_OUTPUT_ACCOUNT.test(e.message))return new l(w.DUPLICATE_CHANGE_OUTPUT_ACCOUNT,"The parameter 'accountCoinQuantities' of assembleTx contains duplicate entries for the same assetId with different 'changeOutputAccount'.",{},e);if(Fe.ASSET_NOT_FOUND.test(e.message))return new l(w.ASSET_NOT_FOUND,"Asset not found for given asset id.",{},e);if(Fe.RPC_CONSISTENCY.test(e.message))return new l(w.RPC_CONSISTENCY,e.message,{},e);if(Fe.INSUFFICIENT_FEE_AMOUNT.test(e.message)){const t=e.message.match(Fe.INSUFFICIENT_FEE_AMOUNT);return new l(w.FUNDS_TOO_LOW,t?.[0]||e.message,{},e)}return new l(w.INVALID_REQUEST,e.message,{},e)},"mapGqlErrorMessage"),ga=p((e,t)=>t?new l(e.code,`${e.message}

${t}`,e.metadata,e.rawError):e,"mapGqlErrorWithIncompatibleNodeVersion"),oo=p((e,t=!1)=>{if(!Array.isArray(e))return;const n=e.map(ul);if(n.length===1)throw ga(n[0],t);const s=n.map(a=>a.message).join(`
`);throw ga(new l(w.INVALID_REQUEST,s,{},n),t)},"assertGqlResponseHasNoErrors"),Qn=class ut{constructor(t,n){this.stream=t,this.onEvent=n}static{p(this,"FuelGraphqlSubscriber")}static incompatibleNodeVersionMessage=!1;static textDecoder=new TextDecoder;static async create(t){const{url:n,query:s,variables:a,fetchFn:r,operationName:o,onEvent:i}=t,c=await r(`${n}-sub`,{method:"POST",body:JSON.stringify({query:Xi(s),variables:a,operationName:o}),headers:{"Content-Type":"application/json",Accept:"text/event-stream"}}),[d,h]=c.body.tee().map(f=>f.getReader());return await new ut(d).next(),new ut(h,i)}static async readEvent(t,n=""){let s=n;const a=/data:.*\n\n/g;for(;;){const r=[...s.matchAll(a)].flatMap(d=>d);if(r.length>0)try{return{event:JSON.parse(r[0].replace(/^data:/,"")),done:!1,parsingLeftover:s.replace(r[0],"")}}catch{throw new l(w.STREAM_PARSING_ERROR,`Error while parsing stream data response: ${s}`)}const{value:o,done:i}=await t.read();if(i)return{event:void 0,done:i,parsingLeftover:""};const c=ut.textDecoder.decode(o).replace(`:keep-alive-text

`,"");s+=c}}events=[];parsingLeftover="";async next(){for(;;){const t=this.events.shift();if(t)return this.onEvent?.(t),oo(t.errors,ut.incompatibleNodeVersionMessage),{value:t.data,done:!1};const{event:n,done:s,parsingLeftover:a}=await ut.readEvent(this.stream,this.parsingLeftover);if(this.parsingLeftover=a,s)return{value:void 0,done:!0};this.events.push(n)}}return(){return Promise.resolve({done:!0,value:void 0})}[Symbol.asyncIterator](){return this}},ll=p(e=>{const{type:t}=e;switch(e.type){case H.Coin:{const n=v(e.predicate??"0x"),s=v(e.predicateData??"0x");return{type:H.Coin,txID:S(v(e.id).slice(0,We)),outputIndex:ze(v(e.id).slice(We,rn)),owner:S(e.owner),amount:u(e.amount),assetId:S(e.assetId),txPointer:{blockHeight:ze(v(e.txPointer).slice(0,8)),txIndex:ze(v(e.txPointer).slice(8,16))},witnessIndex:e.witnessIndex,predicateGasUsed:u(e.predicateGasUsed),predicateLength:u(n.length),predicateDataLength:u(s.length),predicate:S(n),predicateData:S(s)}}case H.Contract:return{type:H.Contract,txID:S(e.txID||K),outputIndex:0,balanceRoot:K,stateRoot:K,txPointer:{blockHeight:ze(v(e.txPointer).slice(0,8)),txIndex:ze(v(e.txPointer).slice(8,16))},contractID:S(e.contractId)};case H.Message:{const n=v(e.predicate??"0x"),s=v(e.predicateData??"0x"),a=v(e.data??"0x");return{type:H.Message,sender:S(e.sender),recipient:S(e.recipient),amount:u(e.amount),nonce:S(e.nonce),witnessIndex:e.witnessIndex,predicateGasUsed:u(e.predicateGasUsed),predicateLength:u(n.length),predicateDataLength:u(s.length),predicate:S(n),predicateData:S(s),data:S(a),dataLength:a.length}}default:throw new l(w.INVALID_TRANSACTION_INPUT,`Invalid transaction input type: ${t}.`)}},"inputify"),hl=p(e=>{const{type:t}=e;switch(t){case k.Coin:return{type:k.Coin,to:S(e.to),amount:u(e.amount),assetId:S(e.assetId)};case k.Contract:return{type:k.Contract,inputIndex:e.inputIndex,balanceRoot:K,stateRoot:K};case k.Change:return{type:k.Change,to:S(e.to),amount:u(0),assetId:S(e.assetId)};case k.Variable:return{type:k.Variable,to:S(e.to||K),amount:u(e.amount),assetId:S(e.assetId||K)};case k.ContractCreated:return{type:k.ContractCreated,contractId:S(e.contractId),stateRoot:S(e.stateRoot)};default:throw new l(w.INVALID_TRANSACTION_INPUT,`Invalid transaction output type: ${t}.`)}},"outputify"),ya=p(e=>!("data"in e),"isMessageCoin"),pl=p(e=>"id"in e,"isCoin"),es=p(e=>{const{name:t,daHeight:n,consensusParameters:s,latestBlock:a}=e,{contractParams:r,feeParams:o,predicateParams:i,scriptParams:c,txParams:d,gasCosts:h,baseAssetId:f,chainId:b,version:g}=s;return{name:t,baseChainHeight:u(n),consensusParameters:{version:g,chainId:u(b),baseAssetId:f,feeParameters:{version:o.version,gasPerByte:u(o.gasPerByte),gasPriceFactor:u(o.gasPriceFactor)},contractParameters:{version:r.version,contractMaxSize:u(r.contractMaxSize),maxStorageSlots:u(r.maxStorageSlots)},txParameters:{version:d.version,maxInputs:u(d.maxInputs),maxOutputs:u(d.maxOutputs),maxWitnesses:u(d.maxWitnesses),maxGasPerTx:u(d.maxGasPerTx),maxSize:u(d.maxSize),maxBytecodeSubsections:u(d.maxBytecodeSubsections)},predicateParameters:{version:i.version,maxPredicateLength:u(i.maxPredicateLength),maxPredicateDataLength:u(i.maxPredicateDataLength),maxGasPerPredicate:u(i.maxGasPerPredicate),maxMessageDataLength:u(i.maxMessageDataLength)},scriptParameters:{version:c.version,maxScriptLength:u(c.maxScriptLength),maxScriptDataLength:u(c.maxScriptDataLength)},gasCosts:h},latestBlock:a}},"deserializeChain"),fl=p(e=>{const{name:t,baseChainHeight:n,consensusParameters:s,latestBlock:a}=e,{contractParameters:r,feeParameters:o,predicateParameters:i,scriptParameters:c,txParameters:d,gasCosts:h,baseAssetId:f,chainId:b,version:g}=s;return{name:t,daHeight:n.toString(),consensusParameters:{version:g,chainId:b.toString(),baseAssetId:f,feeParams:{version:o.version,gasPerByte:o.gasPerByte.toString(),gasPriceFactor:o.gasPriceFactor.toString()},contractParams:{version:r.version,contractMaxSize:r.contractMaxSize.toString(),maxStorageSlots:r.maxStorageSlots.toString()},txParams:{version:d.version,maxInputs:d.maxInputs.toString(),maxOutputs:d.maxOutputs.toString(),maxWitnesses:d.maxWitnesses.toString(),maxGasPerTx:d.maxGasPerTx.toString(),maxSize:d.maxSize.toString(),maxBytecodeSubsections:d.maxBytecodeSubsections.toString()},predicateParams:{version:i.version,maxPredicateLength:i.maxPredicateLength.toString(),maxPredicateDataLength:i.maxPredicateDataLength.toString(),maxGasPerPredicate:i.maxGasPerPredicate.toString(),maxMessageDataLength:i.maxMessageDataLength.toString()},scriptParams:{version:c.version,maxScriptLength:c.maxScriptLength.toString(),maxScriptDataLength:c.maxScriptDataLength.toString()},gasCosts:h},latestBlock:a}},"serializeChain"),ts=p(e=>{const{maxDepth:t,maxTx:n,nodeVersion:s,utxoValidation:a,vmBacktrace:r,indexation:o}=e;return{maxDepth:u(t),maxTx:u(n),nodeVersion:s,utxoValidation:a,vmBacktrace:r,indexation:o}},"deserializeNodeInfo"),ml=p(e=>{const{maxDepth:t,maxTx:n,nodeVersion:s,utxoValidation:a,vmBacktrace:r,indexation:o}=e;return{maxDepth:t.toString(),maxTx:n.toString(),nodeVersion:s,utxoValidation:a,vmBacktrace:r,indexation:o}},"serializeNodeInfo"),gl=p(e=>({consensusParametersTimestamp:e.consensusParametersTimestamp,chain:es(e.chain),nodeInfo:ts(e.nodeInfo)}),"deserializeProviderCache"),yl=p(async e=>({consensusParametersTimestamp:e.consensusParametersTimestamp,chain:fl(await e.getChain()),nodeInfo:ml(await e.getNode())}),"serializeProviderCache"),J=p(e=>e||K,"hexOrZero"),ce=p(e=>{const{receiptType:t}=e;switch(t){case"CALL":{const n=J(e.id||e.contractId);return{type:L.Call,id:n,to:J(e?.to),amount:u(e.amount),assetId:J(e.assetId),gas:u(e.gas),param1:u(e.param1),param2:u(e.param2),pc:u(e.pc),is:u(e.is)}}case"RETURN":return{type:L.Return,id:J(e.id||e.contractId),val:u(e.val),pc:u(e.pc),is:u(e.is)};case"RETURN_DATA":return{type:L.ReturnData,id:J(e.id||e.contractId),ptr:u(e.ptr),len:u(e.len),digest:J(e.digest),pc:u(e.pc),data:J(e.data),is:u(e.is)};case"PANIC":return{type:L.Panic,id:J(e.id),reason:u(e.reason),pc:u(e.pc),is:u(e.is),contractId:J(e.contractId)};case"REVERT":return{type:L.Revert,id:J(e.id||e.contractId),val:u(e.ra),pc:u(e.pc),is:u(e.is)};case"LOG":{const n=u(e.ra),s=u(e.rb),a=u(e.rc),r=u(e.rd);return{type:L.Log,id:J(e.id||e.contractId),ra:n,rb:s,rc:a,rd:r,pc:u(e.pc),is:u(e.is)}}case"LOG_DATA":{const n=u(e.ra),s=u(e.rb);return{type:L.LogData,id:J(e.id||e.contractId),ra:n,rb:s,ptr:u(e.ptr),len:u(e.len),digest:J(e.digest),pc:u(e.pc),data:J(e.data),is:u(e.is)}}case"TRANSFER":{const n=J(e.id||e.contractId);return{type:L.Transfer,id:n,to:J(e.toAddress||e?.to),amount:u(e.amount),assetId:J(e.assetId),pc:u(e.pc),is:u(e.is)}}case"TRANSFER_OUT":{const n=J(e.id||e.contractId);return{type:L.TransferOut,id:n,to:J(e.toAddress||e.to),amount:u(e.amount),assetId:J(e.assetId),pc:u(e.pc),is:u(e.is)}}case"SCRIPT_RESULT":return{type:L.ScriptResult,result:u(e.result),gasUsed:u(e.gasUsed)};case"MESSAGE_OUT":{const n=J(e.sender),s=J(e.recipient),a=J(e.nonce),r=u(e.amount),o=e.data?v(e.data):Uint8Array.from([]),i=J(e.digest),c=u(e.len).toNumber(),d=Qe.getMessageId({sender:n,recipient:s,nonce:a,amount:r,data:S(o)});return{type:L.MessageOut,sender:n,recipient:s,amount:r,nonce:a,len:c,data:o,digest:i,messageId:d}}case"MINT":{const n=J(e.id||e.contractId),s=J(e.subId),a=ra(n,s);return{type:L.Mint,subId:s,contractId:n,assetId:a,val:u(e.val),pc:u(e.pc),is:u(e.is)}}case"BURN":{const n=J(e.id||e.contractId),s=J(e.subId),a=ra(n,s);return{type:L.Burn,subId:s,contractId:n,assetId:a,val:u(e.val),pc:u(e.pc),is:u(e.is)}}default:throw new l(w.INVALID_RECEIPT_TYPE,`Invalid receipt type: ${t}.`)}},"deserializeReceipt"),wl=p(e=>{let t;switch(e.type){case"InputCoin":t={type:H.Coin,id:e.utxoId,amount:u(e.amount),assetId:e.assetId,owner:e.owner,txPointer:`0x${e.txPointer}`,witnessIndex:Number(e.coinWitnessIndex),predicate:e.predicate,predicateData:e.predicateData,predicateGasUsed:u(e.predicateGasUsed)};break;case"InputMessage":t={type:H.Message,nonce:e.nonce,amount:u(e.amount),recipient:e.recipient,sender:e.sender,data:e.data,witnessIndex:Number(e.messageWitnessIndex),predicate:e.predicate,predicateData:e.predicateData,predicateGasUsed:u(e.predicateGasUsed)};break;case"InputContract":t={type:H.Contract,contractId:e.contractId,txPointer:`0x${e.txPointer}`,txID:S(v(e.utxoId).slice(0,32))};break;default:gn()}return t},"deserializeInput"),bl=p(e=>{let t;switch(e.type){case"CoinOutput":t={type:k.Coin,amount:u(e.amount),assetId:e.assetId,to:e.to};break;case"ContractOutput":t={type:k.Contract,inputIndex:Number(e.inputIndex)};break;case"ChangeOutput":t={type:k.Change,assetId:e.assetId,to:e.to};break;case"ContractCreated":t={type:k.ContractCreated,stateRoot:e.stateRoot,contractId:e.contract};break;case"VariableOutput":t={type:k.Variable,amount:u(e.amount),assetId:e.assetId,to:e.to};break;default:gn()}return t},"deserializeOutput"),io=p(e=>{let t;switch(e.type){case"CoinOutput":t={type:k.Coin,amount:u(e.amount),assetId:e.assetId,to:e.to};break;case"ContractOutput":t={type:k.Contract,inputIndex:Number(e.inputIndex),balanceRoot:e.balanceRoot,stateRoot:e.stateRoot};break;case"ChangeOutput":t={type:k.Change,assetId:e.assetId,to:e.to,amount:u(e.amount)};break;case"ContractCreated":t={type:k.ContractCreated,stateRoot:e.stateRoot,contractId:e.contract};break;case"VariableOutput":t={type:k.Variable,amount:u(e.amount),assetId:e.assetId,to:e.to};break;default:gn()}return t},"deserializeProcessedTxOutput"),Il=p(e=>e.type===L.Revert&&e.val.toString("hex")===bs,"doesReceiptHaveMissingOutputVariables"),Cl=p(e=>e.type===L.Panic&&e.contractId!=="0x0000000000000000000000000000000000000000000000000000000000000000","doesReceiptHaveMissingContractId"),wa=p(e=>e.reduce((t,n)=>(Il(n)&&t.missingOutputVariables.push(n),Cl(n)&&t.missingOutputContractIds.push(n),t),{missingOutputVariables:[],missingOutputContractIds:[]}),"getReceiptsWithMissingData"),St=p(e=>e.filter(s=>s.type===L.ScriptResult).reduce((s,a)=>s.add(a.gasUsed),u(0)),"getGasUsedFromReceipts");function re(e,t){const n=u(t.base);let s=u(0);return"unitsPerGas"in t?s=u(e).div(u(t.unitsPerGas)):s=u(e).mul(u(t.gasPerUnit)),n.add(s)}p(re,"resolveGasDependentCosts");function co(e,t,n){const s=[],a=e.filter(i=>{if("owner"in i||"sender"in i){if("predicate"in i&&i.predicate&&i.predicate!=="0x")return!0;if(!s.includes(i.witnessIndex))return s.push(i.witnessIndex),!0}return!1}),r=re(t,n.vmInitialization);return a.reduce((i,c)=>"predicate"in c&&c.predicate&&c.predicate!=="0x"?i.add(r.add(re(v(c.predicate).length,n.contractRoot)).add(u(c.predicateGasUsed))):i.add(n.ecr1),u(0))}p(co,"gasUsedByInputs");function As(e){const{gasCosts:t,gasPerByte:n,inputs:s,metadataGas:a,txBytesSize:r}=e,o=re(r,t.vmInitialization),i=u(r).mul(n),c=co(s,r,t);return o.add(i).add(c).add(a).maxU64()}p(As,"getMinGas");function vn(e){const{gasPerByte:t,witnessesLength:n,witnessLimit:s,minGas:a,gasLimit:r=u(0),maxGasPerTx:o}=e;let i=u(0);s?.gt(0)&&s.gte(n)&&(i=u(s).sub(n).mul(t));const c=i.add(a).add(r);return c.gte(o)?o:c}p(vn,"getMaxGas");function Ps({gasCosts:e,stateRootSize:t,txBytesSize:n,contractBytesSize:s}){const a=re(s,e.contractRoot),r=re(t,e.stateRoot),o=re(n,e.s256),i=u(100),c=re(i,e.s256);return a.add(r).add(o).add(c).maxU64()}p(Ps,"calculateMetadataGasForTxCreate");function Es({gasCosts:e,txBytesSize:t}){return re(t,e.s256)}p(Es,"calculateMetadataGasForTxScript");function uo({gasCosts:e,txBytesSize:t,witnessBytesSize:n}){const s=re(t,e.s256),a=re(n,e.s256);return s.add(a)}p(uo,"calculateMetadataGasForTxBlob");function ns({gasCosts:e,txBytesSize:t,consensusSize:n}){const s=re(t,e.s256);if(n){const a=re(n,e.s256);s.add(a)}return s}p(ns,"calculateMetadataGasForTxUpgrade");function lo({gasCosts:e,txBytesSize:t,subsectionSize:n,subsectionsSize:s}){const a=re(t,e.s256),r=re(n,e.s256);a.add(r);const o=re(s,e.stateRoot);return a.add(o),a}p(lo,"calculateMetadataGasForTxUpload");function ho({gasCosts:e,baseMinGas:t,subsectionSize:n}){const s=u(e.newStoragePerByte).mul(n);return u(t).add(s)}p(ho,"calculateMinGasForTxUpload");var Ve=p(e=>{const{gas:t,gasPrice:n,priceFactor:s,tip:a}=e;return t.mul(n).div(s).add(u(a))},"calculateGasFee");function ln(e){return Object.keys(e).forEach(t=>{switch(e[t]?.constructor.name){case"Uint8Array":e[t]=S(e[t]);break;case"Array":e[t]=ln(e[t]);break;case"BN":e[t]=e[t].toHex();break;case"Address":e[t]=e[t].toB256();break;case"Object":e[t]=ln(e[t]);break}}),e}p(ln,"normalize");function po(e){return ln(ne(e))}p(po,"normalizeJSON");var Sl=p((e,t)=>{let n=`The transaction reverted with reason: "${e}".`;return Rd.includes(e)&&(n=`${n}

You can read more about this error at:

${xd}#variant.${e}`),new l(w.SCRIPT_REVERTED,n,{...t,reason:e})},"assemblePanicError"),ot=p(e=>JSON.stringify(e,null,2),"stringify"),vl=p((e,t,n)=>{let s="The transaction reverted with an unknown reason.",a="";const r=t[t.length-1],o=t[t.length-2];switch(e){case Br:{a="require",s=`The transaction reverted because a "require" statement has thrown ${t.length?ot(r):"an error."}.`;break}case Mr:{const i=t.length>=2?` comparing ${ot(r)} and ${ot(o)}.`:".";a="assert_eq",s=`The transaction reverted because of an "assert_eq" statement${i}`;break}case kr:{const i=t.length>=2?` comparing ${ot(o)} and ${ot(r)}.`:".";a="assert_ne",s=`The transaction reverted because of an "assert_ne" statement${i}`;break}case Lr:a="assert",s='The transaction reverted because an "assert" statement failed to evaluate to true.';break;case bs:a="MissingOutputVariable",s=`The transaction reverted because it's missing an "OutputVariable".`;break;default:a="revert_with_log",s=`The transaction reverted because a "revert_with_log" statement has thrown ${t.length?ot(r):"an error."}.`;break}return new l(w.SCRIPT_REVERTED,s,{...n,reason:a})},"assembleSignalErrorMessage");function fo(e,t,n,s){const{pos:a,msg:r}=e;let o="";const i=a?`

This error originated at ${JSON.stringify(a,null,2)}`:"";if(r)o=`A sway "panic" expression was invoked with the message: "${r}".${i}`;else{const c=t[t.length-1];o=`A sway "panic" expression was invoked with the value: ${JSON.stringify(c)}.${i}`}return new l(w.SCRIPT_REVERTED,o,{...n,abiError:e,reason:s})}p(fo,"buildAbiErrorMessage");function mo(e,t=[]){for(const n of t)if(n.errorCodes?.[e])return n.errorCodes[e]}p(mo,"findErrorInAbis");var Tl=p((e,t,n,s,a)=>{const o=s.match(/Revert\((\d+)\)/)?.[1]??s,i=u(o).toHex();if(Object.values(Ad).includes(i))return vl(i,t,n);let c;if(a){const h=[a.main,...Object.values(a.otherContractsAbis)];c=mo(o,h)}if(c)return fo(c,t,n,o);const d=`The transaction reverted with reason: ${o}.`;return new l(w.SCRIPT_REVERTED,d,{...n,reason:o})},"assembleRevertError"),Os=p(e=>{const{receipts:t,statusReason:n,logs:s,groupedLogs:a,abis:r}=e,o=t.some(({type:d})=>d===L.Panic),i=t.some(({type:d})=>d===L.Revert),c={logs:s,groupedLogs:a,receipts:t,panic:o,revert:i,reason:""};return o?Sl(n,c):Tl(t,s,c,n,r)},"extractTxError"),Zt=p((...e)=>{const t={};function n({amount:s,assetId:a}){t[a]?t[a]=t[a].add(s):t[a]=s}return p(n,"addToMap"),e.forEach(s=>s.forEach(n)),Object.entries(t).map(([s,a])=>({assetId:s,amount:a}))},"mergeQuantities");(class extends Error{static{p(this,"ChangeOutputCollisionError")}name="ChangeOutputCollisionError";message='A ChangeOutput with the same "assetId" already exists for a different "to" address'});var Rl=class extends Error{constructor(e){super(),this.index=e,this.message=`Witness at index "${e}" was not found`}static{p(this,"NoWitnessAtIndexError")}name="NoWitnessAtIndexError"};(class extends Error{constructor(e){super(),this.owner=e,this.message=`A witness for the given owner "${e}" was not found`}static{p(this,"NoWitnessByOwnerError")}name="NoWitnessByOwnerError"});var Pe=p(e=>e.type===H.Coin,"isRequestInputCoin"),Tn=p(e=>e.type===H.Message,"isRequestInputMessage"),go=p(e=>e.type===H.Message&&u(e.data).isZero(),"isRequestInputMessageWithoutData"),Rn=p(e=>Pe(e)||Tn(e),"isRequestInputCoinOrMessage"),yt=p(e=>Pe(e)||go(e),"isRequestInputResource"),yo=p(e=>Pe(e)?e.owner:e.recipient,"getRequestInputResourceOwner"),ss=p((e,t)=>yo(e)===t.toB256(),"isRequestInputResourceFromOwner"),ba=p(e=>Rn(e)&&!!e.predicate&&S(e.predicate)!=="0x","isPredicate"),xl=p((e,t,n)=>e.filter(yt).reduce((s,a)=>Pe(a)&&a.assetId===t||Tn(a)&&t===n?s.add(a.amount):s,u(0)),"getAssetAmountInRequestInputs"),Al=p((e,t)=>e.reduce((n,s)=>(Pe(s)&&s.owner===t.toB256()?n.utxos.push(s.id):Tn(s)&&s.recipient===t.toB256()&&n.messages.push(s.nonce),n),{utxos:[],messages:[]}),"cacheRequestInputsResourcesFromOwner"),Pl=p((e,t)=>{const{inputs:n,outputs:s}=t,a=new Set(n.filter(Pe).map(i=>i.assetId));n.some(i=>Tn(i)&&u(i.amount).gt(0))&&a.add(e);const r=new Set(s.filter(i=>i.type===k.Change).map(i=>i.assetId));return new Set([...a].filter(i=>!r.has(i))).size},"getBurnableAssetCount"),wo=p((e,t,n=!1)=>{if(n===!0||Pl(e,t)<=0)return;const s=["Asset burn detected.","Add the relevant change outputs to the transaction to avoid burning assets.","Or enable asset burn, upon sending the transaction."].join(`
`);throw new l(w.ASSET_BURN_DETECTED,s)},"validateTransactionForAssetBurn"),El=p(e=>{const t=v(e);return{data:S(t),dataLength:t.length}},"witnessify"),$t=class bo{static{p(this,"BaseTransactionRequest")}tip;maturity;expiration;maxFee;witnessLimit;inputs=[];outputs=[];witnesses=[];flag={state:void 0,transactionId:void 0,summary:void 0};constructor({tip:t,maturity:n,expiration:s,maxFee:a,witnessLimit:r,inputs:o,outputs:i,witnesses:c,flag:d}={}){this.tip=t?u(t):void 0,this.maturity=n&&n>0?n:void 0,this.expiration=s&&s>0?s:void 0,this.witnessLimit=he(r)?u(r):void 0,this.maxFee=u(a),this.inputs=o??[],this.outputs=i??[],this.witnesses=c??[],this.flag=d??{state:void 0,transactionId:void 0,summary:void 0}}static getPolicyMeta(t){let n=0;const s=[],{tip:a,witnessLimit:r,maturity:o,expiration:i}=t;return u(a).gt(0)&&(n+=ie.Tip,s.push({data:u(a),type:ie.Tip})),he(r)&&u(r).gte(0)&&(n+=ie.WitnessLimit,s.push({data:u(r),type:ie.WitnessLimit})),o&&o>0&&(n+=ie.Maturity,s.push({data:o,type:ie.Maturity})),n+=ie.MaxFee,s.push({data:t.maxFee,type:ie.MaxFee}),i&&i>0&&(n+=ie.Expiration,s.push({data:i,type:ie.Expiration})),{policyTypes:n,policies:s}}getBaseTransaction(){const t=this.inputs?.map(ll)??[],n=this.outputs?.map(hl)??[],s=this.witnesses?.map(El)??[],{policyTypes:a,policies:r}=bo.getPolicyMeta(this);return{policyTypes:a,inputs:t,outputs:n,policies:r,witnesses:s,inputsCount:t.length,outputsCount:n.length,witnessesCount:s.length}}toTransactionBytes(){return new ve().encode(this.toTransaction())}pushInput(t){return this.inputs.push(t),this.inputs.length-1}pushOutput(t){return this.outputs.push(t),this.outputs.length-1}addWitness(t){return this.witnesses.push(t),this.witnesses.length-1}addEmptyWitness(){return this.addWitness(B([K,K]))}updateWitnessByOwner(t,n){const s=new G(t),a=this.getCoinInputWitnessIndexByOwner(s);typeof a=="number"&&this.updateWitness(a,n)}updateWitness(t,n){if(!this.witnesses[t])throw new Rl(t);this.witnesses[t]=n}async addAccountWitnesses(t){const n=Array.isArray(t)?t:[t];return await Promise.all(n.map(async s=>{this.addWitness(await s.signTransaction(this))})),this}getCoinInputs(){return this.inputs.filter(t=>t.type===H.Coin)}getCoinOutputs(){return this.outputs.filter(t=>t.type===k.Coin)}getChangeOutputs(){return this.outputs.filter(t=>t.type===k.Change)}getCoinInputWitnessIndexByOwner(t){const n=Ot(t);return this.inputs.find(a=>{switch(a.type){case H.Coin:return S(a.owner)===n.toB256();case H.Message:return S(a.recipient)===n.toB256();default:return!1}})?.witnessIndex}addCoinInput(t){const{assetId:n,owner:s,amount:a,id:r,predicate:o,predicateData:i}=t;let c;t.predicate?c=0:(c=this.getCoinInputWitnessIndexByOwner(s),typeof c!="number"&&(c=this.addEmptyWitness()));const d={id:r,type:H.Coin,owner:s.toB256(),amount:a,assetId:n,txPointer:"0x00000000000000000000000000000000",witnessIndex:c,predicate:o,predicateData:i};this.pushInput(d),this.addChangeOutput(s,n)}addMessageInput(t){const{recipient:n,sender:s,amount:a,predicate:r,nonce:o,predicateData:i}=t;let c;t.predicate?c=0:(c=this.getCoinInputWitnessIndexByOwner(n),typeof c!="number"&&(c=this.addEmptyWitness()));const d={nonce:o,type:H.Message,sender:s.toB256(),recipient:n.toB256(),data:ya(t)?"0x":t.data,amount:a,witnessIndex:c,predicate:r,predicateData:i};this.pushInput(d),ya(t)&&this.addChangeOutput(n,t.assetId)}addResource(t){return pl(t)?this.addCoinInput(t):this.addMessageInput(t),this}addResources(t){return t.forEach(n=>this.addResource(n)),this}addCoinOutput(t,n,s){return this.pushOutput({type:k.Coin,to:Ot(t).toB256(),amount:n,assetId:s}),this}addCoinOutputs(t,n){return n.map(vs).forEach(s=>{this.pushOutput({type:k.Coin,to:Ot(t).toB256(),amount:s.amount,assetId:s.assetId})}),this}addChangeOutput(t,n){this.getChangeOutputs().find(a=>S(a.assetId)===n)||this.pushOutput({type:k.Change,to:Ot(t).toB256(),assetId:n})}byteSize(){return this.toTransactionBytes().length}metadataGas(t){throw new l(l.CODES.NOT_IMPLEMENTED,"Not implemented")}calculateMinGas(t){const{consensusParameters:n}=t,{gasCosts:s,feeParameters:{gasPerByte:a}}=n;return As({gasPerByte:a,gasCosts:s,inputs:this.inputs,txBytesSize:this.byteSize(),metadataGas:this.metadataGas(s)})}calculateMaxGas(t,n){const{consensusParameters:s}=t,{feeParameters:{gasPerByte:a},txParameters:{maxGasPerTx:r}}=s,o=this.toTransaction().witnesses.reduce((i,c)=>i+c.dataLength,0);return vn({gasPerByte:a,minGas:n,witnessesLength:o,witnessLimit:this.witnessLimit,maxGasPerTx:r})}fundWithFakeUtxos(t,n,s){const a=p(o=>this.inputs.find(i=>"assetId"in i?i.assetId===o:!1),"findAssetInput"),r=p((o,i)=>{const c=a(o);let d=i;o===n&&(d=u("1000000000000000000")),c&&"assetId"in c?(c.id=S(we(rn)),c.amount=d):this.addResources([{id:S(we(rn)),amount:d,assetId:o,owner:s||G.fromRandom(),blockCreated:u(1),txCreatedIdx:u(1)}])},"updateAssetInput");return r(n,u(1e11)),t.forEach(o=>r(o.assetId,o.amount)),this}getCoinOutputsQuantities(){return this.getCoinOutputs().map(({amount:n,assetId:s})=>({amount:u(n),assetId:s.toString()}))}toJSON(){return po(this)}removeWitness(t){this.witnesses.splice(t,1),this.adjustWitnessIndexes(t)}adjustWitnessIndexes(t){this.inputs.filter(yt).forEach(n=>{n.witnessIndex>t&&(n.witnessIndex-=1)})}updatePredicateGasUsed(t){const n=t.filter(Rn);this.inputs.filter(yt).forEach(s=>{const a=yo(s),r=n.find(o=>ss(o,new G(String(a))));r&&"predicateGasUsed"in r&&u(r.predicateGasUsed).gt(0)&&(s.predicateGasUsed=r.predicateGasUsed)})}byteLength(){return this.toTransactionBytes().byteLength}updateState(t,n,s){if(!n){this.flag={state:void 0,transactionId:void 0,summary:void 0};return}const a=this.getTransactionId(t);this.flag={state:n,transactionId:a,summary:s}}};function vt(e,t){const n=e.toTransaction();n.type===j.Script&&(n.receiptsRoot=K),n.inputs=n.inputs.map(r=>{const o=ne(r);switch(o.type){case H.Coin:return o.txPointer={blockHeight:0,txIndex:0},o.predicateGasUsed=u(0),o;case H.Message:return o.predicateGasUsed=u(0),o;case H.Contract:return o.txPointer={blockHeight:0,txIndex:0},o.txID=K,o.outputIndex=0,o.balanceRoot=K,o.stateRoot=K,o;default:return o}}),n.outputs=n.outputs.map(r=>{const o=ne(r);switch(o.type){case k.Contract:return o.balanceRoot=K,o.stateRoot=K,o;case k.Change:return o.amount=u(0),o;case k.Variable:return o.to=K,o.amount=u(0),o.assetId=K,o;default:return o}}),n.witnessesCount=0,n.witnesses=[];const s=gr(t),a=B([s,new ve().encode(n)]);return te(a)}p(vt,"hashTransaction");var hn=class extends $t{static{p(this,"BlobTransactionRequest")}static from(e){return new this(ne(e))}type=j.Blob;blobId;witnessIndex;constructor({witnessIndex:e,blobId:t,...n}){super(n),this.blobId=t,this.witnessIndex=e??0}toTransaction(){const e=this.getBaseTransaction(),{witnessIndex:t,blobId:n}=this;return{type:j.Blob,...e,blobId:n,witnessIndex:t}}getTransactionId(e){return vt(this,e)}metadataGas(e){return uo({gasCosts:e,txBytesSize:this.byteSize(),witnessBytesSize:this.witnesses[this.witnessIndex].length})}},Ol=p(e=>{const t=new Uint8Array(32);return t.set(v(e)),t},"getStorageValue"),Dl=p(e=>{let t,n;return Array.isArray(e)?(t=e[0],n=e[1]):(t=e.key,n=e.value),{key:S(t),value:S(Ol(n))}},"storageSlotify"),as=class extends $t{static{p(this,"CreateTransactionRequest")}static from(e){return new this(ne(e))}type=j.Create;bytecodeWitnessIndex;salt;storageSlots;constructor({bytecodeWitnessIndex:e,salt:t,storageSlots:n,...s}){super(s),this.bytecodeWitnessIndex=e??0,this.salt=S(t??K),this.storageSlots=[...n??[]]}toTransaction(){const e=this.getBaseTransaction(),t=this.bytecodeWitnessIndex,n=this.storageSlots?.map(Dl)??[];return{type:j.Create,...e,bytecodeWitnessIndex:t,storageSlotsCount:u(n.length),salt:this.salt?S(this.salt):K,storageSlots:n}}getContractCreatedOutputs(){return this.outputs.filter(e=>e.type===k.ContractCreated)}getTransactionId(e){return vt(this,e)}addContractCreatedOutput(e,t){this.pushOutput({type:k.ContractCreated,contractId:e,stateRoot:t})}metadataGas(e){return Ps({contractBytesSize:u(v(this.witnesses[this.bytecodeWitnessIndex]||"0x").length),gasCosts:e,stateRootSize:this.storageSlots.length,txBytesSize:this.byteSize()})}},Ia={bytes:v("0x24000000"),encodeScriptData:p(()=>new Uint8Array(0),"encodeScriptData")},Nl={bytes:v("0x5040C0105D44C0064C40001124000000")},Ae=class extends $t{static{p(this,"ScriptTransactionRequest")}static from(e){return new this(ne(e))}type=j.Script;gasLimit;script;scriptData;abis;constructor({script:e,scriptData:t,gasLimit:n,...s}={}){super(s),this.gasLimit=u(n),this.script=v(e??Ia.bytes),this.scriptData=v(t??Ia.encodeScriptData()),this.abis=s.abis}async estimateAndFund(e,{signatureCallback:t,quantities:n=[],skipAutoConsolidation:s}={}){const a=await e.getTransactionCost(this,{signatureCallback:t,quantities:n});return this.maxFee=a.maxFee,this.gasLimit=a.gasUsed,await e.fund(this,a,{skipAutoConsolidation:s}),this}toTransaction(){const e=v(this.script??"0x"),t=v(this.scriptData??"0x");return{type:j.Script,scriptGasLimit:this.gasLimit,...super.getBaseTransaction(),scriptLength:u(e.length),scriptDataLength:u(t.length),receiptsRoot:K,script:S(e),scriptData:S(t)}}getContractInputs(){return this.inputs.filter(e=>e.type===H.Contract)}getContractOutputs(){return this.outputs.filter(e=>e.type===k.Contract)}getVariableOutputs(){return this.outputs.filter(e=>e.type===k.Variable)}setScript(e,t){this.scriptData=e.encodeScriptData(t),this.script=e.bytes}addVariableOutputs(e=1){let t=e;for(;t;)this.pushOutput({type:k.Variable}),t-=1;return this.outputs.length-1}addVariableOutput(e,t,n){this.pushOutput({type:k.Variable,to:e,amount:t,assetId:n})}calculateMaxGas(e,t){const{consensusParameters:n}=e,{feeParameters:{gasPerByte:s},txParameters:{maxGasPerTx:a}}=n,r=this.toTransaction().witnesses.reduce((o,i)=>o+i.dataLength,0);return vn({gasPerByte:s,minGas:t,witnessesLength:r,witnessLimit:this.witnessLimit,gasLimit:this.gasLimit,maxGasPerTx:a})}addContractInputAndOutput(e){const t=Ot(e);if(this.getContractInputs().find(s=>s.contractId===t.toB256()))return this;const n=super.pushInput({type:H.Contract,contractId:t.toB256(),txPointer:"0x00000000000000000000000000000000"});return this.pushOutput({type:k.Contract,inputIndex:n}),this}getTransactionId(e){return vt(this,e)}setData(e,t){const n=new be(e);return this.scriptData=n.functions.main.encodeArguments(t),this}metadataGas(e){return Es({gasCosts:e,txBytesSize:this.byteSize()})}},Ca=class Io extends $t{static{p(this,"UpgradeTransactionRequest")}static from(t){return t instanceof Io?t:new this(ne(t))}type=j.Upgrade;upgradePurpose;bytecodeWitnessIndex;constructor({upgradePurpose:t,bytecodeWitnessIndex:n,...s}={}){super(s),this.bytecodeWitnessIndex=n??0,this.upgradePurpose=t??{type:me.ConsensusParameters,checksum:"0x"}}addConsensusParametersUpgradePurpose(t){return this.bytecodeWitnessIndex=this.addWitness(t),this.upgradePurpose={type:me.ConsensusParameters,checksum:Te(t)},this}addStateTransitionUpgradePurpose(t){return this.upgradePurpose={type:me.StateTransition,data:S(t)},this}addUpgradePurpose(t,n){return t===me.ConsensusParameters&&this.addConsensusParametersUpgradePurpose(n),t===me.StateTransition&&this.addStateTransitionUpgradePurpose(n),this}toTransaction(){let t;if(this.upgradePurpose.type===me.ConsensusParameters)t={type:me.ConsensusParameters,data:{witnessIndex:this.bytecodeWitnessIndex,checksum:this.upgradePurpose.checksum}};else if(this.upgradePurpose.type===me.StateTransition)t={type:me.StateTransition,data:{bytecodeRoot:S(this.upgradePurpose.data)}};else throw new l(l.CODES.NOT_IMPLEMENTED,"Invalid upgrade purpose");return{type:j.Upgrade,...super.getBaseTransaction(),upgradePurpose:t}}getTransactionId(t){return vt(this,t)}metadataGas(t){const n=this.byteSize();if(this.upgradePurpose.type===me.ConsensusParameters){const s=this.bytecodeWitnessIndex,a=this.witnesses[s].length;return ns({gasCosts:t,txBytesSize:n,consensusSize:a})}if(this.upgradePurpose.type===me.StateTransition)return ns({gasCosts:t,txBytesSize:n});throw new l(l.CODES.NOT_IMPLEMENTED,"Invalid upgrade purpose")}},Sa=class Co extends $t{static{p(this,"UploadTransactionRequest")}static from(t){return t instanceof Co?t:new this(ne(t))}type=j.Upload;witnessIndex;subsection;constructor({witnessIndex:t,subsection:n,...s}={}){super(s),this.witnessIndex=t??0,this.subsection=n??{proofSet:[],root:K,subsectionIndex:0,subsectionsNumber:0}}addSubsection(t){const{subsection:n,...s}=t;this.subsection=s,this.witnessIndex=this.addWitness(n)}getTransactionId(t){return vt(this,t)}toTransaction(){const t=this.getBaseTransaction(),{subsectionIndex:n,subsectionsNumber:s,root:a,proofSet:r}=this.subsection;return{type:j.Upload,...t,subsectionIndex:n,subsectionsNumber:s,root:S(a),proofSet:r.map(S),witnessIndex:this.witnessIndex,proofSetCount:r.length}}metadataGas(t){return lo({gasCosts:t,txBytesSize:this.byteSize(),subsectionSize:v(this.witnesses[this.witnessIndex]).length,subsectionsSize:this.subsection.subsectionsNumber})}calculateMinGas(t){const n=super.calculateMinGas(t),{gasCosts:s}=t.consensusParameters,a=this.witnesses[this.witnessIndex]??K;return ho({gasCosts:s,baseMinGas:n.toNumber(),subsectionSize:v(a).length})}};(class{static{p(this,"AbstractScriptRequest")}});var oe=p(e=>{if(e instanceof Ae||e instanceof as||e instanceof hn||e instanceof Ca||e instanceof Sa)return e;const{type:t}=e;switch(e.type){case j.Script:return Ae.from(e);case j.Create:return as.from(e);case j.Blob:return hn.from(e);case j.Upgrade:return Ca.from(e);case j.Upload:return Sa.from(e);default:throw new l(w.UNSUPPORTED_TRANSACTION_TYPE,`Unsupported transaction type: ${t}.`)}},"transactionRequestify"),He=p(e=>e.type===j.Script,"isTransactionTypeScript"),Fl=p(e=>e.type===j.Create,"isTransactionTypeCreate"),Rt=new Map,va=class{static{p(this,"ResourceCache")}ttl;constructor(e){if(this.ttl=e,typeof e!="number"||this.ttl<=0)throw new l(w.INVALID_TTL,`Invalid TTL: ${this.ttl}. Use a value greater than zero.`)}set(e,t){const n=this.setupResourcesCache(t);Rt.set(e,n)}unset(e){Rt.delete(e)}getActiveData(e){const t={utxos:[],messages:[]},n=Date.now(),s=[];return Rt.forEach((a,r)=>{if(n-a.timestamp<this.ttl){const i=a.owners.get(e);i&&(t.utxos.push(...i.utxos),t.messages.push(...i.messages))}else s.push(r)}),s.forEach(this.unset),t.utxos.reverse(),t.messages.reverse(),t}isCached(e,t){const n=Date.now();let s=!1;const a=[];for(const[r,o]of Rt.entries())if(n-o.timestamp<this.ttl){const c=o.owners.get(e);if(c?.utxos.has(t)||c?.messages.has(t)){s=!0;break}}else a.push(r);return a.forEach(this.unset),s}clear(){Rt.clear()}setupResourcesCache(e){const t=Date.now(),n={owners:new Map,timestamp:t};return e.filter(Rn).forEach(s=>{const{owner:a,key:r,type:o}=this.extractResourceData(s);n.owners.has(a)||n.owners.set(a,{utxos:new Set,messages:new Set}),o==="utxo"?n.owners.get(a)?.utxos.add(r):n.owners.get(a)?.messages.add(r)}),n}extractResourceData(e){return Pe(e)?{owner:S(e.owner),key:S(e.id),type:"utxo"}:{owner:S(e.recipient),key:S(e.nonce),type:"message"}}},_l=p(e=>{const{gasPrice:t,rawPayload:n,tip:s,consensusParameters:{gasCosts:a,feeParams:r,maxGasPerTx:o}}=e,i=u(r.gasPerByte),c=u(r.gasPriceFactor),d=v(n),[h]=new ve().decode(d,0),{type:f,witnesses:b,inputs:g,policies:I}=h;let m=u(0),y=u(0);if(f!==j.Create&&f!==j.Script)return u(0);if(f===j.Create){const{bytecodeWitnessIndex:E,storageSlots:W}=h,D=u(v(b[E].data).length);m=Ps({contractBytesSize:D,gasCosts:a,stateRootSize:W.length||0,txBytesSize:d.length})}else{const{scriptGasLimit:E}=h;E&&(y=E),m=Es({gasCosts:a,txBytesSize:d.length})}const C=As({gasCosts:a,gasPerByte:u(i),inputs:g,metadataGas:m,txBytesSize:d.length}),T=I.find(E=>E.type===ie.WitnessLimit)?.data,A=b.reduce((E,W)=>E+W.dataLength,0),R=vn({gasPerByte:i,minGas:C,witnessesLength:A,gasLimit:y,witnessLimit:T,maxGasPerTx:o});return Ve({gasPrice:t,gas:R,priceFactor:c,tip:s})},"calculateTXFeeForSummary"),Bl=p(({abi:e,receipt:t,offset:n,scriptData:s})=>{const[a,r]=new fs().decode(s,n),i=new be(e).getFunction(a),c=i.jsonFn.inputs;let d;if(c.length){const h=s.slice(r),f=i.decodeArguments(h);d=c.reduce((b,g,I)=>{const m=f?.[I],y=g.name;return y?{...b,[y]:JSON.parse(JSON.stringify(m))}:b},{})}return{functionSignature:i.signature,functionName:i.name,argumentsProvided:d,...t.amount?.isZero()?{}:{amount:t.amount,assetId:t.assetId}}},"getFunctionCall");function So(e,t){return e.filter(n=>t.includes(n.type))}p(So,"getInputsByTypes");function xn(e,t){return e.filter(n=>n.type===t)}p(xn,"getInputsByType");function vo(e){return xn(e,H.Coin)}p(vo,"getInputsCoin");function To(e){return xn(e,H.Message)}p(To,"getInputsMessage");function Ds(e){return So(e,[H.Coin,H.Message])}p(Ds,"getInputsCoinAndMessage");function rs(e){return e.type===H.Coin}p(rs,"isInputCoin");function Ro(e){return xn(e,H.Contract)}p(Ro,"getInputsContract");function xo(e,t){return vo(e).find(s=>s.assetId===t)}p(xo,"findCoinInput");function Ao(e,t){const n=new Map;return Ds(e).forEach(s=>{const a=rs(s)?s.assetId:t,r=rs(s)?s.owner:s.recipient;let o=n.get(a);o||(o=new Map,n.set(a,o));let i=o.get(r);i||(i=new ac(0),o.set(r,i)),o.set(r,i.add(s.amount))}),n}p(Ao,"aggregateInputsAmountsByAssetAndOwner");function Po(e){return To(e)?.[0]}p(Po,"findMessageInput");function Ns(e,t,n=!1){const s=xo(e,t);if(s)return s;if(n)return Po(e)}p(Ns,"getInputFromAssetId");function Eo(e,t){if(t==null)return;const n=e?.[t];if(n){if(n.type!==H.Contract)throw new l(w.INVALID_TRANSACTION_INPUT,"Contract input should be of type 'contract'.");return n}}p(Eo,"getInputContractFromIndex");function An(e){return e.type===H.Coin?e.owner.toString():e.type===H.Message?e.recipient.toString():""}p(An,"getInputAccountAddress");function Tt(e,t){return e.filter(n=>n.type===t)}p(Tt,"getOutputsByType");function Oo(e){return Tt(e,k.ContractCreated)}p(Oo,"getOutputsContractCreated");function Fs(e){return Tt(e,k.Coin)}p(Fs,"getOutputsCoin");function Do(e){return Tt(e,k.Change)}p(Do,"getOutputsChange");function No(e){return Tt(e,k.Contract)}p(No,"getOutputsContract");function Ml(e){return Tt(e,k.Variable)}p(Ml,"getOutputsVariable");var Fo=(e=>(e.submitted="submitted",e.success="success",e.squeezedout="squeezedout",e.failure="failure",e.preconfirmationSuccess="preconfirmationSuccess",e.preconfirmationFailure="preconfirmationFailure",e))(Fo||{});function wt(e,t){return(e??[]).filter(n=>n.type===t)}p(wt,"getReceiptsByType");function Pn(e){switch(e){case j.Mint:return"Mint";case j.Create:return"Create";case j.Script:return"Script";case j.Blob:return"Blob";case j.Upgrade:return"Upgrade";case j.Upload:return"Upload";default:throw new l(w.UNSUPPORTED_TRANSACTION_TYPE,`Unsupported transaction type: ${e}.`)}}p(Pn,"getTransactionTypeName");function at(e,t){return Pn(e)===t}p(at,"isType");function _s(e){return at(e,"Mint")}p(_s,"isTypeMint");function En(e){return at(e,"Create")}p(En,"isTypeCreate");function On(e){return at(e,"Script")}p(On,"isTypeScript");function Bs(e){return at(e,"Upgrade")}p(Bs,"isTypeUpgrade");function Ms(e){return at(e,"Upload")}p(Ms,"isTypeUpload");function Ls(e){return at(e,"Blob")}p(Ls,"isTypeBlob");function Ll(e){return t=>e.assetId===t.assetId}p(Ll,"hasSameAssetId");function _o(e){return wt(e,L.Call)}p(_o,"getReceiptsCall");function Bo(e){return wt(e,L.MessageOut)}p(Bo,"getReceiptsMessageOut");function Mo(e,t){const n=e.assetsSent||[],s=t.assetsSent||[],a=new Map;return n.forEach(r=>{a.set(r.assetId,{...r})}),s.forEach(r=>{const o=a.get(r.assetId);o?o.amount=u(o.amount).add(r.amount):a.set(r.assetId,{...r})}),Array.from(a.values())}p(Mo,"mergeAssets");function Lo(e,t){return e.name===t.name&&e.from?.address===t.from?.address&&e.to?.address===t.to?.address&&e.from?.type===t.from?.type&&e.to?.type===t.to?.type}p(Lo,"isSameOperation");function ko(e,t){return t.assetsSent?.length?e.assetsSent?.length?Mo(e,t):t.assetsSent:e.assetsSent}p(ko,"mergeAssetsSent");function Uo(e,t){return t.calls?.length?[...e.calls||[],...t.calls]:e.calls}p(Uo,"mergeCalls");function Go(e,t){return{...e,assetsSent:ko(e,t),calls:Uo(e,t),receipts:[...e.receipts||[],...t.receipts?.filter(n=>!e.receipts?.some(s=>s===n))||[]]}}p(Go,"mergeOperations");function bt(e,t){const n=e.findIndex(s=>Lo(s,t));return n===-1?[...e,t]:e.map((s,a)=>a===n?Go(s,t):s)}p(bt,"addOperation");function kl(e){return wt(e,L.TransferOut)}p(kl,"getReceiptsTransferOut");function $o({inputs:e,receipts:t,baseAssetId:n}){return Bo(t).reduce((r,o)=>{const i=Ns(e,n,!0);if(i){const c=An(i);return bt(r,{name:"Withdraw from Fuel",from:{type:1,address:c},to:{type:1,address:o.recipient.toString(),chain:"ethereum"},assetsSent:[{amount:o.amount,assetId:n}],receipts:[o]})}return r},[])}p($o,"getWithdrawFromFuelOperations");function zo(e,t){for(let n=0;n<=e.length-t.length;n++){let s=!0;for(let a=0;a<t.length;a++)if(e[n+a]!==t[a]){s=!1;break}if(s)return n}return-1}p(zo,"findBytesSegmentIndex");function Wo(e,t,n,s){const a=[],r=t?.[e.contractID];if(!r||!s)return a;const o=B([v(n.to),Se(n.param1.toHex(),8),Se(n.param2.toHex(),8)]),i=zo(s,o);if(!(i!==-1))return a;const d=i+o.length,h=Bl({abi:r,receipt:n,offset:d,scriptData:s});return a.push(h),a}p(Wo,"getContractCalls");function Vo(e){return e.amount?.isZero()?void 0:[{amount:e.amount,assetId:e.assetId}]}p(Vo,"getAssetsSent");function qo(e,t,n,s,a,r){const o=e.assetId===K?r:e.assetId,i=Ns(n,o,o===r);if(!i)return[];const c=An(i),d=Wo(t,s,e,a);return[{name:"Contract call",from:{type:1,address:c},to:{type:0,address:e.to},assetsSent:Vo(e),calls:d,receipts:[e]}]}p(qo,"processCallReceipt");function Ho({inputs:e,outputs:t,receipts:n,abiMap:s,rawPayload:a,baseAssetId:r}){const o=_o(n);return No(t).flatMap(c=>{const d=Eo(e,c.inputIndex);if(!d)return[];let h;if(a){const[f]=new ve().decode(v(a),0);f.type===j.Script&&(h=v(f.scriptData))}return o.filter(f=>f.to===d.contractID).flatMap(f=>qo(f,d,e,s,h,r))})}p(Ho,"getContractCallOperations");function jo(e,t,n){const{to:s,assetId:a,amount:r}=e;let{id:o}=e;const i=t.some(d=>d.contractID===s)?0:1;return K===o&&(o=n.find(h=>h.assetId===a)?.to||o),{name:"Transfer asset",from:{type:t.some(d=>d.contractID===o)?0:1,address:o},to:{type:i,address:s},assetsSent:[{assetId:a.toString(),amount:r}],receipts:[e]}}p(jo,"extractTransferOperationFromReceipt");function Ko({inputs:e,outputs:t,receipts:n,baseAssetId:s}){let a=[];const r=Fs(t),o=Ro(e),i=Do(t),c=Ao(e,s);r.forEach(({amount:f,assetId:b,to:g})=>{const I=c.get(b)||new Map;let m,y;for(const[C,T]of I)if(y||(y=C),T.gte(f)){m=C;break}m=m||y,m&&(a=bt(a,{name:"Transfer asset",from:{type:1,address:m},to:{type:1,address:g},assetsSent:[{assetId:b,amount:f}]}))});const d=wt(n,L.Transfer),h=wt(n,L.TransferOut);return[...d,...h].forEach(f=>{const b=jo(f,o,i);a=bt(a,b)}),a}p(Ko,"getTransferOperations");function Jo(e){return Fs(e).reduce((s,a)=>bt(s,{name:"Pay network fee to block producer",from:{type:1,address:"Network"},to:{type:1,address:a.to.toString()},assetsSent:[{assetId:a.assetId.toString(),amount:a.amount}]}),[])}p(Jo,"getPayProducerOperations");function Yo({inputs:e,outputs:t}){const n=Oo(t),s=Ds(e)[0],a=An(s);return n.reduce((o,i)=>bt(o,{name:"Contract created",from:{type:1,address:a},to:{type:0,address:i?.contractId||""}}),[])}p(Yo,"getContractCreatedOperations");function ks({transactionType:e,inputs:t,outputs:n,receipts:s,abiMap:a,rawPayload:r,maxInputs:o,baseAssetId:i}){return En(e)?[...Yo({inputs:t,outputs:n})]:On(e)?[...Ko({inputs:t,outputs:n,receipts:s,baseAssetId:i}),...Ho({inputs:t,outputs:n,receipts:s,abiMap:a,rawPayload:r,baseAssetId:i}),...$o({inputs:t,receipts:s,baseAssetId:i})]:[...Jo(n)]}p(ks,"getOperations");var Xo=p(e=>{const t=[];return e.forEach(n=>{n.type===L.Mint&&t.push({subId:n.subId,contractId:n.contractId,assetId:n.assetId,amount:n.val})}),t},"extractMintedAssetsFromReceipts"),Zo=p(e=>{const t=[];return e.forEach(n=>{n.type===L.Burn&&t.push({subId:n.subId,contractId:n.contractId,assetId:n.assetId,amount:n.val})}),t},"extractBurnedAssetsFromReceipts"),Ul=p(e=>{switch(e){case"FailureStatus":return"failure";case"SuccessStatus":return"success";case"SubmittedStatus":return"submitted";case"SqueezedOutStatus":return"squeezedout";case"PreconfirmationSuccessStatus":return"preconfirmationSuccess";case"PreconfirmationFailureStatus":return"preconfirmationFailure";default:throw new l(w.INVALID_TRANSACTION_STATUS,`Invalid transaction status: ${e}.`)}},"getTransactionStatusName"),Ta=p(e=>{const t=[];return e?.forEach(({utxoId:n,output:s})=>t.push({utxoId:n,output:io(s)})),t},"extractResolvedOutputs"),Qo=p(e=>{let t,n,s,a,r,o,i=[],c,d=!1,h=!1,f=!1,b=!1,g=!1;if(e?.type)switch(s=Ul(e.type),e.type){case"SuccessStatus":t=e.time,n=e.block?.id,h=!0,o=e.receipts?.map(ce),a=u(e.totalFee),r=u(e.totalGas);break;case"FailureStatus":t=e.time,n=e.block?.id,d=!0,a=u(e.totalFee),o=e.receipts?.map(ce),r=u(e.totalGas);break;case"SubmittedStatus":t=e.time,f=!0;break;case"PreconfirmationSuccessStatus":b=!0,a=u(e.totalFee),r=u(e.totalGas),o=e.preconfirmationReceipts?.map(ce),i=Ta(e.resolvedOutputs);break;case"PreconfirmationFailureStatus":g=!0,a=u(e.totalFee),r=u(e.totalGas),o=e.preconfirmationReceipts?.map(ce),i=Ta(e.resolvedOutputs),c=e.reason;break}return{time:t,blockId:n,status:s,totalFee:a,totalGas:r,receipts:o,isStatusFailure:d,isStatusSuccess:h,isStatusPending:f,isStatusPreConfirmationSuccess:b,isStatusPreConfirmationFailure:g,resolvedOutputs:i,errorReason:c}},"processGraphqlStatus"),ei=p(e=>e&&"totalFee"in e?u(e.totalFee):void 0,"getTotalFeeFromStatus");function zt(e){const{id:t,receipts:n,gasPerByte:s,gasPriceFactor:a,transaction:r,transactionBytes:o,gqlTransactionStatus:i,abiMap:c={},maxInputs:d,gasCosts:h,maxGasPerTx:f,gasPrice:b,baseAssetId:g}=e,I=St(n),m=S(o),y=ks({transactionType:r.type,inputs:r.inputs||[],outputs:r.outputs||[],receipts:n,rawPayload:m,abiMap:c,maxInputs:d,baseAssetId:g}),C=Pn(r.type),T=u(r.policies?.find(Vi=>Vi.type===ie.Tip)?.data),{isStatusFailure:A,isStatusPending:R,isStatusSuccess:M,blockId:E,status:W,time:D,totalFee:Y}=Qo(i),ee=Y??_l({gasPrice:b,rawPayload:m,tip:T,consensusParameters:{gasCosts:h,maxGasPerTx:f,feeParams:{gasPerByte:s,gasPriceFactor:a}}}),Ie=Xo(n),Wt=Zo(n);let rt;return D&&(rt=nr.fromTai64(D)),{id:t,tip:T,fee:ee,gasUsed:I,operations:y,type:C,blockId:E,time:D,status:W,receipts:n,mintedAssets:Ie,burnedAssets:Wt,isTypeMint:_s(r.type),isTypeCreate:En(r.type),isTypeScript:On(r.type),isTypeUpgrade:Bs(r.type),isTypeUpload:Ms(r.type),isTypeBlob:Ls(r.type),isStatusFailure:A,isStatusSuccess:M,isStatusPending:R,date:rt,transaction:r}}p(zt,"assembleTransactionSummary");function ti(e){const{id:t,gqlTransactionStatus:n,transactionRequest:s,baseAssetId:a,maxInputs:r,abiMap:o}=e;let i,c,d,h,f,b,g;const{isStatusFailure:I,isStatusSuccess:m,isStatusPending:y,status:C,receipts:T,resolvedOutputs:A,errorReason:R,totalFee:M,isStatusPreConfirmationFailure:E,isStatusPreConfirmationSuccess:W}=Qo(n);if(T&&(d=St(T),b=Xo(T),g=Zo(T)),s&&(f=s.toTransaction(),i=Pn(f.type),h=u(f.policies?.find(Y=>Y.type===ie.Tip)?.data),T)){const Y=S(new ve().encode(f));c=ks({transactionType:f.type,inputs:f.inputs||[],outputs:f.outputs||[],receipts:T,rawPayload:Y,abiMap:o,maxInputs:r,baseAssetId:a})}return{id:t,fee:M,type:i,status:C,receipts:T,gasUsed:d,tip:h,isStatusPreConfirmationFailure:E,isStatusPreConfirmationSuccess:W,isStatusFailure:I,isStatusSuccess:m,isStatusPending:y,...f&&{isTypeMint:_s(f.type),isTypeCreate:En(f.type),isTypeScript:On(f.type),isTypeUpgrade:Bs(f.type),isTypeUpload:Ms(f.type),isTypeBlob:Ls(f.type)},mintedAssets:b,burnedAssets:g,resolvedOutputs:A,errorReason:R,transaction:f,operations:c}}p(ti,"assemblePreConfirmationTransactionSummary");function Mt(e){const{receipts:t,mainAbi:n,externalAbis:s={}}=e;let a="";if(n.programType==="contract"){const r=t.find(o=>o.type===L.Call&&o.id===K);r&&(a=r.to)}return t.reduce(({logs:r,groupedLogs:o},i)=>{if(i.type===L.LogData||i.type===L.Log){const c=i.id===K||a===i.id;if(c||s[i.id]){const h=c?new be(n):new be(s[i.id]),f=i.type===L.Log?new O("u64").encode(i.ra):i.data,[b]=h.decodeLog(f,i.rb.toString());r.push(b),o[i.id]=[...o[i.id]||[],b]}}return{logs:r,groupedLogs:o}},{logs:[],groupedLogs:{}})}p(Mt,"getAllDecodedLogs");var Ra=class ni{static{p(this,"TransactionResponse")}id;provider;gasUsed=u(0);gqlTransaction;request;status;abis;submitTxSubscription;preConfirmationStatus;waitingForStreamData=!1;statusResolvers=new Map;constructor(t,n,s,a,r){let o,i,c,d;typeof t=="object"&&"provider"in t&&arguments.length===1?(o=t.transactionRequestOrId,i=t.provider,c=t.chainId,d=t.abis,this.submitTxSubscription=t.submitAndAwaitSubscription):(o=t,i=n,c=s,d=a,this.submitTxSubscription=r),typeof o=="string"?this.id=o:(this.id=o.getTransactionId(c),this.request=o),this.provider=i,this.abis=d,this.waitForResult=this.waitForResult.bind(this),this.waitForPreConfirmation=this.waitForPreConfirmation.bind(this)}static async create(t,n,s){const a=await n.getChainId(),r=new ni(t,n,a,s);return await r.fetch(),r}applyMalleableSubscriptionFields(t){const n=this.status;if(!n)return;const s=t;(n.type==="SuccessStatus"||n.type==="FailureStatus")&&(s.inputs=s.inputs.map((a,r)=>{if("txPointer"in a){const o=n.transaction.inputs?.[r];return{...a,txPointer:nt.decodeFromGqlScalar(o.txPointer)}}return a}),s.outputs=n.transaction.outputs.map(io),n.transaction.receiptsRoot&&(s.receiptsRoot=n.transaction.receiptsRoot))}async getTransaction(){if(this.request){const r=this.request.toTransaction();return this.applyMalleableSubscriptionFields(r),{tx:r,bytes:this.request.toTransactionBytes()}}const t=this.gqlTransaction??await this.fetch(),{rawPayload:n}=t,s=v(n),[a]=new ve().decode(s,0);return{tx:a,bytes:s}}getReceipts(){const t=this.getTransactionStatus();switch(t?.type){case"SuccessStatus":case"FailureStatus":return t.receipts.map(ce);default:return[]}}async fetch(){const t=await this.provider.operations.getTransactionWithReceipts({transactionId:this.id});if(!t.transaction){const n=await this.provider.operations.statusChange({transactionId:this.id});for await(const{statusChange:s}of n)if(s){this.status=s;break}return this.fetch()}return this.gqlTransaction=t.transaction,t.transaction}async getTransactionSummary(t){const{tx:n,bytes:s}=await this.getTransaction(),{gasPerByte:a,gasPriceFactor:r,gasCosts:o,maxGasPerTx:i}=await this.provider.getGasConfig(),c=this.getTransactionStatus(),h=ei(c)?u(0):await this.provider.getLatestGasPrice(),f=(await this.provider.getChain()).consensusParameters.txParameters.maxInputs,b=await this.provider.getBaseAssetId();return zt({id:this.id,receipts:this.getReceipts(),transaction:n,transactionBytes:s,gqlTransactionStatus:c,gasPerByte:a,gasPriceFactor:r,abiMap:t,maxInputs:f,gasCosts:o,maxGasPerTx:i,gasPrice:h,baseAssetId:b})}async getPreConfirmationTransactionSummary(t){const n=await this.provider.getBaseAssetId(),s=(await this.provider.getChain()).consensusParameters.txParameters.maxInputs;return ti({id:this.id,gqlTransactionStatus:this.preConfirmationStatus||this.status,baseAssetId:n,maxInputs:s,abiMap:t,transactionRequest:this.request})}resolveStatus(t){(this.statusResolvers.get(t)||[]).forEach(s=>s()),this.statusResolvers.delete(t)}async waitForStatus(t){return new Promise((n,s)=>{const a=this.statusResolvers.get(t)||[];a.push(()=>{n()}),this.statusResolvers.set(t,a),this.waitForStatusChange().catch(s)})}async waitForStatusChange(){const t=this.status?.type;if(t&&(t==="FailureStatus"||t==="SuccessStatus")){this.resolveStatus("preConfirmation"),this.resolveStatus("confirmation");return}if(this.waitingForStreamData)return;this.waitingForStreamData=!0;const n=this.submitTxSubscription??await this.provider.operations.statusChange({transactionId:this.id,includePreConfirmation:!0});for await(const s of n){const a="statusChange"in s?s.statusChange:s.submitAndAwaitStatus;if(this.status=a,a.type==="SqueezedOutStatus")throw new l(w.TRANSACTION_SQUEEZED_OUT,`Transaction Squeezed Out with reason: ${a.reason}`);if((a.type==="PreconfirmationSuccessStatus"||a.type==="PreconfirmationFailureStatus")&&(this.preConfirmationStatus=a,this.resolveStatus("preConfirmation"),!this.statusResolvers.get("confirmation"))){this.waitingForStreamData=!1;break}if(a.type==="SuccessStatus"||a.type==="FailureStatus"){this.resolveStatus("confirmation"),this.resolveStatus("preConfirmation"),this.waitingForStreamData=!1;break}}}async waitForConfirmationStatuses(){try{await this.waitForStatus("confirmation")}catch(t){throw this.unsetResourceCache(),t}}async waitForPreConfirmationStatuses(){try{await this.waitForStatus("preConfirmation")}catch(t){throw this.unsetResourceCache(),t}}async assembleResult(t){const n=await this.getTransactionSummary(t),s={...n};let{logs:a,groupedLogs:r}={logs:[],groupedLogs:{}},o;this.abis&&({logs:a,groupedLogs:r}=Mt({receipts:n.receipts,mainAbi:this.abis.main,externalAbis:this.abis.otherContractsAbis}),s.logs=a,s.groupedLogs=r,o=this.abis);const{receipts:i}=s,c=this.getTransactionStatus();if(c?.type==="FailureStatus"){const{reason:d}=c;throw Os({receipts:i,statusReason:d,logs:a,groupedLogs:r,abis:o})}return s}async assemblePreConfirmationResult(t){const n=await this.getPreConfirmationTransactionSummary(t),s={...n,logs:[],groupedLogs:{}};let{logs:a,groupedLogs:r}={logs:[],groupedLogs:{}};return this.abis&&n.receipts&&({logs:a,groupedLogs:r}=Mt({receipts:n.receipts,mainAbi:this.abis.main,externalAbis:this.abis.otherContractsAbis}),s.logs=a,s.groupedLogs=r),s}async waitForResult(t){return await this.waitForConfirmationStatuses(),this.unsetResourceCache(),this.assembleResult(t)}async waitForPreConfirmation(t){return await this.waitForPreConfirmationStatuses(),this.unsetResourceCache(),this.assemblePreConfirmationResult(t)}async wait(t){return this.waitForResult(t)}unsetResourceCache(){this.provider.cache?.unset(this.id)}getTransactionStatus(){return this.status??this.gqlTransaction?.status}};function Gl(e,t,n={}){let s="";return t.programType==="contract"&&(s=e.find(r=>r.type===L.Call&&r.id===K).to),e.reduce((a,r)=>{if(r.type===L.LogData||r.type===L.Log){const o=r.id===K||s===r.id;if(o||n[r.id]){const c=o?new be(t):new be(n[r.id]),d=r.type===L.Log?new O("u64").encode(r.ra):r.data,[h]=c.decodeLog(d,r.rb.toString());a.push(h)}}return a},[])}p(Gl,"getDecodedLogs");function Us(e,t){const n=e.baseDelay??150;switch(e.backoff){case"linear":return n*t;case"fixed":return n;case"exponential":default:return 2**(t-1)*n}}p(Us,"getWaitDelay");function Gs(e,t,n=0){return t===void 0?e:async(...s)=>{try{return await e(...s)}catch(a){const r=a;if(r.cause?.code!=="ECONNREFUSED")throw r;const o=n+1;if(o>t.maxRetries)throw r;const i=Us(t,o);return await hs(i),Gs(e,t,o)(...s)}}}p(Gs,"autoRetryFetch");var $l=p(async e=>{const{response:t,isSubscription:n}=e;let s;const a=t.clone();if(n){const r=a.body?.getReader(),{event:o}=await Qn.readEvent(r);s=o?.extensions}else s=(await a.json()).extensions;return{extensions:s}},"parseGraphqlResponse"),lt=p(e=>{const{paginationLimit:t,inputArgs:n={}}=e,{first:s,last:a,after:r,before:o}=n;if(r&&o)throw new l(w.INVALID_INPUT_PARAMETERS,'Pagination arguments "after" and "before" cannot be used together');if((s||0)>t||(a||0)>t)throw new l(w.INVALID_INPUT_PARAMETERS,`Pagination limit for this query cannot exceed ${t} items`);if(s&&o)throw new l(w.INVALID_INPUT_PARAMETERS,'The use of pagination argument "first" with "before" is not supported');if(a&&r)throw new l(w.INVALID_INPUT_PARAMETERS,'The use of pagination argument "last" with "after" is not supported');return!s&&!a&&(n.first=t),n},"validatePaginationArgs"),xa=10,Aa=512,si=60,zl=100,Wl=1e4,Vl=5,ql=2e4,Hl=1.2,jl=["submit","submitAndAwaitStatus","produceBlocks"],Pa=class _{static{p(this,"Provider")}operations;cache;static clearChainAndNodeCaches(t){if(t){delete _.inflightFetchChainAndNodeInfoRequests[t],delete _.chainInfoCache[t],delete _.nodeInfoCache[t],delete _.currentBlockHeightCache[t];return}_.inflightFetchChainAndNodeInfoRequests={},_.nodeInfoCache={},_.chainInfoCache={},_.currentBlockHeightCache={}}url;urlWithoutAuth;static ENABLE_RPC_CONSISTENCY=!0;static inflightFetchChainAndNodeInfoRequests={};static chainInfoCache={};static nodeInfoCache={};static currentBlockHeightCache={};static incompatibleNodeVersionMessage="";consensusParametersTimestamp;options={timeout:void 0,resourceCacheTTL:void 0,fetch:void 0,retryOptions:void 0,headers:void 0,cache:void 0};static extractOperationName(t){return t?.toString().match(/"operationName":"(.+)"/)?.[1]}static isWriteOperation(t){return jl.includes(this.extractOperationName(t))}static normalizeUrl(t){return t.replace(/-sub$/,"")}static hasWriteOperationHappened(t){return he(_.currentBlockHeightCache[this.normalizeUrl(t)])}static getFetchFn(t){const{retryOptions:n,timeout:s,headers:a}=t;return Gs(async(...r)=>{const o=r[0],i=r[1],c=s?AbortSignal.timeout(s):void 0;let d={...i,signal:c,headers:{...i?.headers,...a}};t.requestMiddleware&&(d=await t.requestMiddleware(d)),_.ENABLE_RPC_CONSISTENCY&&_.hasWriteOperationHappened(o)&&_.applyBlockHeight(d,o);const h=await _.fetchAndProcessBlockHeight(o,d,t);if(h.body===null)throw new l(w.RESPONSE_BODY_EMPTY,"The response from the server is missing the body",{timestamp:new Date().toISOString(),request:i,response:h});return h},n)}static applyBlockHeight(t,n){const s=this.normalizeUrl(n),a=_.currentBlockHeightCache[s]??0;t.body=t.body?.toString().replace(/}$/,`,"extensions":{"required_fuel_block_height":${a}}}`)}static async fetchAndProcessBlockHeight(t,n,s){const a=p(()=>s.fetch?s.fetch(t,n,s):fetch(t,n),"fetchFn");_.isWriteOperation(n.body)&&!_.hasWriteOperationHappened(t)&&(_.currentBlockHeightCache[_.normalizeUrl(t)]=0);let o=await a();if(!_.ENABLE_RPC_CONSISTENCY)return o;const i={maxRetries:5,baseDelay:500};for(let c=i.maxRetries;c>0;--c){if(o.body){const{extensions:f}=await $l({response:o,isSubscription:t.endsWith("-sub")});if(_.setCurrentBlockHeight(t,f?.current_fuel_block_height),!f?.fuel_block_height_precondition_failed)break}const d=i.maxRetries-c+1,h=Us(i,d);await hs(h),o=await a()}return o}static setCurrentBlockHeight(t,n){const s=_.hasWriteOperationHappened(t);if(!he(n)||!s)return;const a=_.normalizeUrl(t);n>_.currentBlockHeightCache[a]&&(_.currentBlockHeightCache[a]=n)}constructor(t,n={}){const{url:s,urlWithoutAuth:a,headers:r}=_.extractBasicAuth(t);this.url=s,this.urlWithoutAuth=a,this.url=t;const{FUELS:o}=Zi,i={...r,...n.headers,Source:`ts-sdk-${o}`};this.options={...this.options,...n,headers:i},this.operations=this.createOperations();const{resourceCacheTTL:c,cache:d}=this.options;if(d){const{consensusParametersTimestamp:h,chain:f,nodeInfo:b}=gl(d);this.consensusParametersTimestamp=h,_.chainInfoCache[this.urlWithoutAuth]=f,_.nodeInfoCache[this.urlWithoutAuth]=b}he(c)?c!==-1?this.cache=new va(c):this.cache=void 0:this.cache=new va(ql)}static extractBasicAuth(t){let n;try{n=new URL(t)}catch(o){throw new l(l.CODES.INVALID_URL,"Invalid URL provided.",{url:t},o)}const s=n.username,a=n.password,r=`${n.origin}${n.pathname}`;return s&&a?{url:t,urlWithoutAuth:r,headers:{Authorization:`Basic ${btoa(`${s}:${a}`)}`}}:{url:t,urlWithoutAuth:t,headers:void 0}}async init(){return await this.fetchChainAndNodeInfo(),this}async getChain(){return await this.init(),_.chainInfoCache[this.urlWithoutAuth]}async getNode(){return await this.init(),_.nodeInfoCache[this.urlWithoutAuth]}async getGasConfig(){await this.init();const{txParameters:{maxGasPerTx:t},predicateParameters:{maxGasPerPredicate:n},feeParameters:{gasPriceFactor:s,gasPerByte:a},gasCosts:r}=(await this.getChain()).consensusParameters;return{maxGasPerTx:t,maxGasPerPredicate:n,gasPriceFactor:s,gasPerByte:a,gasCosts:r}}async connect(t,n){const{url:s,urlWithoutAuth:a,headers:r}=_.extractBasicAuth(t);this.url=s,this.urlWithoutAuth=a,this.options=n??this.options,this.options={...this.options,headers:{...this.options.headers,...r}},this.operations=this.createOperations(),await this.init()}async fetchChainAndNodeInfo(t=!1){const n=_.nodeInfoCache[this.urlWithoutAuth],s=_.chainInfoCache[this.urlWithoutAuth];if(n&&s&&!t)return{nodeInfo:n,chain:s};const r=_.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth];if(r)return r.then(i=>(this.consensusParametersTimestamp=i.consensusParametersTimestamp,{nodeInfo:_.nodeInfoCache[this.urlWithoutAuth],chain:_.chainInfoCache[this.urlWithoutAuth]}));const o=this.operations.getChainAndNodeInfo().then(i=>({chain:es(i.chain),nodeInfo:ts(i.nodeInfo),consensusParametersTimestamp:Date.now()})).then(i=>(_.setIncompatibleNodeVersionMessage(i.nodeInfo),_.chainInfoCache[this.urlWithoutAuth]=i.chain,_.nodeInfoCache[this.urlWithoutAuth]=i.nodeInfo,this.consensusParametersTimestamp=i.consensusParametersTimestamp,i)).catch(i=>{const c=new l(l.CODES.CONNECTION_REFUSED,"Unable to fetch chain and node info from the network",{url:this.urlWithoutAuth},i);throw c.cause={code:"ECONNREFUSED"},c}).finally(()=>{delete _.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth]});return _.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth]=o,_.inflightFetchChainAndNodeInfoRequests[this.urlWithoutAuth].then(i=>(this.consensusParametersTimestamp=i.consensusParametersTimestamp,{nodeInfo:_.nodeInfoCache[this.urlWithoutAuth],chain:_.chainInfoCache[this.urlWithoutAuth]}))}static setIncompatibleNodeVersionMessage(t){const{isMajorSupported:n,isMinorSupported:s,supportedVersion:a}=Qi(t.nodeVersion);(!n||!s)&&(_.incompatibleNodeVersionMessage=[`The Fuel Node that you are trying to connect to is using fuel-core version ${t.nodeVersion}.`,`The TS SDK currently supports fuel-core version ${a}.`,"Things may not work as expected."].join(`
`),Qn.incompatibleNodeVersionMessage=_.incompatibleNodeVersionMessage)}createOperations(){const t=_.getFetchFn(this.options),n=new ec(this.urlWithoutAuth,{fetch:p((r,o)=>t(r.toString(),o||{},this.options),"fetch"),responseMiddleware:p(r=>{if("response"in r){const o=r.response;oo(o.errors,_.incompatibleNodeVersionMessage)}},"responseMiddleware")}),s=p((r,o)=>{const i=r.definitions.find(d=>d.kind==="OperationDefinition");return i?.operation==="subscription"?Qn.create({url:this.urlWithoutAuth,query:r,fetchFn:p((d,h)=>t(d,h,this.options),"fetchFn"),variables:o,operationName:i.name.value,onEvent:p(d=>{_.setCurrentBlockHeight(this.urlWithoutAuth,d.extensions?.current_fuel_block_height)},"onEvent")}):n.request(r,o)},"executeQuery"),a=p(r=>({getBlobs(o){const i=o.blobIds.map((f,b)=>`$blobId${b}: BlobId!`).join(", "),c=o.blobIds.map((f,b)=>`blob${b}: blob(id: $blobId${b}) { id }`).join(`
`),d=o.blobIds.reduce((f,b,g)=>(f[`blobId${g}`]=b,f),{}),h=x`
          query getBlobs(${i}) {
            ${c}
          }
        `;return r(h,d)}}),"customOperations");return{...ro(s),...a(s)}}async getVersion(){const{nodeInfo:{nodeVersion:t}}=await this.operations.getVersion();return t}async getBlockNumber(){const{chain:{latestBlock:{height:t}}}=await this.operations.getLatestBlockHeight();return u(t)}async fetchNode(){const{nodeInfo:t}=await this.operations.getNodeInfo(),n=ts(t);return _.nodeInfoCache[this.urlWithoutAuth]=n,n}async fetchChain(){const{chain:t}=await this.operations.getChain(),n=es(t);return _.chainInfoCache[this.urlWithoutAuth]=n,n}async getChainId(){const{consensusParameters:{chainId:t}}=await this.getChain();return t.toNumber()}async getBaseAssetId(){const t=await this.getChain(),{consensusParameters:{baseAssetId:n}}=t;return n}async getAssetDetails(t){const{assetMetadata:n}=await this.getNodeFeatures();if(!n)throw new l(w.UNSUPPORTED_FEATURE,"The current node does not supports fetching asset details");const{assetDetails:s}=await this.operations.getAssetDetails({assetId:t}),{contractId:a,subId:r,totalSupply:o}=s;return{subId:r,contractId:a,totalSupply:u(o)}}#e(t,n){this.cache&&this.cache.set(n,t)}async validateTransaction(t){const{consensusParameters:{txParameters:{maxInputs:n,maxOutputs:s}}}=await this.getChain();if(u(t.inputs.length).gt(n))throw new l(w.MAX_INPUTS_EXCEEDED,`The transaction exceeds the maximum allowed number of inputs. Tx inputs: ${t.inputs.length}, max inputs: ${n}`);if(u(t.outputs.length).gt(s))throw new l(w.MAX_OUTPUTS_EXCEEDED,`The transaction exceeds the maximum allowed number of outputs. Tx outputs: ${t.outputs.length}, max outputs: ${s}`)}async sendTransaction(t,{enableAssetBurn:n,estimateTxDependencies:s=!0,includePreConfirmation:a=!0}={}){const r=oe(t);wo(await this.getBaseAssetId(),r,n),s&&await this.estimateTxDependencies(r),await this.validateTransaction(r);const o=S(r.toTransactionBytes());let i;He(r)&&(i=r.abis);const c=await this.operations.submitAndAwaitStatus({encodedTransaction:o,includePreConfirmation:!0});this.#e(r.inputs,r.getTransactionId(await this.getChainId()));const d=await this.getChainId();return new Ra({transactionRequestOrId:r,provider:this,chainId:d,abis:i,submitAndAwaitSubscription:c})}async dryRun(t,{utxoValidation:n,estimateTxDependencies:s=!0}={}){const a=oe(t);if(s)return this.estimateTxDependencies(a);const r=S(a.toTransactionBytes()),{dryRun:o}=await this.operations.dryRun({encodedTransactions:r,utxoValidation:n||!1}),[{receipts:i,status:c}]=o;return{receipts:i.map(ce),dryRunStatus:c}}async estimatePredicates(t){if(!t.inputs.some(o=>ba(o)&&u(o.predicateGasUsed).isZero()))return t;const s=S(t.toTransactionBytes()),a=await this.operations.estimatePredicates({encodedTransaction:s}),{estimatePredicates:r}=a;return t=this.parseEstimatePredicatesResponse(t,r),t}async estimatePredicatesAndGasPrice(t,n){if(!t.inputs.some(o=>ba(o)&&u(o.predicateGasUsed).isZero())){const o=await this.estimateGasPrice(n);return{transactionRequest:t,gasPrice:o}}const{estimateGasPrice:{gasPrice:a},estimatePredicates:r}=await this.operations.estimatePredicatesAndGasPrice({blockHorizon:String(n),encodedTransaction:S(t.toTransactionBytes())});return t=this.parseEstimatePredicatesResponse(t,r),{transactionRequest:t,gasPrice:u(a)}}async estimateTxDependencies(t,{gasPrice:n}={}){if(Fl(t))return{rawReceipts:[],receipts:[],outputVariables:0,missingContractIds:[]};let s=[],a=[];const r=[];let o=0,i;await this.validateTransaction(t);const c=n??await this.estimateGasPrice(10);for(let d=0;d<xa;d++){const{dryRun:[{receipts:h,status:f}]}=await this.operations.dryRun({encodedTransactions:[S(t.toTransactionBytes())],utxoValidation:!1,gasPrice:c.toString()});s=h,a=h.map(ce),i=f;const{missingOutputVariables:b,missingOutputContractIds:g}=wa(a);if((b.length!==0||g.length!==0)&&He(t)){o+=b.length,t.addVariableOutputs(b.length),g.forEach(({contractId:y})=>{t.addContractInputAndOutput(new G(y)),r.push(y)});const{maxFee:m}=await this.estimateTxGasAndFee({transactionRequest:t,gasPrice:c});t.maxFee=m}else break}return{rawReceipts:s,receipts:a,outputVariables:o,missingContractIds:r,dryRunStatus:i}}async estimateMultipleTxDependencies(t){const n=t.map(()=>({rawReceipts:[],receipts:[],outputVariables:0,missingContractIds:[],dryRunStatus:void 0})),s=ne(t),a=new Map;s.forEach((i,c)=>{He(i)&&a.set(c,S(i.toTransactionBytes()))});let r=Array.from(a.keys()),o=0;for(;r.length>0&&o<xa;){const i=r.map(h=>a.get(h)),c=await this.operations.dryRun({encodedTransactions:i,utxoValidation:!1}),d=[];for(let h=0;h<c.dryRun.length;h++){const f=r[h],{receipts:b,status:g}=c.dryRun[h],I=n[f];I.receipts=b.map(ce),I.dryRunStatus=g;const{missingOutputVariables:m,missingOutputContractIds:y}=wa(I.receipts),C=m.length>0||y.length>0,T=s[f];if(C&&He(T)){I.outputVariables+=m.length,T.addVariableOutputs(m.length),y.forEach(({contractId:R})=>{T.addContractInputAndOutput(new G(R)),I.missingContractIds.push(R)});const{maxFee:A}=await this.estimateTxGasAndFee({transactionRequest:T});T.maxFee=A,a.set(f,S(T.toTransactionBytes())),d.push(f)}}r=d,o+=1}return n}async dryRunMultipleTransactions(t,{utxoValidation:n,estimateTxDependencies:s=!0}={}){if(s)return this.estimateMultipleTxDependencies(t);const a=t.map(i=>S(i.toTransactionBytes())),{dryRun:r}=await this.operations.dryRun({encodedTransactions:a,utxoValidation:n||!1});return r.map(({receipts:i,status:c})=>({receipts:i.map(ce),dryRunStatus:c}))}async autoRefetchConfigs(){if(Date.now()-(this.consensusParametersTimestamp??0)<6e4)return;if(!_.chainInfoCache?.[this.urlWithoutAuth]){await this.fetchChainAndNodeInfo(!0);return}const s=_.chainInfoCache[this.urlWithoutAuth],{latestBlock:{header:{consensusParametersVersion:a}}}=s,{chain:{latestBlock:{header:{consensusParametersVersion:r}}}}=await this.operations.getConsensusParametersVersion();a!==r&&await this.fetchChainAndNodeInfo(!0)}async estimateTxGasAndFee(t){const{transactionRequest:n,gasPrice:s}=t;let a=s;await this.autoRefetchConfigs();const r=await this.getChain(),{gasPriceFactor:o,maxGasPerTx:i}=await this.getGasConfig(),c=n.calculateMinGas(r);he(a)||(a=await this.estimateGasPrice(10));const d=Ve({gasPrice:u(a),gas:c,priceFactor:o,tip:n.tip}).add(1);let h=u(0);He(n)&&(h=n.gasLimit,n.gasLimit.eq(0)&&(n.gasLimit=c,n.gasLimit=i.sub(n.calculateMaxGas(r,c)),h=n.gasLimit));const f=n.calculateMaxGas(r,c),b=Ve({gasPrice:u(a),gas:f,priceFactor:o,tip:n.tip}).add(1);return{minGas:c,minFee:d,maxGas:f,maxFee:b,gasPrice:a,gasLimit:h}}async simulate(t,{estimateTxDependencies:n=!0}={}){const s=oe(t);if(n)return this.estimateTxDependencies(s);const a=[S(s.toTransactionBytes())],{dryRun:r}=await this.operations.dryRun({encodedTransactions:a,utxoValidation:!0});return{receipts:r.map(i=>{const{id:c,receipts:d,status:h}=i,f=d.map(ce);return{id:c,receipts:f,status:h}})[0].receipts}}async getTransactionCost(t,{signatureCallback:n,gasPrice:s}={}){const a=ne(oe(t)),r=a.maxFee.eq(0),o=He(a);o&&(a.gasLimit=u(0));const i=ne(a);let c=0;if(n&&He(i)){const E=i.witnesses.length;await n(i),c=i.witnesses.length-E}let d;s?(d=s,await this.estimatePredicates(i)):{gasPrice:d}=await this.estimatePredicatesAndGasPrice(i,10),a.updatePredicateGasUsed(i.inputs);let{maxFee:h,maxGas:f,minFee:b,minGas:g,gasLimit:I}=await this.estimateTxGasAndFee({transactionRequest:i,gasPrice:d}),m=[],y=[],C,T=[],A=0,R=u(0);if(a.maxFee=h,o){if(a.gasLimit=I,n&&await n(a),{rawReceipts:m,receipts:y,missingContractIds:T,outputVariables:A,dryRunStatus:C}=await this.estimateTxDependencies(a,{gasPrice:d}),C&&"reason"in C)throw this.extractDryRunError(a,y,C.reason);const{maxGasPerTx:E}=await this.getGasConfig(),W=St(y);R=u(W.muln(Hl)).max(E.sub(g)),a.gasLimit=R,{maxFee:h,maxGas:f,minFee:b,minGas:g}=await this.estimateTxGasAndFee({transactionRequest:a,gasPrice:d})}const M={gasPrice:d.toString(),receipts:m};return{rawReceipts:m,receipts:y,gasUsed:R,gasPrice:d,minGas:g,maxGas:f,minFee:b,maxFee:h,outputVariables:A,missingContractIds:T,addedSignatures:c,estimatedPredicates:a.inputs,dryRunStatus:C,updateMaxFee:r,transactionSummary:M}}async assembleTx(t){const{request:n,reserveGas:s,resourcesIdsToIgnore:a,feePayerAccount:r,blockHorizon:o=10,estimatePredicates:i=!0,accountCoinQuantities:c=[]}=t,d=new Set,h=await this.getBaseAssetId();let f=-1,b;const g=c.map((R,M)=>{const{amount:E,assetId:W,account:D=r,changeOutputAccount:Y}=R,ee=Y?Y.address.toB256():D.address.toB256();d.add(D.address.toB256());const Ie={change:ee};return W===h&&(b=Ie.change),D.address.equals(r.address)&&(f=M),{account:fa(D),amount:u(E).toString(10),assetId:W,changePolicy:Ie}});f===-1&&(d.add(r.address.toB256()),f=g.push({account:fa(r),amount:u(0).toString(10),assetId:h,changePolicy:{change:b||r.address.toB256()}})-1);const I=await this.adjustResourcesToIgnoreForAddresses(Array.from(d),a),{assembleTx:{status:m,transaction:y,gasPrice:C}}=await this.operations.assembleTx({tx:S(n.toTransactionBytes()),blockHorizon:String(o),feeAddressIndex:String(f),requiredBalances:g,estimatePredicates:i,excludeInput:I,reserveGas:s?u(s).toString(10):void 0});if(m.type==="DryRunFailureStatus"){const R=m.receipts.map(ce);throw this.extractDryRunError(n,R,m.reason)}n.witnesses=y.witnesses||n.witnesses,n.inputs=y.inputs?.map(wl)||n.inputs,n.outputs=y.outputs?.map(bl)||n.outputs,y.policies?.maxFee&&(n.maxFee=u(y.policies.maxFee)),n.type===j.Script&&(n.gasLimit=u(y.scriptGasLimit).add(u(s)));const T=m.receipts,A=await this.getChainId();return n.updateState(A,"funded",{gasPrice:C.toString(),receipts:T}),{assembledRequest:n,gasPrice:u(C),receipts:m.receipts.map(ce),rawReceipts:T}}async getCoins(t,n,s){const a=new G(t),{coins:{edges:r,pageInfo:o}}=await this.operations.getCoins({...lt({paginationLimit:Aa,inputArgs:s}),filter:{owner:a.toB256(),assetId:n&&S(n)}});return{coins:r.map(({node:c})=>({id:c.utxoId,assetId:c.assetId,amount:u(c.amount),owner:a,blockCreated:u(c.blockCreated),txCreatedIdx:u(c.txCreatedIdx)})),pageInfo:o}}async getResourcesToSpend(t,n,s){const a=new G(t),r=await this.adjustResourcesToIgnoreForAddresses([a.b256Address],s),o={owner:a.toB256(),queryPerAsset:n.map(vs).map(({assetId:d,amount:h,max:f})=>({assetId:S(d),amount:(h.eqn(0)?u(1):h).toString(10),max:f?f.toString(10):void 0})),excludedIds:r};return(await this.operations.getCoinsToSpend(o)).coinsToSpend.flat().map(d=>{switch(d.type){case"MessageCoin":return{amount:u(d.amount),assetId:d.assetId,daHeight:u(d.daHeight),sender:new G(d.sender),recipient:new G(d.recipient),nonce:d.nonce};case"Coin":return{id:d.utxoId,amount:u(d.amount),assetId:d.assetId,owner:a,blockCreated:u(d.blockCreated),txCreatedIdx:u(d.txCreatedIdx)};default:return null}}).filter(d=>!!d)}async getBlobs(t){const n=await this.operations.getBlobs({blobIds:t}),s=[];return Object.keys(n).forEach(a=>{const r=n[a];s.push(r?.id??null)}),s.filter(a=>a)}async getBlock(t){let n;if(t==="latest"){const{chain:{latestBlock:i}}=await this.operations.getLatestBlock();n=i}else{const c=typeof t=="string"&&tt(t)?{blockId:t}:{height:u(t).toString(10)};n=(await this.operations.getBlock(c)).block}if(!n)return null;const{header:s,height:a,id:r,transactions:o}=n;return{id:r,height:u(a),time:s.time,header:{applicationHash:s.applicationHash,daHeight:u(s.daHeight),eventInboxRoot:s.eventInboxRoot,messageOutboxRoot:s.messageOutboxRoot,prevRoot:s.prevRoot,stateTransitionBytecodeVersion:s.stateTransitionBytecodeVersion,transactionsCount:s.transactionsCount,transactionsRoot:s.transactionsRoot},transactionIds:o.map(i=>i.id)}}async getBlocks(t){const{blocks:{edges:n,pageInfo:s}}=await this.operations.getBlocks({...lt({paginationLimit:Vl,inputArgs:t})});return{blocks:n.map(({node:r})=>({id:r.id,height:u(r.height),time:r.header.time,header:{applicationHash:r.header.applicationHash,daHeight:u(r.header.daHeight),eventInboxRoot:r.header.eventInboxRoot,messageOutboxRoot:r.header.messageOutboxRoot,prevRoot:r.header.prevRoot,stateTransitionBytecodeVersion:r.header.stateTransitionBytecodeVersion,transactionsCount:r.header.transactionsCount,transactionsRoot:r.header.transactionsRoot},transactionIds:r.transactions.map(o=>o.id)})),pageInfo:s}}async getBlockWithTransactions(t){let n;typeof t=="number"?n={blockHeight:u(t).toString(10)}:t==="latest"?n={blockHeight:(await this.getBlockNumber()).toString()}:typeof t=="string"&&tt(t)?n={blockId:t}:n={blockHeight:u(t).toString()};const{block:s}=await this.operations.getBlockWithTransactions(n);return s?{id:s.id,height:u(s.height,10),time:s.header.time,header:{applicationHash:s.header.applicationHash,daHeight:u(s.header.daHeight),eventInboxRoot:s.header.eventInboxRoot,messageOutboxRoot:s.header.messageOutboxRoot,prevRoot:s.header.prevRoot,stateTransitionBytecodeVersion:s.header.stateTransitionBytecodeVersion,transactionsCount:s.header.transactionsCount,transactionsRoot:s.header.transactionsRoot},transactionIds:s.transactions.map(a=>a.id),transactions:s.transactions.map(a=>new ve().decode(v(a.rawPayload),0)?.[0])}:null}async getTransaction(t){const{transaction:n}=await this.operations.getTransaction({transactionId:t});if(!n)return null;try{return new ve().decode(v(n.rawPayload),0)?.[0]}catch(s){if(s instanceof l&&s.code===w.UNSUPPORTED_TRANSACTION_TYPE)return console.warn("Unsupported transaction type encountered"),null;throw s}}async getTransactions(t){const{transactions:{edges:n,pageInfo:s}}=await this.operations.getTransactions({...lt({inputArgs:t,paginationLimit:si})}),a=new ve;return{transactions:n.map(({node:{rawPayload:o}})=>{try{return a.decode(v(o),0)[0]}catch(i){if(i instanceof l&&i.code===w.UNSUPPORTED_TRANSACTION_TYPE)return console.warn("Unsupported transaction type encountered"),null;throw i}}).filter(o=>o!==null),pageInfo:s}}async daCompressedBlock(t){const{daCompressedBlock:n}=await this.operations.daCompressedBlock({height:t});return n||null}async getContract(t){const{contract:n}=await this.operations.getContract({contractId:t});return n||null}async getContractBalance(t,n){const{contractBalance:s}=await this.operations.getContractBalance({contract:new G(t).toB256(),asset:S(n)});return u(s.amount,10)}async getBalance(t,n){const{balance:s}=await this.operations.getBalanceV2({owner:new G(t).toB256(),assetId:S(n)});return u(s.amountU128,10)}async getBalances(t,n){let s={first:Wl};const{balancesPagination:a}=await this.getNodeFeatures();a&&(s=lt({inputArgs:n,paginationLimit:zl}));const{balances:{edges:r,pageInfo:o}}=await this.operations.getBalancesV2({...s,filter:{owner:new G(t).toB256()},supportsPagination:a});return{balances:r.map(({node:c})=>({assetId:c.assetId,amount:u(c.amountU128)})),...a?{pageInfo:o}:{}}}async getMessages(t,n){const{messages:{edges:s,pageInfo:a}}=await this.operations.getMessages({...lt({inputArgs:n,paginationLimit:Aa}),owner:new G(t).toB256()});return{messages:s.map(({node:o})=>({messageId:Qe.getMessageId({sender:o.sender,recipient:o.recipient,nonce:o.nonce,amount:u(o.amount),data:o.data}),sender:new G(o.sender),recipient:new G(o.recipient),nonce:o.nonce,amount:u(o.amount),data:Qe.decodeData(o.data),daHeight:u(o.daHeight)})),pageInfo:a}}async getMessageProof(t,n,s,a){let r={transactionId:t,nonce:n};if(s&&a)throw new l(w.INVALID_INPUT_PARAMETERS,"commitBlockId and commitBlockHeight cannot be used together");s&&(r={...r,commitBlockId:s}),a&&(r={...r,commitBlockHeight:a.toNumber().toString()});const o=await this.operations.getMessageProof(r),{messageProof:i,messageBlockHeader:c,commitBlockHeader:d,blockProof:h,sender:f,recipient:b,amount:g,data:I}=o.messageProof;return{messageProof:{proofIndex:u(i.proofIndex),proofSet:i.proofSet},blockProof:{proofIndex:u(h.proofIndex),proofSet:h.proofSet},messageBlockHeader:{id:c.id,daHeight:u(c.daHeight),transactionsCount:Number(c.transactionsCount),transactionsRoot:c.transactionsRoot,height:u(c.height),prevRoot:c.prevRoot,time:c.time,applicationHash:c.applicationHash,messageReceiptCount:Number(c.messageReceiptCount),messageOutboxRoot:c.messageOutboxRoot,consensusParametersVersion:Number(c.consensusParametersVersion),eventInboxRoot:c.eventInboxRoot,stateTransitionBytecodeVersion:Number(c.stateTransitionBytecodeVersion)},commitBlockHeader:{id:d.id,daHeight:u(d.daHeight),transactionsCount:Number(d.transactionsCount),transactionsRoot:d.transactionsRoot,height:u(d.height),prevRoot:d.prevRoot,time:d.time,applicationHash:d.applicationHash,messageReceiptCount:Number(d.messageReceiptCount),messageOutboxRoot:d.messageOutboxRoot,consensusParametersVersion:Number(d.consensusParametersVersion),eventInboxRoot:d.eventInboxRoot,stateTransitionBytecodeVersion:Number(d.stateTransitionBytecodeVersion)},sender:new G(f),recipient:new G(b),nonce:n,amount:u(g),data:I}}async getLatestGasPrice(){const{latestGasPrice:t}=await this.operations.getLatestGasPrice();return u(t.gasPrice)}async estimateGasPrice(t){const{estimateGasPrice:n}=await this.operations.estimateGasPrice({blockHorizon:String(t)});return u(n.gasPrice)}async getMessageStatus(t){return(await this.operations.getMessageStatus({nonce:t})).messageStatus}async produceBlocks(t,n){const{produceBlocks:s}=await this.operations.produceBlocks({blocksToProduce:u(t).toString(10),startTimestamp:n?nr.fromUnixMilliseconds(n).toTai64():void 0});return u(s)}async isUserAccount(t){return await this.getAddressType(t)==="Account"}async getAddressType(t){const{contract:n,blob:s,transaction:a}=await this.operations.isUserAccount({blobId:t,contractId:t,transactionId:t});if(n)return"Contract";if(s)return"Blob";if(a)return"Transaction";try{if(await this.getAssetDetails(t))return"Asset"}catch{}return"Account"}async getTransactionResponse(t){const n=await this.getChainId();return new Ra({transactionRequestOrId:t,provider:this,chainId:n})}async getMessageByNonce(t){const{message:n}=await this.operations.getMessageByNonce({nonce:t});return n?{messageId:Qe.getMessageId({sender:n.sender,recipient:n.recipient,nonce:t,amount:u(n.amount),data:n.data}),sender:new G(n.sender),recipient:new G(n.recipient),nonce:t,amount:u(n.amount),data:Qe.decodeData(n.data),daHeight:u(n.daHeight)}:null}async getRelayedTransactionStatus(t){const{relayedTransactionStatus:n}=await this.operations.getRelayedTransactionStatus({relayedTransactionId:t});return n||null}extractDryRunError(t,n,s){let a=[],r={},o;return t.type===j.Script&&t.abis&&({logs:a,groupedLogs:r}=Mt({receipts:n,mainAbi:t.abis.main,externalAbis:t.abis.otherContractsAbis}),o=t.abis),Os({logs:a,groupedLogs:r,receipts:n,statusReason:s,abis:o})}async getNodeFeatures(){const{indexation:t}=await this.getNode();return{assetMetadata:!!t?.assetMetadata,balancesPagination:!!t?.balances,coinsToSpend:!!t?.coinsToSpend}}parseEstimatePredicatesResponse(t,{inputs:n}){return n&&n.forEach((s,a)=>{s&&"predicateGasUsed"in s&&u(s.predicateGasUsed).gt(0)&&(t.inputs[a].predicateGasUsed=s.predicateGasUsed)}),t}async adjustResourcesToIgnoreForAddresses(t,n){const s={messages:n?.messages?.map(a=>S(a))||[],utxos:n?.utxos?.map(a=>S(a))||[]};if(this.cache){const a=this.cache,r=t.map(c=>a.getActiveData(c)),{consensusParameters:{txParameters:{maxInputs:o}}}=await this.getChain(),i=o.toNumber();for(let c=0;c<r.length;c++){let d=s.utxos.length+s.messages.length;if(d>=i||(s.utxos=[...s.utxos,...r[c].utxos.slice(0,i-d)],d=s.utxos.length+s.messages.length,d>=i))break;s.messages=[...s.messages,...r[c].messages.slice(0,i-d)]}}return s}};async function Kl(e){const{id:t,provider:n,abiMap:s}=e,{transaction:a}=await n.operations.getTransactionWithReceipts({transactionId:t});if(!a)throw new l(w.TRANSACTION_NOT_FOUND,`Transaction not found for given id: ${t}.`);const[r]=new ve().decode(v(a.rawPayload),0);let o=[];a?.status&&"receipts"in a.status&&(o=a.status.receipts);const i=o.map(ce),{consensusParameters:{feeParameters:{gasPerByte:c,gasPriceFactor:d},txParameters:{maxInputs:h,maxGasPerTx:f},gasCosts:b}}=await n.getChain(),I=ei(a.status)?u(0):await n.getLatestGasPrice(),m=await n.getBaseAssetId();return{...zt({id:a.id,receipts:i,transaction:r,transactionBytes:v(a.rawPayload),gqlTransactionStatus:a.status,gasPerByte:u(c),gasPriceFactor:u(d),abiMap:s,maxInputs:h,gasCosts:b,maxGasPerTx:f,gasPrice:I,baseAssetId:m})}}p(Kl,"getTransactionSummary");async function Jl(e){const{provider:t,transactionRequest:n,abiMap:s}=e,{receipts:a}=await t.dryRun(n),{gasPerByte:r,gasPriceFactor:o,gasCosts:i,maxGasPerTx:c}=await t.getGasConfig(),d=(await t.getChain()).consensusParameters.txParameters.maxInputs,h=n.toTransaction(),f=n.toTransactionBytes(),b=await t.getLatestGasPrice(),g=await t.getBaseAssetId();return zt({id:n.getTransactionId(await t.getChainId()),receipts:a,transaction:h,transactionBytes:f,abiMap:s,gasPerByte:r,gasPriceFactor:o,maxInputs:d,gasCosts:i,maxGasPerTx:c,gasPrice:b,baseAssetId:g})}p(Jl,"getTransactionSummaryFromRequest");async function Yl(e){const{filters:t,provider:n,abiMap:s}=e,{owner:a,...r}=t,o=lt({inputArgs:r,paginationLimit:si}),{transactionsByOwner:i}=await n.operations.getTransactionsByOwner({...o,owner:a}),{edges:c,pageInfo:d}=i,{consensusParameters:{feeParameters:{gasPerByte:h,gasPriceFactor:f},txParameters:{maxInputs:b,maxGasPerTx:g},gasCosts:I}}=await n.getChain(),m=await n.getLatestGasPrice(),y=await n.getBaseAssetId();return{transactions:c.map(T=>{const{node:A}=T,{id:R,rawPayload:M,status:E}=A,[W]=new ve().decode(v(M),0);let D=[];A?.status&&"receipts"in A.status&&(D=A.status.receipts);const Y=D.map(ce);return{...zt({id:R,receipts:Y,transaction:W,transactionBytes:v(M),gqlTransactionStatus:E,abiMap:s,gasPerByte:h,gasPriceFactor:f,maxInputs:b,gasCosts:I,maxGasPerTx:g,gasPrice:m,baseAssetId:y})}}),pageInfo:d}}p(Yl,"getTransactionsSummaries");var Xl=class{static{p(this,"AbstractAccount")}},Zl=[w.MAX_COINS_REACHED],os=p(async e=>{const{error:t,account:n,skipAutoConsolidation:s=!1}=e;if(s)return!1;const a=l.parse(t);if(Zl.includes(a.code)){const{assetId:r,owner:o}=a.metadata;return n.startConsolidation({owner:o,assetId:r})}return!1},"consolidateCoinsIfRequired"),kn=p(async(e,t)=>{const n=[];let s=!0,a;for(;s;){const{coins:r,pageInfo:o}=await e.getCoins(t,{after:a});n.push(...r),a=r.pop()?.id,s=o.hasNextPage}return{coins:n}},"getAllCoins"),Ea=p(({coins:e})=>e.sort((t,n)=>n.amount.cmp(t.amount)),"sortCoins"),Ql=p(e=>{const{transactionId:t,outputs:n,baseAssetId:s}=e,a=n.findIndex(i=>i.type===k.Change&&i.assetId===s);if(a===-1)throw new l(w.UNKNOWN,"No change output found");const r=n[a],o=Number(a).toString().padStart(4,"0");return{id:`${t}${o}`,assetId:r.assetId,amount:r.amount,owner:new G(r.to),blockCreated:u(0),txCreatedIdx:u(0)}},"createOuputCoin"),eh=p(async({account:e,assetId:t})=>{const n=await e.provider.getChain(),s=n.consensusParameters.chainId.toNumber(),a=await e.provider.estimateGasPrice(10),r=n.consensusParameters.txParameters.maxInputs.toNumber(),o=await e.provider.getBaseAssetId(),i=t===o,c=r,d=r;let h=[],f=[];if(i){const m=await kn(e,o).then(Ea);h=m.slice(0,d),f=m.slice(d)}else h=await kn(e,o).then(Ea).then(m=>m.slice(0,d)),f=await kn(e,t).then(({coins:m})=>m);if(h.length===0)throw new l(w.INSUFFICIENT_FUNDS,`Insufficient funds to consolidate.
	Asset ID: ${o}
	Owner: ${e.address.toB256()}`);const g=[...Ys(c,h),...Ys(c-1,f)].map(m=>{const y=new Ae({scriptData:"0x"});return y.addResources(m),y}),I=p(async(m={})=>{const y=[];let C;for(let T=0;T<g.length;T++){let A=g[T];const R=T+1;if(C){const D=Ql({transactionId:C.transactionId,outputs:C.outputs,baseAssetId:o});A.addResource(D)}"populateTransactionPredicateData"in e&&typeof e.populateTransactionPredicateData=="function"&&(A=e.populateTransactionPredicateData(A),A=await e.provider.estimatePredicates(A));const M=Ve({gasPrice:a,gas:A.calculateMinGas(n),priceFactor:n.consensusParameters.feeParameters.gasPriceFactor,tip:A.tip});A.maxFee=M,A.gasLimit=u(1e3),m.onTransactionStart?.({tx:A,step:R,assetId:t,transactionId:A.getTransactionId(s)});const E=await e.sendTransaction(A),W=await E.waitForResult();y.push(W),C={transactionId:E.id,outputs:W.transaction.outputs}}return{txResponses:y,errors:[]}},"submitAll");return{txs:g,totalFeeCost:g.reduce((m,y)=>m.add(y.maxFee),u(0)),submitAll:I}},"consolidateCoins"),th=p(e=>{const t=new O("u64");return e.reduce((n,s)=>{const{assetId:a,amount:r,contractId:o}=s,i=t.encode(r),c=B([new G(o).toBytes(),i,v(a)]);return B([n,c])},new Uint8Array)},"formatTransferToContractScriptData"),nh=p(async e=>{const t=th(e);await Ya();let n=new Uint8Array;return e.forEach((s,a)=>{const r=(Yn+V+on)*a;n=B([n,tc(16,0,sc.ScriptData).to_bytes(),ke(17,16,r).to_bytes(),ke(18,17,Yn).to_bytes(),nn(19,18,0).to_bytes(),ke(20,18,V).to_bytes(),nc(17,19,20).to_bytes()])}),n=B([n,Xa(1).to_bytes()]),{script:n,scriptData:t}},"assembleTransferToContractScript"),Oa=p((e,t)=>{const n=Math.ceil(e.length/t),s=[];for(let a=0;a<n;a+=1){const r=a*t,o=(a+1)*t;s.push(e.slice(r,o))}return s},"splitCoinsIntoBatches"),sh=5,Dn=class extends Xl{static{p(this,"Account")}address;_provider;_connector;constructor(e,t,n){super(),this._provider=t,this._connector=n,this.address=new G(e)}get provider(){if(!this._provider)throw new l(w.MISSING_PROVIDER,"Provider not set");return this._provider}set provider(e){this._provider=e}connect(e){return this._provider=e,this.provider}async getResourcesToSpend(e,t,{skipAutoConsolidation:n}={}){const s=p(()=>this.provider.getResourcesToSpend(this.address,e,t),"getResourcesToSpend");try{return await s()}catch(a){if(!await os({error:a,account:this,skipAutoConsolidation:n}))throw a;return await s()}}async getCoins(e,t){return this.provider.getCoins(this.address,e,t)}async getMessages(e){return this.provider.getMessages(this.address,e)}async getBalance(e){const t=e??await this.provider.getBaseAssetId();return await this.provider.getBalance(this.address,t)}async getBalances(){return this.provider.getBalances(this.address)}async fund(e,t,{skipAutoConsolidation:n}={}){const{addedSignatures:s,estimatedPredicates:a,requiredQuantities:r,updateMaxFee:o,gasPrice:i,transactionSummary:c}=t,d=await this.provider.getChainId(),h=e.maxFee,f=await this.provider.getBaseAssetId(),b=r.find(R=>R.assetId===f)?.amount||u(0),g=qd({amount:u(h),assetId:f,coinQuantities:r}),I={};g.forEach(({amount:R,assetId:M})=>{I[M]={required:R,owned:u(0)}}),e.inputs.filter(yt).forEach(R=>{const E=Pe(R)?String(R.assetId):f;I[E]&&(I[E].owned=I[E].owned.add(R.amount))});let m=[];Object.entries(I).forEach(([R,{owned:M,required:E}])=>{M.lt(E)&&m.push({assetId:R,amount:E.sub(M)})});let y=m.length>0,C=0;for(;y&&C<sh;){const R=await this.getResourcesToSpend(m,Al(e.inputs,this.address),{skipAutoConsolidation:n});e.addResources(R),e.updatePredicateGasUsed(a);const M=ne(e);if(s&&Array.from({length:s}).forEach(()=>M.addEmptyWitness()),!o){y=!1;break}const{maxFee:E}=await this.provider.estimateTxGasAndFee({transactionRequest:M,gasPrice:i}),W=xl(e.inputs.filter(yt),f,f),D=b.add(E);W.gt(D)?y=!1:m=[{amount:D.sub(W),assetId:f}],C+=1}if(y)throw new l(w.INSUFFICIENT_FUNDS,`The account ${this.address} does not have enough base asset funds to cover the transaction execution.`);e.updateState(d,"funded",c),await this.provider.validateTransaction(e),e.updatePredicateGasUsed(a);const T=ne(e);if(s&&Array.from({length:s}).forEach(()=>T.addEmptyWitness()),!o)return e;const{maxFee:A}=await this.provider.estimateTxGasAndFee({transactionRequest:T,gasPrice:i});return e.maxFee=A,e}async createTransfer(e,t,n,s={},{skipAutoConsolidation:a}={}){let r=new Ae(s);r=this.addTransfer(r,{destination:e,amount:t,assetId:n||await this.provider.getBaseAssetId()});const{gasPrice:o,transactionRequest:i}=await this.assembleTx({transactionRequest:r,skipAutoConsolidation:a});return r=await ft({gasPrice:o,provider:this.provider,transactionRequest:i,setGasLimit:s?.gasLimit,setMaxFee:s?.maxFee}),r}async transfer(e,t,n,s={},{skipAutoConsolidation:a}={}){const r=await this.createTransfer(e,t,n,s,{skipAutoConsolidation:a});return this.sendTransaction(r,{estimateTxDependencies:!1})}async batchTransfer(e,t={},{skipAutoConsolidation:n}={}){let s=new Ae(t);s=this.addBatchTransfer(s,e);const{gasPrice:a,transactionRequest:r}=await this.assembleTx({transactionRequest:s,skipAutoConsolidation:n});return s=await ft({gasPrice:a,provider:this.provider,transactionRequest:r,setGasLimit:t?.gasLimit,setMaxFee:t?.maxFee}),this.sendTransaction(s,{estimateTxDependencies:!1})}addTransfer(e,t){const{destination:n,amount:s,assetId:a}=t;return this.validateTransferAmount(s),e.addCoinOutput(new G(n),s,a),e}addBatchTransfer(e,t){return t.forEach(({destination:n,amount:s,assetId:a})=>{this.addTransfer(e,{destination:n,amount:s,assetId:a})}),e}async transferToContract(e,t,n,s={},{skipAutoConsolidation:a}={}){return this.batchTransferToContracts([{amount:t,assetId:n,contractId:e}],s,{skipAutoConsolidation:a})}async batchTransferToContracts(e,t={},{skipAutoConsolidation:n}={}){let s=new Ae({...t});const a=[],r=await this.provider.getBaseAssetId(),o=e.map(f=>{const b=u(f.amount),g=new G(f.contractId),I=f.assetId?S(f.assetId):r;if(b.lte(0))throw new l(w.INVALID_TRANSFER_AMOUNT,"Transfer amount must be a positive number.");return s.addContractInputAndOutput(g),a.push({amount:b,assetId:I}),{amount:b,contractId:g.toB256(),assetId:I}}),{script:i,scriptData:c}=await nh(o);s.script=i,s.scriptData=c;const{gasPrice:d,transactionRequest:h}=await this.assembleTx({transactionRequest:s,quantities:a,skipAutoConsolidation:n});return s=await ft({gasPrice:d,provider:this.provider,transactionRequest:h,setGasLimit:t?.gasLimit,setMaxFee:t?.maxFee}),this.sendTransaction(s)}async withdrawToBaseLayer(e,t,n={},{skipAutoConsolidation:s}={}){const a=new G(e),r=v("0x".concat(a.toHexString().substring(2).padStart(64,"0"))),o=v("0x".concat(u(t).toHex().substring(2).padStart(16,"0"))),c={script:new Uint8Array([...v(Nl.bytes),...r,...o]),...n},d=await this.provider.getBaseAssetId();let h=new Ae(c);const f=[{amount:u(t),assetId:d}],{gasPrice:b,transactionRequest:g}=await this.assembleTx({transactionRequest:h,quantities:f,skipAutoConsolidation:s});return h=await ft({gasPrice:b,provider:this.provider,transactionRequest:g,setGasLimit:n?.gasLimit,setMaxFee:n?.maxFee}),this.sendTransaction(h)}async startConsolidation(e){if(this._connector)return await this._connector.startConsolidation(e),!1;const{owner:t,assetId:n}=e;if(t!==this.address.toB256())return!1;const{submitAll:s}=await eh({account:this,assetId:n});return await s(),!0}async consolidateCoins(e){const{assetId:t}=e,{coins:n}=await this.getCoins(t),a=await this.provider.getBaseAssetId()===t;let r;const o={assetId:t,coins:n,mode:e.mode,outputNum:e.outputNum};return a?{submitAll:r}=await this.assembleBaseAssetConsolidationTxs(o):{submitAll:r}=await this.assembleNonBaseAssetConsolidationTxs(o),r()}async assembleBaseAssetConsolidationTxs(e){const{coins:t,mode:n="parallel",outputNum:s=1}=e,a=await this.provider.getBaseAssetId();this.validateConsolidationTxsCoins(t,a);const r=await this.provider.getChain(),o=r.consensusParameters.txParameters.maxInputs.toNumber();let i=u(0);const c=[],d=Oa(t,o),h=await this.provider.estimateGasPrice(10),f=s>1;d.filter(g=>g.length>1).forEach(g=>{const I=new Ae({script:"0x"});I.addResources(g),f&&Array.from({length:s-1}).forEach(()=>{I.addCoinOutput(this.address,0,a)});const m=I.calculateMinGas(r),y=Ve({gasPrice:h,gas:m,priceFactor:r.consensusParameters.feeParameters.gasPriceFactor,tip:I.tip});if(I.maxFee=y,f){const T=I.inputs.filter(Pe).reduce((A,R)=>A.add(R.amount),u(0)).div(s+1);I.outputs.forEach(A=>{A.type===k.Coin&&(A.amount=T)})}i=i.add(y),c.push(I)});const b=this.prepareSubmitAll({txs:c,mode:n});return{txs:c,totalFeeCost:i,submitAll:b}}async assembleNonBaseAssetConsolidationTxs(e){const{assetId:t,coins:n,mode:s="parallel",outputNum:a=1}=e;this.validateConsolidationTxsCoins(n,t);const r=await this.provider.getChain(),o=r.consensusParameters.txParameters.maxInputs.toNumber(),i=r.consensusParameters.baseAssetId,{coins:c}=await this.provider.getCoins(this.address,i);let d=u(0);const h=[],f=await this.provider.estimateGasPrice(10),b=a>1,g=Oa(n,o);g.filter(m=>m.length>1).forEach(m=>{const y=new Ae({script:"0x"});y.addResources(m),b&&Array.from({length:a-1}).forEach(()=>{y.addCoinOutput(this.address,0,t)});const C=y.calculateMinGas(r),T=Ve({gasPrice:f,gas:C,priceFactor:r.consensusParameters.feeParameters.gasPriceFactor,tip:y.tip});if(y.maxFee=T,b){const Y=y.inputs.filter(Pe).reduce((ee,Ie)=>ee.add(Ie.amount),u(0)).div(a+1);y.outputs.forEach(ee=>{ee.type===k.Coin&&(ee.amount=Y)})}d=d.add(T);const A=[];let R=u(0);for(;R.lt(T);){const D=c.pop();if(!D)break;A.push(D),R=R.add(D.amount)}const{inputs:M}=y;y.inputs=M.slice(0,o-A.length);const E=m.slice(o-A.length);y.addResources(A);const W=g[g.length-1];W.push(...E),W.length>o&&g.push(W.slice(o)),h.push(y)});const I=this.prepareSubmitAll({txs:h,mode:s});return{txs:h,totalFeeCost:d,submitAll:I}}prepareSubmitAll=p(e=>{const{txs:t,mode:n="sequential"}=e;return async()=>{const s=[],a=[];if(n==="sequential")for(const r of t)try{const i=await(await this.sendTransaction(r)).waitForResult();s.push(i)}catch(o){a.push(o)}else(await Promise.allSettled(t.map(async o=>(await this.sendTransaction(o)).waitForResult()))).forEach(o=>{o.status==="fulfilled"?s.push(o.value):a.push(o.reason)});return{txResponses:s,errors:a}}},"prepareSubmitAll");async getTransactionCost(e,{signatureCallback:t,quantities:n=[],gasPrice:s}={}){const a=ne(oe(e)),r=await this.provider.getBaseAssetId(),o=a.getCoinOutputsQuantities(),i=Zt(o,n),c=[{assetId:r,amount:u("100000000000000000")}],d=p(b=>a.inputs.find(g=>g.type===H.Coin?g.assetId===b:go(g)?r===b:!1),"findAssetInput"),h=p((b,g)=>{const I=d(b),m=g;I&&"amount"in I?I.amount=m:a.addResources(this.generateFakeResources([{amount:g,assetId:b}]))},"updateAssetInput");return Zt(i,c).forEach(({amount:b,assetId:g})=>h(g,b)),{...await this.provider.getTransactionCost(a,{signatureCallback:t,gasPrice:s}),requiredQuantities:i}}async signMessage(e){if(!this._connector)throw new l(w.MISSING_CONNECTOR,"A connector is required to sign messages.");return this._connector.signMessage(this.address.toString(),e)}async signTransaction(e,t={}){if(!this._connector)throw new l(w.MISSING_CONNECTOR,"A connector is required to sign transactions.");const n=oe(e),{transactionRequest:s,connectorsSendTxParams:a}=await this.setTransactionStateForConnectors({transactionRequest:n,connectorOptions:t});return this._connector.signTransaction(this.address.toString(),s,a)}async sendTransaction(e,{estimateTxDependencies:t=!0,...n}={}){const s=oe(e);if(this._connector){const a=await this.setTransactionStateForConnectors({transactionRequest:s,connectorOptions:n}),r=await this._connector.sendTransaction(this.address.toString(),a.transactionRequest,a.connectorsSendTxParams);return typeof r=="string"?this.provider.getTransactionResponse(r):r}return t&&await this.provider.estimateTxDependencies(s),this.provider.sendTransaction(s,{estimateTxDependencies:!1})}async simulateTransaction(e,{estimateTxDependencies:t=!0}={}){const n=oe(e);return t&&await this.provider.estimateTxDependencies(n),this.provider.simulate(n,{estimateTxDependencies:!1})}generateFakeResources(e){return e.map(t=>({id:S(we(rn)),owner:this.address,blockCreated:u(1),txCreatedIdx:u(1),...t}))}async prepareTransactionForSend(e){const{transactionId:t}=e.flag;if(!he(t))return e;const n=await this.provider.getChainId(),s=e.getTransactionId(n);return t!==s&&e.updateState(n),e}async prepareTransactionSummary(e){const t=await this.provider.getChainId();return he(e.flag.summary)?{...e.flag.summary,id:e.getTransactionId(t),transactionBytes:S(e.toTransactionBytes())}:void 0}async assembleTx(e){const{transactionRequest:t,quantities:n=[],skipAutoConsolidation:s}=e,a=t.outputs.filter(o=>o.type===k.Coin).map(({amount:o,assetId:i})=>({assetId:String(i),amount:u(o)}));t.gasLimit=u(0),t.maxFee=u(0);const r=p(async()=>{const{assembledRequest:o,gasPrice:i}=await this.provider.assembleTx({request:t,accountCoinQuantities:Zt(a,n),feePayerAccount:this});return{transactionRequest:o,gasPrice:i}},"assembleTx");try{return await r()}catch(o){if(!await os({error:o,account:this,skipAutoConsolidation:s}))throw o;return await r()}}validateTransferAmount(e){if(u(e).lte(0))throw new l(w.INVALID_TRANSFER_AMOUNT,"Transfer amount must be a positive number.")}validateConsolidationTxsCoins(e,t){if(e.length<=1)throw new l(w.NO_COINS_TO_CONSOLIDATE,"No coins to consolidate.");if(!e.every(n=>n.assetId===t))throw new l(w.COINS_ASSET_ID_MISMATCH,"All coins to consolidate must be from the same asset id.")}async setTransactionStateForConnectors(e){const{transactionRequest:t,connectorOptions:n}=e,{onBeforeSend:s,skipCustomFee:a=!1}=n,r=await this.prepareTransactionForSend(t),o={onBeforeSend:s,skipCustomFee:a,provider:{url:this.provider.url,cache:await yl(this.provider)},transactionState:t.flag.state,transactionSummary:await this.prepareTransactionSummary(t)};return{transactionRequest:r,connectorsSendTxParams:o}}},Lt=class ai{static{p(this,"Signer")}address;publicKey;compressedPublicKey;privateKey;constructor(t){typeof t=="string"&&t.match(/^[0-9a-f]*$/i)&&t.length===64&&(t=`0x${t}`);const n=Se(t,32);this.privateKey=S(n),this.publicKey=S(qe.getPublicKey(n,!1).slice(1)),this.compressedPublicKey=S(qe.getPublicKey(n,!0)),this.address=new G(this.publicKey)}sign(t){const n=qe.sign(v(t),v(this.privateKey)),s=Se(`0x${n.r.toString(16)}`,32),a=Se(`0x${n.s.toString(16)}`,32);return a[0]|=(n.recovery||0)<<7,S(B([s,a]))}addPoint(t){const n=qe.ProjectivePoint.fromHex(v(this.compressedPublicKey)),s=qe.ProjectivePoint.fromHex(v(t));return`0x${n.add(s).toHex(!0)}`}static recoverPublicKey(t,n){const s=v(n),a=s.slice(0,32),r=s.slice(32,64),o=(r[0]&128)>>7;r[0]&=127;const c=new qe.Signature(BigInt(S(a)),BigInt(S(r))).addRecoveryBit(o).recoverPublicKey(v(t)).toRawBytes(!1).slice(1);return S(c)}static recoverAddress(t,n){return new G(ai.recoverPublicKey(t,n))}static generatePrivateKey(t){return t?Te(B([we(32),v(t)])):we(32)}static extendPublicKey(t){const n=qe.ProjectivePoint.fromHex(v(t));return S(n.toRawBytes(!1).slice(1))}},Da=13,Na=8,Fa=1,Un=32,ah=16,_a=p(e=>/^0x/.test(e)?e.slice(2):e,"removeHexPrefix");async function ri(e,t,n){const s=Ye(_a(e),"hex"),a=new G(t),r=we(Un),o=pr({password:Ye(n),salt:r,dklen:Un,n:2**Da,r:Na,p:Fa}),i=we(ah),c=await Oc(s,o,i),d=Uint8Array.from([...o.subarray(16,32),...c]),h=fr(d),f=Et(h,"hex"),b={id:Fc(),version:3,address:_a(a.toHexString()),crypto:{cipher:"aes-128-ctr",mac:f,cipherparams:{iv:Et(i,"hex")},ciphertext:Et(c,"hex"),kdf:"scrypt",kdfparams:{dklen:Un,n:2**Da,p:Fa,r:Na,salt:Et(r,"hex")}}};return JSON.stringify(b)}p(ri,"encryptKeystoreWallet");async function oi(e,t){const n=JSON.parse(e),{crypto:{mac:s,ciphertext:a,cipherparams:{iv:r},kdfparams:{dklen:o,n:i,r:c,p:d,salt:h}}}=n,f=Ye(a,"hex"),b=Ye(r,"hex"),g=Ye(h,"hex"),I=Ye(t),m=pr({password:I,salt:g,n:i,p:d,r:c,dklen:o}),y=Uint8Array.from([...m.subarray(16,32),...f]),C=fr(y),T=Et(C,"hex");if(s!==T)throw new l(w.INVALID_PASSWORD,"Failed to decrypt the keystore wallet, the provided password is incorrect.");const A=await Ec(f,m,b);return S(A)}p(oi,"decryptKeystoreWallet");var rh=class extends Dn{static{p(this,"BaseWalletUnlocked")}static defaultPath="m/44'/1179993420'/0'/0/0";signer;constructor(e,t){const n=new Lt(e);super(n.address,t),this.signer=()=>n}get privateKey(){return this.signer().privateKey}get publicKey(){return this.signer().publicKey}async signMessage(e){const t=await this.signer().sign(yr(e));return S(t)}async signTransaction(e){const t=oe(e),n=await this.provider.getChainId(),s=t.getTransactionId(n),a=await this.signer().sign(s);return S(a)}async populateTransactionWitnessesSignature(e){const t=oe(e),n=await this.signTransaction(t);return t.updateWitnessByOwner(this.address,n),t}async sendTransaction(e,{estimateTxDependencies:t=!1,enableAssetBurn:n}={}){const s=oe(e);return wo(await this.provider.getBaseAssetId(),s,n),t&&await this.provider.estimateTxDependencies(s),this.provider.sendTransaction(await this.populateTransactionWitnessesSignature(s),{estimateTxDependencies:!1,enableAssetBurn:n})}async simulateTransaction(e,{estimateTxDependencies:t=!0}={}){const n=oe(e);return t&&await this.provider.estimateTxDependencies(n),this.provider.dryRun(await this.populateTransactionWitnessesSignature(n),{utxoValidation:!0,estimateTxDependencies:!1})}async encrypt(e){return ri(this.privateKey,this.address,e)}},qt=["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"];function ii(e){return(1<<e)-1}p(ii,"getLowerMask");function $s(e){return(1<<e)-1<<8-e}p($s,"getUpperMask");function Qt(e){return Array.isArray(e)?e:e.split(/\s+/)}p(Qt,"getWords");function ci(e){return Array.isArray(e)?e.join(" "):e}p(ci,"getPhrase");function di(e){const t=[0];let n=11;for(let r=0;r<e.length;r+=1)n>8?(t[t.length-1]<<=8,t[t.length-1]|=e[r],n-=8):(t[t.length-1]<<=n,t[t.length-1]|=e[r]>>8-n,t.push(e[r]&ii(8-n)),n+=3);const s=e.length/4,a=v(te(e))[0]&$s(s);return t[t.length-1]<<=s,t[t.length-1]|=a>>8-s,t}p(di,"entropyToMnemonicIndices");function ui(e,t){const n=Math.ceil(11*e.length/8),s=v(new Uint8Array(n));let a=0;for(let d=0;d<e.length;d+=1){const h=t.indexOf(e[d].normalize("NFKD"));if(h===-1)throw new l(w.INVALID_MNEMONIC,`Invalid mnemonic: the word '${e[d]}' is not found in the provided wordlist.`);for(let f=0;f<11;f+=1)h&1<<10-f&&(s[a>>3]|=1<<7-a%8),a+=1}const r=32*e.length/3,o=e.length/3,i=$s(o);if((v(te(s.slice(0,r/8)))[0]&i)!==(s[s.length-1]&i))throw new l(w.INVALID_CHECKSUM,"Checksum validation failed for the provided mnemonic.");return s.slice(0,r/8)}p(ui,"mnemonicWordsToEntropy");var oh=Ce("Bitcoin seed"),ih="0x0488ade4",ch="0x04358394",Ba=[12,15,18,21,24];function is(e){if(e.length!==2048)throw new l(w.INVALID_WORD_LIST,`Expected word list length of 2048, but got ${e.length}.`)}p(is,"assertWordList");function li(e){if(e.length%4!==0||e.length<16||e.length>32)throw new l(w.INVALID_ENTROPY,`Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${e.length} bytes.`)}p(li,"assertEntropy");function en(e){if(!Ba.includes(e.length)){const t=`Invalid mnemonic size. Expected one of [${Ba.join(", ")}] words, but got ${e.length}.`;throw new l(w.INVALID_MNEMONIC,t)}}p(en,"assertMnemonic");var dh=class Ge{static{p(this,"Mnemonic")}wordlist;constructor(t=qt){this.wordlist=t,is(this.wordlist)}mnemonicToEntropy(t){return Ge.mnemonicToEntropy(t,this.wordlist)}entropyToMnemonic(t){return Ge.entropyToMnemonic(t,this.wordlist)}static mnemonicToEntropy(t,n=qt){const s=Qt(t);return en(s),S(ui(s,n))}static entropyToMnemonic(t,n=qt){const s=v(t);return is(n),li(s),di(s).map(a=>n[a]).join(" ")}static mnemonicToSeed(t,n=""){en(Qt(t));const s=Ce(ci(t)),a=Ce(`mnemonic${n}`);return Dc(s,a,2048,64,"sha512")}static mnemonicToMasterKeys(t,n=""){const s=Ge.mnemonicToSeed(t,n);return Ge.masterKeysFromSeed(s)}static isMnemonicValid(t){const n=Qt(t);let s=0;try{en(n)}catch{return!1}for(;s<n.length;){if(Ge.binarySearch(n[s])===!1)return!1;s+=1}return!0}static binarySearch(t){const n=qt;let s=0,a=n.length-1;for(;s<=a;){const r=Math.floor((s+a)/2);if(n[r]===t)return!0;t<n[r]?a=r-1:s=r+1}return!1}static masterKeysFromSeed(t){const n=v(t);if(n.length<16||n.length>64)throw new l(w.INVALID_SEED,`Seed length should be between 16 and 64 bytes, but received ${n.length} bytes.`);return v(mr("sha512",oh,n))}static seedToExtendedKey(t,n=!1){const s=Ge.masterKeysFromSeed(t),a=v(n?ch:ih),r="0x00",o="0x00000000",i="0x00000000",c=s.slice(32),d=s.slice(0,32),h=B([a,r,o,i,c,B(["0x00",d])]),f=fn(te(te(h)),0,4);return ps(B([h,f]))}static generate(t=32,n=""){const s=n?te(B([we(t),v(n)])):we(t);return Ge.entropyToMnemonic(s)}},zs=dh,hi=2147483648,pi=S("0x0488ade4"),Ws=S("0x0488b21e"),fi=S("0x04358394"),Vs=S("0x043587cf");function cs(e){return ps(B([e,fn(te(te(e)),0,4)]))}p(cs,"base58check");function mi(e=!1,t=!1){return e?t?Vs:Ws:t?fi:pi}p(mi,"getExtendedKeyPrefix");function gi(e){return[Ws,Vs].includes(S(e.slice(0,4)))}p(gi,"isPublicExtendedKey");function yi(e){return[pi,fi,Ws,Vs].includes(S(e.slice(0,4)))}p(yi,"isValidExtendedKey");function wi(e,t=0){const n=e.split("/");if(n.length===0||n[0]==="m"&&t!==0)throw new l(w.HD_WALLET_ERROR,`invalid path - ${e}`);return n[0]==="m"&&n.shift(),n.map(s=>~s.indexOf("'")?parseInt(s,10)+hi:parseInt(s,10))}p(wi,"parsePath");var uh=class ht{static{p(this,"HDWallet")}depth=0;index=0;fingerprint=S("0x00000000");parentFingerprint=S("0x00000000");privateKey;publicKey;chainCode;constructor(t){if(t.privateKey){const n=new Lt(t.privateKey);this.publicKey=S(n.compressedPublicKey),this.privateKey=S(t.privateKey)}else{if(!t.publicKey)throw new l(w.HD_WALLET_ERROR,"Both public and private Key cannot be missing. At least one should be provided.");this.publicKey=S(t.publicKey)}this.parentFingerprint=t.parentFingerprint||this.parentFingerprint,this.fingerprint=fn(Nc(te(this.publicKey)),0,4),this.depth=t.depth||this.depth,this.index=t.index||this.index,this.chainCode=t.chainCode}get extendedKey(){return this.toExtendedKey()}deriveIndex(t){const n=this.privateKey&&v(this.privateKey),s=v(this.publicKey),a=v(this.chainCode),r=new Uint8Array(37);if(t&hi){if(!n)throw new l(w.HD_WALLET_ERROR,"Cannot derive a hardened index without a private Key.");r.set(n,1)}else r.set(v(this.publicKey));r.set(Se(t,4),33);const o=v(mr("sha512",a,r)),i=o.slice(0,32),c=o.slice(32);if(n){const b=u(i).add(n).mod("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141").toBytes(32);return new ht({privateKey:b,chainCode:c,index:t,depth:this.depth+1,parentFingerprint:this.fingerprint})}const h=new Lt(S(i)).addPoint(s);return new ht({publicKey:h,chainCode:c,index:t,depth:this.depth+1,parentFingerprint:this.fingerprint})}derivePath(t){return wi(t,this.depth).reduce((s,a)=>s.deriveIndex(a),this)}toExtendedKey(t=!1,n=!1){if(this.depth>=256)throw new l(w.HD_WALLET_ERROR,`Exceeded max depth of 255. Current depth: ${this.depth}.`);const s=mi(this.privateKey==null||t,n),a=S(Uint8Array.from([this.depth])),r=this.parentFingerprint,o=ls(this.index,4),i=this.chainCode,c=this.privateKey!=null&&!t?B(["0x00",this.privateKey]):this.publicKey,d=v(B([s,a,r,o,i,c]));return cs(d)}static fromSeed(t){const n=zs.masterKeysFromSeed(t);return new ht({chainCode:v(n.slice(32)),privateKey:v(n.slice(0,32))})}static fromExtendedKey(t){const n=S(Se(rr(t))),s=v(n),a=cs(s.slice(0,78))===t;if(s.length!==82||!yi(s))throw new l(w.HD_WALLET_ERROR,"Provided key is not a valid extended key.");if(!a)throw new l(w.HD_WALLET_ERROR,"Provided key has an invalid checksum.");const r=s[4],o=S(s.slice(5,9)),i=parseInt(S(s.slice(9,13)).substring(2),16),c=S(s.slice(13,45)),d=s.slice(45,78);if(r===0&&o!=="0x00000000"||r===0&&i!==0)throw new l(w.HD_WALLET_ERROR,"Inconsistency detected: Depth is zero but fingerprint/index is non-zero.");if(gi(s)){if(d[0]!==3)throw new l(w.HD_WALLET_ERROR,"Invalid public extended key.");return new ht({publicKey:d,chainCode:c,index:i,depth:r,parentFingerprint:o})}if(d[0]!==0)throw new l(w.HD_WALLET_ERROR,"Invalid private extended key.");return new ht({privateKey:d.slice(1),chainCode:c,index:i,depth:r,parentFingerprint:o})}},Gn=uh,bi=class extends Dn{static{p(this,"WalletLocked")}unlock(e){return new Je(e,this._provider)}},Je=class $e extends rh{static{p(this,"WalletUnlocked")}lock(){return this.signer=()=>new Lt("0x00"),new bi(this.address,this._provider)}static generate(t){const n=Lt.generatePrivateKey(t?.entropy);return new $e(n,t?.provider)}static fromSeed(t,n,s){const r=Gn.fromSeed(t).derivePath(n||$e.defaultPath);return new $e(r.privateKey,s)}static fromMnemonic(t,n,s,a){const r=zs.mnemonicToSeed(t,s),i=Gn.fromSeed(r).derivePath(n||$e.defaultPath);return new $e(i.privateKey,a)}static fromExtendedKey(t,n){const s=Gn.fromExtendedKey(t);return new $e(s.privateKey,n)}static async fromEncryptedJson(t,n,s){const a=await oi(t,n);return new $e(a,s)}},ye=class{static{p(this,"Wallet")}static fromAddress(e,t){return new bi(e,t)}static fromPrivateKey(e,t){return new Je(e,t)}static generate=Je.generate;static fromSeed=Je.fromSeed;static fromMnemonic=Je.fromMnemonic;static fromExtendedKey=Je.fromExtendedKey;static fromEncryptedJson=Je.fromEncryptedJson},lh=class{static{p(this,"MemoryStorage")}storage=new Map;async getItem(e){return await this.storage.get(e)}async setItem(e,t){await this.storage.set(e,t)}async removeItem(e){await this.storage.delete(e)}async clear(){await this.storage.clear()}},hh=class{static{p(this,"MnemonicVault")}static type="mnemonic";#e;pathKey="{}";rootPath=`m/44'/1179993420'/${this.pathKey}'/0/0`;numberOfAccounts=0;constructor(e){this.#e=e.secret||zs.generate(),this.rootPath=e.rootPath||this.rootPath,this.numberOfAccounts=e.numberOfAccounts||1}getDerivePath(e){return this.rootPath.includes(this.pathKey)?this.rootPath.replace(this.pathKey,String(e)):`${this.rootPath}/${e}`}serialize(){return{secret:this.#e,rootPath:this.rootPath,numberOfAccounts:this.numberOfAccounts}}getAccounts(){const e=[];let t=0;do{const n=ye.fromMnemonic(this.#e,this.getDerivePath(t));e.push({publicKey:n.publicKey,address:n.address}),t+=1}while(t<this.numberOfAccounts);return e}addAccount(){this.numberOfAccounts+=1;const e=ye.fromMnemonic(this.#e,this.getDerivePath(this.numberOfAccounts-1));return{publicKey:e.publicKey,address:e.address}}exportAccount(e){let t=0;const n=new G(e);do{const s=ye.fromMnemonic(this.#e,this.getDerivePath(t));if(s.address.equals(n))return s.privateKey;t+=1}while(t<this.numberOfAccounts);throw new l(w.WALLET_MANAGER_ERROR,`Account with address '${e}' not found in derived wallets.`)}getWallet(e){const t=this.exportAccount(e);return ye.fromPrivateKey(t)}},ph=class{static{p(this,"PrivateKeyVault")}static type="privateKey";#e=[];constructor(e={}){e.secret?this.#e=[e.secret]:this.#e=e.accounts||[ye.generate().privateKey]}serialize(){return{accounts:this.#e}}getPublicAccount(e){const t=ye.fromPrivateKey(e);return{address:t.address,publicKey:t.publicKey}}getAccounts(){return this.#e.map(e=>this.getPublicAccount(e))}addAccount(){const e=ye.generate();return this.#e.push(e.privateKey),this.getPublicAccount(e.privateKey)}exportAccount(e){const t=new G(e),n=this.#e.find(s=>ye.fromPrivateKey(s).address.equals(t));if(!n)throw new l(w.WALLET_MANAGER_ERROR,`No private key found for address '${e}'.`);return n}getWallet(e){const t=this.exportAccount(e);return ye.fromPrivateKey(t)}},_e={invalid_vault_type:"The provided Vault type is invalid.",address_not_found:"No private key found for address the specified wallet address.",vault_not_found:"The specified vault was not found.",wallet_not_unlocked:"The wallet is currently locked."};function xe(e,t){if(!e)throw new l(w.WALLET_MANAGER_ERROR,t)}p(xe,"assert");(class Ii extends Ja.EventEmitter{static{p(this,"WalletManager")}static Vaults=[hh,ph];storage=new lh;STORAGE_KEY="WalletManager";#e=[];#n="";#t=!0;constructor(t){super(),this.storage=t?.storage||this.storage}get isLocked(){return this.#t}exportVault(t){xe(!this.#t,_e.wallet_not_unlocked);const n=this.#e.find((s,a)=>a===t);return xe(n,_e.vault_not_found),n.vault.serialize()}getVaults(){return this.#e.map((t,n)=>({title:t.title,type:t.type,vaultId:n}))}getAccounts(){return this.#e.flatMap((t,n)=>t.vault.getAccounts().map(s=>({...s,vaultId:n})))}getWallet(t){const n=new G(t),s=this.#e.find(a=>a.vault.getAccounts().find(r=>r.address.equals(n)));return xe(s,_e.address_not_found),s.vault.getWallet(n)}exportPrivateKey(t){const n=new G(t);xe(!this.#t,_e.wallet_not_unlocked);const s=this.#e.find(a=>a.vault.getAccounts().find(r=>r.address.equals(n)));return xe(s,_e.address_not_found),s.vault.exportAccount(n)}async addAccount(t){await this.loadState();const n=this.#e[t?.vaultId||0];await xe(n,_e.vault_not_found);const s=n.vault.addAccount();return await this.saveState(),s}async removeVault(t){this.#e.splice(t,1),await this.saveState()}async addVault(t){await this.loadState();const n=this.getVaultClass(t.type),s=new n(t);this.#e=this.#e.concat({title:t.title,type:t.type,vault:s}),await this.saveState()}lock(){this.#t=!0,this.#e=[],this.#n="",this.emit("lock")}async unlock(t){this.#n=t,this.#t=!1;try{await this.loadState(),this.emit("unlock")}catch(n){throw await this.lock(),n}}async updatePassphrase(t,n){const s=this.#t;await this.unlock(t),this.#n=n,await this.saveState(),await this.loadState(),s&&await this.lock()}async loadState(){await xe(!this.#t,_e.wallet_not_unlocked);const t=await this.storage.getItem(this.STORAGE_KEY);if(t){const n=await Ac(this.#n,JSON.parse(t));this.#e=this.#a(n.vaults)}}async saveState(){await xe(!this.#t,_e.wallet_not_unlocked);const t=await Pc(this.#n,{vaults:this.#s(this.#e)});await this.storage.setItem(this.STORAGE_KEY,JSON.stringify(t)),this.emit("update")}#s(t){return t.map(({title:n,type:s,vault:a})=>({title:n,type:s,data:a.serialize()}))}#a(t){return t.map(({title:n,type:s,data:a})=>{const r=this.getVaultClass(s);return{title:n,type:s,vault:new r(a)}})}getVaultClass(t){const n=Ii.Vaults.find(s=>s.type===t);return xe(n,_e.invalid_vault_type),n}});(class{static{p(this,"Vault")}static type;constructor(e){throw new l(w.NOT_IMPLEMENTED,"Not implemented.")}serialize(){throw new l(w.NOT_IMPLEMENTED,"Not implemented.")}getAccounts(){throw new l(w.NOT_IMPLEMENTED,"Not implemented.")}addAccount(){throw new l(w.NOT_IMPLEMENTED,"Not implemented.")}exportAccount(e){throw new l(w.NOT_IMPLEMENTED,"Not implemented.")}getWallet(e){throw new l(w.NOT_IMPLEMENTED,"Not implemented.")}});(class{static{p(this,"StorageAbstract")}});var fh=32,ae=16,fe=17,it=18,mh=8,gh=8,yh=16;function Ci(e){const[t]=new O("u64").decode(e,gh);return t.toNumber()}p(Ci,"getBytecodeDataOffset");function Nn(e){const[t]=new O("u64").decode(e,yh);return t.toNumber()}p(Nn,"getBytecodeConfigurableOffset");function Si(e){const t=Nn(e),n=e.slice(0,t);return te(n)}p(Si,"getBytecodeId");function wh(e){const t=Ci(e),n=e.slice(0,t);return te(n)}p(wh,"getLegacyBlobId");function vi(e,t){const{RegId:n,Instruction:s}=Za,a=n.pc().to_u8(),r=n.sp().to_u8(),o=n.is().to_u8(),i=p(m=>[pt(ae,a),ke(ae,ae,m*s.size()),pt(fe,r),Wn(it,ae),Ht(ae,0,it,1),ke(ae,ae,fh),nn(it,ae,0),ke(ae,ae,mh),Ht(ae,0,it,2),Vn(fe,fe,o),qn(fe,fe,4),Hn(fe)],"getInstructions"),c=p(m=>[pt(ae,a),ke(ae,ae,m*s.size()),pt(fe,r),Wn(it,ae),Ht(ae,0,it,1),Vn(fe,fe,o),qn(fe,fe,4),Hn(fe)],"getInstructionsNoDataSection"),d=Nn(e);if(e.length<d)throw new Error(`Data section offset is out of bounds, offset: ${d}, binary length: ${e.length}`);const h=e.slice(d);if(h.length>0){const m=i(0).length;if(m>65535)throw new Error("Too many instructions, exceeding u16::MAX.");const y=new Uint8Array(i(m).flatMap(M=>Array.from(M.to_bytes()))),C=new Uint8Array(t),T=new Uint8Array(8);new DataView(T.buffer).setBigUint64(0,BigInt(h.length),!1);const R=new Uint8Array([...y,...C,...T]);return{loaderBytecode:B([R,h]),blobOffset:R.length}}const f=c(0).length;if(f>65535)throw new Error("Too many instructions, exceeding u16::MAX.");const b=new Uint8Array(c(f).flatMap(m=>Array.from(m.to_bytes()))),g=new Uint8Array(t);return{loaderBytecode:new Uint8Array([...b,...g])}}p(vi,"getPredicateScriptLoaderInstructions");async function Ti(e,t){const{assembledRequest:n}=await e.provider.assembleTx({request:t,feePayerAccount:e,accountCoinQuantities:[]});return n}p(Ti,"fundBlobTx");function Ri(e,t){const{configurables:n}=e,s=[];return n.forEach(a=>{s.push({...a,offset:a.offset-t})}),{...e,configurables:s}}p(Ri,"adjustConfigurableOffsets");async function qs({deployer:e,bytecode:t,abi:n,loaderInstanceCallback:s}){const a=Si(v(t)),r=Nn(v(t)),o=t.slice(0,r),i=new hn({blobId:a,witnessIndex:0,witnesses:[o]}),{loaderBytecode:c,blobOffset:d}=vi(v(t),v(a)),h=o.length-(d||0),f=Ri(n,h),b=(await e.provider.getBlobs([a])).length>0,g=s(c,f);if(b)return{waitForResult:p(()=>Promise.resolve(g),"waitForResult"),blobId:a};const I=await Ti(e,i);return{waitForResult:p(async()=>{try{if((await(await e.sendTransaction(I)).waitForResult()).status!=="success")throw new Error}catch{throw new l(w.TRANSACTION_FAILED,"Failed to deploy predicate chunk")}return g},"waitForResult"),blobId:a}}p(qs,"deployScriptOrPredicate");var bh=p(e=>{const n=v(e),s=Qa(n,16384),a=Ss(s.map(o=>S(o)));return Te(B(["0x4655454C",a]))},"getPredicateRoot");(class Dt extends Dn{static{p(this,"Predicate")}bytes;predicateData=[];interface;initialBytecode;configurableConstants;constructor({bytecode:t,abi:n,provider:s,data:a,configurableConstants:r}){const{predicateBytes:o,predicateInterface:i}=Dt.processPredicateData(t,n,r),c=new G(bh(o));super(c,s),this.initialBytecode=v(t),this.bytes=o,this.interface=i,this.configurableConstants=r,a!==void 0&&a.length>0&&(this.predicateData=a)}populateTransactionPredicateData(t){const n=oe(t),s=this.getIndexFromPlaceholderWitness(n);return s!==-1&&n.removeWitness(s),n.inputs.filter(Rn).forEach(a=>{ss(a,this.address)&&(a.predicate=S(this.bytes),a.predicateData=S(this.getPredicateData()),a.witnessIndex=0)}),n}sendTransaction(t){const n=oe(t);return super.sendTransaction(n,{estimateTxDependencies:!1})}simulateTransaction(t){const n=oe(t);return super.simulateTransaction(n,{estimateTxDependencies:!1})}getPredicateData(){return this.predicateData.length?this.interface?.functions.main?.encodeArguments(this.predicateData)||new Uint8Array:new Uint8Array}toNewInstance(t={}){return new Dt({bytecode:this.initialBytecode,abi:this.interface.jsonAbi,provider:this.provider,data:t.data??this.predicateData,configurableConstants:t.configurableConstants??this.configurableConstants})}setData(t){this.predicateData=t}static processPredicateData(t,n,s){let a=v(t);const r=new be(n);if(r.functions.main===void 0)throw new l(w.ABI_MAIN_METHOD_MISSING,'Cannot use ABI without "main" function.');return s&&Object.keys(s).length&&(a=Dt.setConfigurableConstants(a,s,r)),{predicateBytes:a,predicateInterface:r}}async getResourcesToSpend(t,n){return(await this.provider.getResourcesToSpend(this.address,t,n)).map(a=>({...a,predicate:S(this.bytes),predicateData:S(this.getPredicateData())}))}generateFakeResources(t){return super.generateFakeResources(t).map(n=>({...n,predicate:S(this.bytes),predicateData:S(this.getPredicateData())}))}static setConfigurableConstants(t,n,s){const a=t;try{if(Object.keys(s.configurables).length===0)throw new l(w.INVALID_CONFIGURABLE_CONSTANTS,"Predicate has no configurable constants to be set");Object.entries(n).forEach(([r,o])=>{if(!s?.configurables[r])throw new l(w.CONFIGURABLE_NOT_FOUND,`No configurable constant named '${r}' found in the Predicate`);const{offset:i}=s.configurables[r],c=s.encodeConfigurable(r,o);a.set(c,i)})}catch(r){throw new l(w.INVALID_CONFIGURABLE_CONSTANTS,`Error setting configurable constants: ${r.message}.`)}return a}getIndexFromPlaceholderWitness(t){const n=t.inputs.filter(yt).filter(r=>ss(r,this.address));let s=-1;const a=n.find(r=>!r.predicate);return a&&(s=a.witnessIndex,n.every(o=>!o.predicate)||n[0]?.predicate&&(s=-1)),s}async deploy(t){return qs({deployer:t,abi:this.interface.jsonAbi,bytecode:this.bytes,loaderInstanceCallback:p((n,s)=>new Dt({bytecode:n,abi:s,provider:this.provider,data:this.predicateData}),"loaderInstanceCallback")})}});var xi=(e=>(e.ping="ping",e.version="version",e.connect="connect",e.disconnect="disconnect",e.isConnected="isConnected",e.accounts="accounts",e.currentAccount="currentAccount",e.signTransaction="signTransaction",e.signMessage="signMessage",e.sendTransaction="sendTransaction",e.assets="assets",e.addAsset="addAsset",e.addAssets="addAssets",e.networks="networks",e.currentNetwork="currentNetwork",e.addNetwork="addNetwork",e.selectNetwork="selectNetwork",e.addABI="addABI",e.getABI="getABI",e.hasABI="hasABI",e.startConsolidation="startConsolidation",e))(xi||{}),Hs=(e=>(e.connectors="connectors",e.currentConnector="currentConnector",e.connection="connection",e.accounts="accounts",e.currentAccount="currentAccount",e.networks="networks",e.currentNetwork="currentNetwork",e.assets="assets",e.abis="abis",e.consolidateCoins="consolidateCoins",e))(Hs||{}),Ai="FuelConnector",Ih=class{static{p(this,"LocalStorage")}storage;constructor(e){this.storage=e}async setItem(e,t){this.storage.setItem(e,t)}async getItem(e){return this.storage.getItem(e)}async removeItem(e){this.storage.removeItem(e)}async clear(){this.storage.clear()}},Ch=class extends Ja.EventEmitter{static{p(this,"FuelConnector")}name="";metadata={};connected=!1;installed=!1;external=!0;events=Hs;async ping(){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async version(){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async isConnected(){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async accounts(){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async connect(){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async disconnect(){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async signMessage(e,t){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async signTransaction(e,t,n){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async sendTransaction(e,t,n){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async currentAccount(){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async addAssets(e){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async addAsset(e){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async assets(){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async addNetwork(e){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async selectNetwork(e){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async networks(){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async currentNetwork(){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async addABI(e,t){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async getABI(e){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async hasABI(e){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}async startConsolidation(e){throw new l(l.CODES.NOT_IMPLEMENTED,"Method not implemented.")}on(e,t){return super.on(e,t),this}};function Pi(e,{cache:t,cacheTime:n,key:s}){return async(...a)=>{if(t[s]&&t[s]?.value)return t[s]?.value;clearTimeout(t[s]?.timeout);const r=await e(...a);return t[s]={timeout:Number(setTimeout(()=>{t[s]=null},n)),value:r},r}}p(Pi,"cacheFor");function Sh(e){window.dispatchEvent(new CustomEvent(Ai,{detail:e}))}p(Sh,"dispatchFuelConnectorEvent");function Ei(){const e={};return e.promise=new Promise((t,n)=>{e.reject=n,e.resolve=t}),e}p(Ei,"deferPromise");async function Nt(e,t=1050){const n=new Promise((s,a)=>{setTimeout(()=>{a(new l(l.CODES.TIMEOUT_EXCEEDED,"Promise timed out"))},t)});return Promise.race([n,e])}p(Nt,"withTimeout");var vh=2e3,Th=5e3,{warn:Rh}=console;(class Ft extends Ch{static{p(this,"Fuel")}static STORAGE_KEY="fuel-current-connector";static defaultConfig={};_storage=null;_connectors=[];_targetObject=null;_unsubscribes=[];_targetUnsubscribe=p(()=>{},"_targetUnsubscribe");_pingCache={};_currentConnector;_initializationPromise=null;constructor(t=Ft.defaultConfig){super(),this.setMaxListeners(1e3),this._connectors=t.connectors??[],this._targetObject=this.getTargetObject(t.targetObject),this._storage=t.storage===void 0?this.getStorage():t.storage,this.setupMethods(),this._initializationPromise=this.initialize()}async initialize(){try{const t=this.setDefaultConnector();this._targetUnsubscribe=this.setupConnectorListener(),await t}catch{throw new l(w.INVALID_PROVIDER,"Error initializing Fuel Connector")}}async init(){return await this._initializationPromise,this}getTargetObject(t){return t||(typeof window<"u"?window:typeof document<"u"?document:null)}getStorage(){if(typeof window<"u")return new Ih(window.localStorage)}async setDefaultConnector(){const t=await this._storage?.getItem(Ft.STORAGE_KEY)||this._connectors[0]?.name;if(t)return this.selectConnector(t,{emitEvents:!1})}setupConnectorEvents(t){if(!this._currentConnector)return;const n=this._currentConnector;this._unsubscribes.map(s=>s()),this._unsubscribes=t.map(s=>{const a=p((...r)=>this.emit(s,...r),"handler");return n.on(s,a),()=>n.off(s,a)})}async callMethod(t,...n){const s=await this.hasConnector();if(await this.pingConnector(),!this._currentConnector||!s)throw new l(w.MISSING_CONNECTOR,`No connector selected for calling ${t}. Use hasConnector before executing other methods.`);if(typeof this._currentConnector[t]=="function")return this._currentConnector[t](...n)}setupMethods(){Object.values(xi).forEach(t=>{this[t]=async(...n)=>this.callMethod(t,...n)})}async fetchConnectorStatus(t){const n=Date.now(),[s,a]=await Promise.allSettled([Nt(t.isConnected()),Nt(this.pingConnector(t))]);return n<(t._latestUpdate||0)||(t._latestUpdate=Date.now(),t.installed=a.status==="fulfilled"&&a.value,t.connected=s.status==="fulfilled"&&s.value),{installed:t.installed,connected:t.connected}}async fetchConnectorsStatus(){return Promise.all(this._connectors.map(async t=>this.fetchConnectorStatus(t)))}async pingConnector(t){const n=t||this._currentConnector;if(!n)return!1;try{return await Pi(async()=>Nt(n.ping()),{key:n.name,cache:this._pingCache,cacheTime:Th})()}catch{throw new l(w.INVALID_PROVIDER,"Current connector is not available.")}}setupConnectorListener=p(()=>{const{_targetObject:t}=this,n=Ai;if(t?.on)return t.on(n,this.addConnector),()=>{t.off?.(n,this.addConnector)};if(t?.addEventListener){const s=p(a=>{this.addConnector(a.detail)},"handler");return t.addEventListener(n,s),()=>{t.removeEventListener?.(n,s)}}return()=>{}},"setupConnectorListener");addConnector=p(async t=>{this.getConnector(t)||this._connectors.push(t),await this.fetchConnectorStatus(t),this.emit(this.events.connectors,this._connectors),this._currentConnector||await this.selectConnector(t.name,{emitEvents:!1})},"addConnector");triggerConnectorEvents=p(async()=>{const[t,n,s]=await Promise.all([this.isConnected(),this.networks(),this.currentNetwork()]);if(this.emit(this.events.connection,t),this.emit(this.events.networks,n),this.emit(this.events.currentNetwork,s),t){const[a,r]=await Promise.all([this.accounts(),this.currentAccount()]);this.emit(this.events.accounts,a),this.emit(this.events.currentAccount,r)}},"triggerConnectorEvents");getConnector=p(t=>this._connectors.find(n=>{const s=typeof t=="string"?t:t.name;return n.name===s||n===t})||null,"getConnector");async connectors(){return await this.fetchConnectorsStatus(),this._connectors}async selectConnector(t,n={emitEvents:!0}){const s=this.getConnector(t);if(!s)return!1;if(this._currentConnector?.name===t)return!0;const{installed:a}=await this.fetchConnectorStatus(s);return a?(this._currentConnector=s,this.emit(this.events.currentConnector,s),this.setupConnectorEvents(Object.values(Hs)),await this._storage?.setItem(Ft.STORAGE_KEY,s.name),n.emitEvents&&this.triggerConnectorEvents(),!0):!1}currentConnector(){return this._currentConnector}async hasConnector(){if(this._currentConnector)return!0;const t=Ei();return this.once(this.events.currentConnector,()=>{t.resolve(!0)}),Nt(t.promise,vh).then(()=>!0).catch(()=>!1)}async hasWallet(){return this.hasConnector()}async getProvider(t){return Rh("getProvider is deprecated and is going to be removed in the future, use getWallet instead."),this._getProvider(t)}async _getProvider(t){let n;if(t&&"getTransactionResponse"in t)n=t;else if(t&&"chainId"in t&&"url"in t)n=new Pa(t.url);else{if(t)throw new l(w.INVALID_PROVIDER,"Provider is not valid.");{const s=await this.currentNetwork();n=new Pa(s.url)}}return n}async getWallet(t,n){const s=await this._getProvider(n);return new Dn(t,s,this)}unsubscribe(){this._unsubscribes.map(t=>t()),this._targetUnsubscribe(),this.removeAllListeners()}async clean(){await this._storage?.removeItem(Ft.STORAGE_KEY)}async destroy(){this.unsubscribe(),await this.clean()}});var xh=Object.defineProperty,q=(e,t)=>xh(e,"name",{value:t,configurable:!0}),Oi=class{static{q(this,"AbstractProgram")}};(class extends Oi{static{q(this,"AbstractContract")}});function ds(e,t){if(!e)throw new l(w.TRANSACTION_ERROR,t)}q(ds,"assert");function Fn(e){return e.reduce((t,n,s)=>{const{program:a,externalAbis:r}=n.getCallConfig();return s===0?(t.main=a.interface.jsonAbi,t.otherContractsAbis={}):t.otherContractsAbis[a.id.toB256()]=a.interface.jsonAbi,t.otherContractsAbis={...t.otherContractsAbis,...r},t},{})}q(Fn,"getAbisFromAllCalls");var js=q(e=>{const{receipts:t,mainCallConfig:n,functionScopes:s}=e;if(!n)return{logs:[],groupedLogs:{}};const{main:a,otherContractsAbis:r}=Fn(s);return Mt({receipts:t,mainAbi:a,externalAbis:r})},"getAllResultLogs"),Ks=class{static{q(this,"InstructionSet")}#e;constructor(...e){this.#e=e||[]}entries(){return this.#e}push(...e){this.#e.push(...e)}concat(e){return this.#e.concat(e)}extend(e){this.#e.push(...e)}toBytes(){return B(this.#e.reduce((e,t)=>(e.push(t.to_bytes()),e),[]))}toHex(){return S(this.toBytes())}toString(){return`Program:
${JSON.stringify(this.#e,null,2)}`}byteLength(){return this.toBytes().byteLength}},Ah=q(e=>Tr+vr({maxInputs:e}),"calculateScriptDataBaseOffset");function Di(e){const t=[...e.receipts];let n,s;if(t.forEach(r=>{r.type===L.ScriptResult?n=r:(r.type===L.Return||r.type===L.ReturnData||r.type===L.Revert)&&(s=r)}),!n||!s)throw new l(w.SCRIPT_REVERTED,"Transaction reverted.");return{code:n.result,gasUsed:n.gasUsed,receipts:t,scriptResultReceipt:n,returnReceipt:s,callResult:e}}q(Di,"callResultToScriptResult");function _n(e){const{callResult:t,scriptResultDecoder:n,logs:s=[],groupedLogs:a={},abis:r}=e;try{const o=Di(t);return n(o)}catch(o){if(o.code===w.SCRIPT_REVERTED){const i=t?.dryRunStatus?.reason;throw Os({logs:s,groupedLogs:a,receipts:t.receipts,statusReason:i,abis:r})}throw o}}q(_n,"decodeCallResult");function Ni(e){const{callResult:t,call:n,logs:s=[],groupedLogs:a={},abis:r}=e;return _n({callResult:t,scriptResultDecoder:q(o=>{if(o.returnReceipt.type===L.Revert)throw new l(w.SCRIPT_REVERTED,`Script Reverted. Logs: ${JSON.stringify(s)}`);if(o.returnReceipt.type!==L.Return&&o.returnReceipt.type!==L.ReturnData){const{type:c}=o.returnReceipt;throw new l(w.SCRIPT_REVERTED,`Script Return Type [${c}] Invalid. Logs: ${JSON.stringify({logs:s,groupedLogs:a,receipt:o.returnReceipt})}`)}let i;return o.returnReceipt.type===L.Return&&(i=o.returnReceipt.val),o.returnReceipt.type===L.ReturnData&&(i=n.func.decodeOutput(o.returnReceipt.data)[0]),i},"scriptResultDecoder"),logs:s,groupedLogs:a,abis:r})}q(Ni,"callResultToInvocationResult");var Js=class Fi{static{q(this,"ScriptRequest")}bytes;scriptDataEncoder;scriptResultDecoder;constructor(t,n,s){this.bytes=v(t),this.scriptDataEncoder=n,this.scriptResultDecoder=s}static getScriptDataOffsetWithScriptBytes(t,n){return vr({maxInputs:n})+Tr+t}getScriptDataOffset(t){return Fi.getScriptDataOffsetWithScriptBytes(this.bytes.length,t)}encodeScriptData(t){const n=this.scriptDataEncoder(t);return ArrayBuffer.isView(n)?n:(this.bytes=v(n.script),n.data)}decodeCallResult(t,n,s,a){let r,o,i,c;return typeof t=="object"&&"callResult"in t?(r=t.callResult,o=t.logs??[],i=t.groupedLogs??{},c=t.abis):(r=t,o=n??[],i=s??{},c=a),_n({callResult:r,scriptResultDecoder:this.scriptResultDecoder,logs:o,groupedLogs:i,abis:c})}},_i={assetIdOffset:0,amountOffset:0,gasForwardedOffset:0,callDataOffset:0},Ph=K,Bi=q(({callDataOffset:e,gasForwardedOffset:t,amountOffset:n,assetIdOffset:s})=>{const a=new Ks(Pt(16,e),Pt(17,n),nn(17,17,0),Pt(18,s));return t?a.push(Pt(19,t),nn(19,19,0),Xs(16,17,18,19)):a.push(Xs(16,17,18,oc.cgas().to_u8())),a},"getSingleCallInstructions");function us(e){if(!e.length)return new Uint8Array;const t=new Ks;for(let n=0;n<e.length;n+=1)t.extend(Bi(e[n]).entries());return t.push(Xa(1)),t.toBytes()}q(us,"getInstructions");var Eh=q(e=>e===L.Return||e===L.ReturnData,"isReturnType"),Oh=q((e,t)=>e.find(({type:n,id:s,to:a})=>n===L.Call&&s===Ph&&a===t),"getMainCallReceipt"),Dh=q(e=>t=>{if(ze(t.code)!==0)throw new l(w.SCRIPT_REVERTED,"Transaction reverted.");const n=Oh(t.receipts,e.toB256()),s=u(n?.is);return t.receipts.filter(({type:r})=>Eh(r)).flatMap(r=>s.eq(u(r.is))?r.type===L.Return?[new O("u64").encode(r.val)]:r.type===L.ReturnData?[v(r.data)]:[new Uint8Array]:[])},"scriptResultDecoder"),Nh=q(e=>{const{contractId:t,...n}=e;return _n({...n,scriptResultDecoder:Dh(t)})},"decodeContractCallScriptResult"),Fh=q(e=>e.reduce((t,n)=>{const s={..._i};return n.gas&&(s.gasForwardedOffset=1),t+Bi(s).byteLength()},rc.size()),"getCallInstructionsLength"),_h=q((e,t)=>new Js(us(new Array(e.length).fill(_i)),n=>{const s=n.length;if(s===0)return{data:new Uint8Array,script:new Uint8Array};const a=Fh(n),r=(8-a%8)%8,o=a+r,i=Ah(t.toNumber())+o,c=[];let d=i;const h=[];for(let g=0;g<s;g+=1){const I=n[g],m=d,y=m+V,C=y+on,T=C+Yn+V+V,A=T+I.fnSelectorBytes.byteLength,R=v(I.data);let M=0;h.push(new O("u64").encode(I.amount||0)),h.push(new F().encode(I.assetId?.toString()||K)),h.push(I.contractId.toBytes()),h.push(new O("u64").encode(T)),h.push(new O("u64").encode(A)),h.push(I.fnSelectorBytes),h.push(R),I.gas&&(h.push(new O("u64").encode(I.gas)),M=A+R.byteLength);const E={amountOffset:m,assetIdOffset:y,gasForwardedOffset:M,callDataOffset:C};c.push(E),d=i+B(h).byteLength}const f=us(c);return{data:B(h),script:f}},()=>[new Uint8Array]),"getContractCallScript");function Bn(e,t,n,s,a,r){let o,i,c,d,h,f;typeof e=="object"&&!Array.isArray(e)?(o=e.functionScopes,i=e.receipts,c=e.isMultiCall,d=e.logs??[],h=e.groupedLogs??{},f=e.abis):(o=e,i=t,c=n,d=s??[],h=a??{},f=r);const b=o[0]?.getCallConfig();if(o.length===1&&b&&"bytes"in b.program)return Ni({callResult:{receipts:i},call:b,logs:d,groupedLogs:h,abis:f});const I=Nh({callResult:{receipts:i},contractId:(b?.program).id,logs:d,groupedLogs:h,abis:f}).map((m,y)=>{const{func:C}=o[y].getCallConfig();return C.decodeOutput(m)?.[0]});return c?I:I?.[0]}q(Bn,"extractInvocationResult");var Bh=q(async e=>{const{funcScope:t,isMultiCall:n,program:s,transactionResponse:a}=e,r=await a.waitForResult(),{receipts:o}=r,i=Array.isArray(t)?t:[t],c=i[0]?.getCallConfig(),{main:d,otherContractsAbis:h}=Fn(i),f={main:d,otherContractsAbis:h},{logs:b,groupedLogs:g}=js({receipts:o,mainCallConfig:c,functionScopes:i}),I=Bn(i,o,n,b,g,f),m=St(o);return{isMultiCall:n,functionScopes:i,value:I,program:s,transactionResult:r,transactionResponse:a,transactionId:a.id,logs:b,groupedLogs:g,gasUsed:m}},"buildFunctionResult"),Mh=q(async e=>{const{funcScope:t,isMultiCall:n,program:s,transactionResponse:a}=e,r=await a.waitForPreConfirmation(),{receipts:o}=r,i=Array.isArray(t)?t:[t],c=i[0]?.getCallConfig();let d,h,f,b;return o&&({logs:d,groupedLogs:h}=js({receipts:o,mainCallConfig:c,functionScopes:i}),b=Bn(i,o,n,d,h),f=St(o)),{isMultiCall:n,functionScopes:i,program:s,transactionResult:r,transactionResponse:a,transactionId:a.id,logs:d,groupedLogs:h,gasUsed:f,value:b}},"buildPreConfirmationFunctionResult"),$n=q(e=>{const{funcScopes:t,callResult:n,isMultiCall:s}=e,{receipts:a}=n,r=Array.isArray(t)?t:[t],o=r[0]?.getCallConfig(),{logs:i,groupedLogs:c}=js({receipts:a,mainCallConfig:o,functionScopes:r}),d=Bn(r,a,s,i,c),h=St(a);return{functionScopes:r,callResult:n,isMultiCall:s,gasUsed:h,value:d}},"buildDryRunResult");function Mi(e){const{program:t,args:n,forward:s,func:a,callParameters:r,externalAbis:o}=e.getCallConfig(),i=a.encodeArguments(n);return{contractId:t.id,fnSelectorBytes:a.selectorBytes,data:i,assetId:s?.assetId,amount:s?.amount,gas:r?.gasLimit,externalContractsAbis:o}}q(Mi,"createContractCall");var Li=class{static{q(this,"BaseInvocationScope")}transactionRequest;program;functionInvocationScopes=[];txParameters;assembleTxParameters;requiredCoins=[];isMultiCall=!1;hasCallParamsGasLimit=!1;externalAbis={};addSignersCallback;constructor(e,t){this.program=e,this.isMultiCall=t,this.transactionRequest=new Ae}get calls(){return this.functionInvocationScopes.map(e=>Mi(e))}async updateScriptRequest(){const e=this.getProvider(),{consensusParameters:{txParameters:{maxInputs:t}}}=await e.getChain(),n=_h(this.functionInvocationScopes,t);this.transactionRequest.setScript(n,this.calls)}updateContractInputAndOutput(){this.calls.forEach(t=>{t.contractId&&this.transactionRequest.addContractInputAndOutput(t.contractId),t.externalContractsAbis&&Object.keys(t.externalContractsAbis).forEach(n=>this.transactionRequest.addContractInputAndOutput(new G(n)))})}getRequiredCoins(){return this.calls.map(t=>({assetId:String(t.assetId),amount:u(t.amount||0)})).filter(({assetId:t,amount:n})=>t&&!u(n).isZero())}updateRequiredCoins(){const e=this.getRequiredCoins(),t=q((n,{assetId:s,amount:a})=>{const r=n.get(s)?.amount||u(0);return n.set(s,{assetId:String(s),amount:r.add(a)})},"reduceForwardCoins");this.requiredCoins=Array.from(e.reduce(t,new Map).values())}addCall(e){return this.addCalls([e]),this}addCalls(e){return this.functionInvocationScopes.push(...e),this.updateContractInputAndOutput(),this.updateRequiredCoins(),this}async prepareTransaction(){await Ya(),await this.updateScriptRequest(),this.updateRequiredCoins(),this.checkGasLimitTotal(),this.transactionRequest.type===j.Script&&(this.transactionRequest.abis=Fn(this.functionInvocationScopes))}checkGasLimitTotal(){const e=this.calls.reduce((t,n)=>t.add(n.gas||0),u(0));if(this.transactionRequest.gasLimit.eq(0))this.transactionRequest.gasLimit=e;else if(e.gt(this.transactionRequest.gasLimit))throw new l(w.TRANSACTION_ERROR,"Transaction's gasLimit must be equal to or greater than the combined forwarded gas of all calls.")}async getTransactionCost(){const e=ne(await this.getTransactionRequest());return(this.program.account??ye.generate({provider:this.getProvider()})).getTransactionCost(e,{quantities:this.getRequiredCoins(),signatureCallback:this.addSignersCallback})}async fundWithRequiredCoins({skipAutoConsolidation:e}={}){let t=await this.getTransactionRequest();t=ne(t);let{feePayerAccount:n,accountCoinQuantities:s,...a}=this.assembleTxParameters??{};t.maxFee=u(0),t.gasLimit=u(0);const r=this.getProvider(),o=this.program.account??ye.generate({provider:r}),i=await r.getBaseAssetId();if(n||(n=o),!s){const d=t.outputs.filter(h=>h.type===k.Coin).map(({amount:h,assetId:f})=>({assetId:String(f),amount:u(h)}));s=Zt(d,this.requiredCoins),s.length||s.push({assetId:i,amount:u(0)})}const c=q(async()=>{const{assembledRequest:d,gasPrice:h}=await r.assembleTx({request:t,feePayerAccount:n,accountCoinQuantities:s,...a});return await ft({gasPrice:h,provider:r,transactionRequest:d,setGasLimit:this.txParameters?.gasLimit,setMaxFee:this.txParameters?.maxFee}),d},"assembleTx");try{return await c()}catch(d){if(!await os({error:d,account:o,skipAutoConsolidation:e}))throw d;return await c()}}async legacyFundWithRequiredCoins({skipAutoConsolidation:e}={}){let t=await this.getTransactionRequest();t=ne(t);const n=await this.getTransactionCost(),{gasUsed:s,missingContractIds:a,outputVariables:r,maxFee:o}=n;return this.setDefaultTxParams(t,s,o),a.forEach(i=>{t.addContractInputAndOutput(new G(i))}),t.addVariableOutputs(r),await this.program.account?.fund(t,n,{skipAutoConsolidation:e}),this.addSignersCallback&&await this.addSignersCallback(t),t}txParams(e){this.txParameters=e;const t=this.transactionRequest;return t.tip=u(e.tip||t.tip),t.gasLimit=u(e.gasLimit||t.gasLimit),t.maxFee=e.maxFee?u(e.maxFee):t.maxFee,t.witnessLimit=e.witnessLimit?u(e.witnessLimit):t.witnessLimit,t.maturity=e.maturity||t.maturity,t.expiration=e.expiration||t.expiration,t.addVariableOutputs(this.txParameters?.variableOutputs||0),this}assembleTxParams(e){return this.assembleTxParameters=e,this}addContracts(e){return e.forEach(t=>{typeof t=="string"?this.transactionRequest.addContractInputAndOutput(new G(t)):(this.transactionRequest.addContractInputAndOutput(t.id),this.externalAbis[t.id.toB256()]=t.interface.jsonAbi)}),this}addTransfer(e){const{amount:t,destination:n,assetId:s}=e;return this.transactionRequest=this.transactionRequest.addCoinOutput(new G(n),t,s),this}addBatchTransfer(e){return e.forEach(({destination:t,amount:n,assetId:s})=>{this.transactionRequest=this.transactionRequest.addCoinOutput(new G(t),n,s)}),this}addSigners(e){return this.addSignersCallback=t=>t.addAccountWitnesses(e),this}async getTransactionRequest(){return await this.prepareTransaction(),this.transactionRequest}fromRequest(e){return this.transactionRequest=e,this}async call(e){ds(this.program.account,"Wallet is required!");let t=await this.getTransactionRequest();const n=e?.skipAssembleTx,s=e?.skipAutoConsolidation;n||(this.addSignersCallback?t=await this.legacyFundWithRequiredCoins({skipAutoConsolidation:s}):t=await this.fundWithRequiredCoins({skipAutoConsolidation:s}));const a=await this.program.account.sendTransaction(t,{estimateTxDependencies:!1});return{transactionId:a.id,waitForResult:q(async()=>Bh({funcScope:this.functionInvocationScopes,isMultiCall:this.isMultiCall,program:this.program,transactionResponse:a}),"waitForResult"),waitForPreConfirmation:q(async()=>Mh({funcScope:this.functionInvocationScopes,isMultiCall:this.isMultiCall,program:this.program,transactionResponse:a}),"waitForPreConfirmation")}}async simulate(){if(ds(this.program.account,"Wallet is required!"),!("populateTransactionWitnessesSignature"in this.program.account))throw new l(w.ABI_MAIN_METHOD_MISSING,"An unlocked wallet is required to simulate a contract call.");const e=await this.fundWithRequiredCoins(),t=await this.program.account.simulateTransaction(e,{estimateTxDependencies:!1});return $n({funcScopes:this.functionInvocationScopes,callResult:t,isMultiCall:this.isMultiCall})}async dryRun(){const{receipts:e}=await this.getTransactionCost(),t={receipts:e};return $n({funcScopes:this.functionInvocationScopes,callResult:t,isMultiCall:this.isMultiCall})}async get(){let e=await this.getTransactionRequest();e=ne(e),e.maxFee=u(0),e.gasLimit=u(0),e.inputs=e.inputs.filter(d=>d.type!==H.Coin);const t=this.getProvider(),n=this.program.account??ye.generate({provider:t}),s=await t.getBaseAssetId(),a=e.outputs.filter(d=>d.type===k.Coin).map(({amount:d,assetId:h})=>({assetId:String(h),amount:u(d)})).concat(this.requiredCoins),r=n.generateFakeResources(a),o=r.find(d=>d.assetId===s),i=u("1000000000000000");if(o)o.amount=o.amount.add(i);else{const[d]=n.generateFakeResources([{assetId:s,amount:i}]);r.push(d)}e.addResources(r);const{receipts:c}=await t.assembleTx({request:e,feePayerAccount:n});return $n({funcScopes:this.functionInvocationScopes,callResult:{receipts:c},isMultiCall:this.isMultiCall})}getProvider(){return this.program.provider}setDefaultTxParams(e,t,n){const s=he(this.txParameters?.gasLimit)||this.hasCallParamsGasLimit,a=he(this.txParameters?.maxFee),{gasLimit:r,maxFee:o}=e;if(!s)e.gasLimit=t;else if(r.lt(t))throw new l(w.GAS_LIMIT_TOO_LOW,`Gas limit '${r}' is lower than the required: '${t}'.`);if(!a)e.maxFee=n;else if(n.gt(o))throw new l(w.MAX_FEE_TOO_LOW,`Max fee '${o}' is lower than the required: '${n}'.`)}},ki=class extends Li{static{q(this,"FunctionInvocationScope")}func;callParameters;forward;args;constructor(e,t,n){super(e,!1),this.func=t,this.args=n||[],this.setArguments(...n),super.addCall(this)}getCallConfig(){return{func:this.func,program:this.program,callParameters:this.callParameters,txParameters:this.txParameters,forward:this.forward,args:this.args,externalAbis:this.externalAbis}}setArguments(...e){return this.args=e||[],this}callParams(e){if(!this.hasCallParamsGasLimit&&e?.gasLimit!==void 0&&(this.hasCallParamsGasLimit=!0),this.callParameters=e,e?.forward){if(!this.func.attributes.find(t=>t.name==="payable"))throw new l(w.TRANSACTION_ERROR,`The target function ${this.func.name} cannot accept forwarded funds as it's not marked as 'payable'.`);this.forward=vs(e.forward)}return this.setArguments(...this.args),this.updateRequiredCoins(),this}},Lh=class extends Li{static{q(this,"MultiCallInvocationScope")}constructor(e,t){super(e,!0),this.addCalls(t)}addCall(e){return super.addCalls([e])}addCalls(e){return super.addCalls(e)}},tn=class{static{q(this,"Contract")}id;provider;interface;account;functions={};constructor(e,t,n){this.interface=t instanceof be?t:new be(t),this.id=new G(e),n&&"provider"in n?(this.provider=n.provider,this.account=n):(this.provider=n,this.account=null),Object.keys(this.interface.functions).forEach(s=>{const a=this.interface.getFunction(s);Object.defineProperty(this.functions,a.name,{value:this.buildFunction(a),writable:!1})})}buildFunction(e){return(()=>{const t=q((...n)=>new ki(this,e,n),"funcInvocationScopeCreator");return Object.defineProperty(t,"isReadOnly",{value:q(()=>e.isReadOnly(),"value"),writable:!1}),t})()}multiCall(e){return new Lh(this,e)}getBalance(e){return this.provider.getContractBalance(this.id,e)}},kh=Object.defineProperty,Bt=(e,t)=>kh(e,"name",{value:t,configurable:!0}),Uh=class extends ki{static{Bt(this,"ScriptInvocationScope")}scriptRequest;async updateScriptRequest(){this.scriptRequest||await this.buildScriptRequest(),this.transactionRequest.setScript(this.scriptRequest,this.args)}async buildScriptRequest(){const e=this.program.bytes;if(!await this.program.provider.getChain())throw new l(l.CODES.CHAIN_INFO_CACHE_EMPTY,"Provider chain info cache is empty. Please make sure to initialize the `Provider` properly by running `new Provider()`");this.scriptRequest=new Js(e,n=>this.func.encodeArguments(n),()=>[])}},Gh=class extends Oi{static{Bt(this,"AbstractScript")}};(class Ui extends Gh{static{Bt(this,"Script")}bytes;interface;account;script;provider;functions;constructor(t,n,s){super(),this.bytes=v(t),this.interface=new be(n),this.provider=s.provider,this.account=s,this.functions={main:Bt((...a)=>new Uh(this,this.interface.getFunction("main"),a),"main")}}setConfigurableConstants(t){try{if(!Object.keys(this.interface.configurables).length)throw new l(l.CODES.INVALID_CONFIGURABLE_CONSTANTS,"The script does not have configurable constants to be set");Object.entries(t).forEach(([n,s])=>{if(!this.interface.configurables[n])throw new l(l.CODES.CONFIGURABLE_NOT_FOUND,`The script does not have a configurable constant named: '${n}'`);const{offset:a}=this.interface.configurables[n],r=this.interface.encodeConfigurable(n,s);this.bytes.set(r,a)})}catch(n){throw new l(l.CODES.INVALID_CONFIGURABLE_CONSTANTS,`Error setting configurable constants: ${n.message}.`)}return this}deploy(t){return qs({deployer:t,abi:this.interface.jsonAbi,bytecode:this.bytes,loaderInstanceCallback:Bt((n,s)=>new Ui(n,s,this.account),"loaderInstanceCallback")})}});new Js("0x24000000",()=>new Uint8Array(0),()=>{});var $h=Object.defineProperty,ge=(e,t)=>$h(e,"name",{value:t,configurable:!0}),zh=ge(e=>{const{RegId:t,Instruction:n}=Za,s=12,a=e.length,r=We,o=B(e.map(c=>v(c))),i=new Ks(pt(16,t.pc().to_u8()),ke(16,16,s*n.size()),pt(22,t.sp().to_u8()),Pt(19,a),Wn(17,16),Ht(16,0,17,1),ke(16,16,r),ic(19,19,1),cc(19,t.zero().to_u8(),3),Vn(22,22,t.is().to_u8()),qn(22,22,4),Hn(22)).toBytes();return B([i,o])},"getLoaderInstructions"),Wh=ge((e,t)=>{const n=[];for(let s=0,a=0;s<e.length;s+=t,a++){let r=e.slice(s,s+t),o=r.length;o%V!==0&&(r=B([r,new Uint8Array(t-r.length)]),o=r.length),n.push({id:a,size:o,bytecode:r})}return n},"getContractChunks"),Vh=ge(e=>{const n=v(e),s=Qa(n,16384);return Ss(s.map(a=>S(a)))},"getContractRoot"),qh=ge(e=>{const t=new kd;return e.forEach(({key:n,value:s})=>t.update(te(n),s)),t.root},"getContractStorageRoot"),Hh=ge((e,t,n)=>{const s=Vh(v(e));return te(B(["0x4655454C",t,s,n]))},"getContractId"),Ma=ge(e=>S(e.startsWith("0x")?e:`0x${e}`),"hexlifyWithPrefix"),La=.95,jh=class Gi{static{ge(this,"ContractFactory")}bytecode;interface;provider;account;storageSlots;constructor(t,n,s=null,a=[]){this.bytecode=v(t),n instanceof be?this.interface=n:this.interface=new be(n),s&&"provider"in s?(this.provider=s.provider,this.account=s):(this.provider=s,this.account=null),this.storageSlots=a}connect(t){return new Gi(this.bytecode,this.interface,t)}createTransactionRequest(t){const n=(t?.storageSlots??[]).concat(this.storageSlots).map(({key:c,value:d})=>({key:Ma(c),value:Ma(d)})).filter((c,d,h)=>h.findIndex(f=>f.key===c.key)===d).sort(({key:c},{key:d})=>c.localeCompare(d)),s={salt:we(32),...t??{},storageSlots:n};if(!this.provider)throw new l(w.MISSING_PROVIDER,"Cannot create transaction request without provider");const a=t?.bytecode||this.bytecode,r=s.stateRoot||qh(s.storageSlots),o=Hh(a,s.salt,r),i=new as({bytecodeWitnessIndex:0,witnesses:[a],...s});return i.addContractCreatedOutput(o,r),{contractId:o,transactionRequest:i}}async assembleTx(t,n={}){const s=this.getAccount(),{maxFee:a}=n;t.maxFee=u(0);const{gasPrice:r,assembledRequest:o}=await s.provider.assembleTx({request:t,feePayerAccount:s,accountCoinQuantities:[]});return t=await ft({gasPrice:r,provider:s.provider,transactionRequest:o,setMaxFee:a}),t}async deploy(t={}){const n=this.getAccount(),{consensusParameters:s}=await n.provider.getChain(),a=s.contractParameters.contractMaxSize.toNumber();return this.bytecode.length>a?this.deployAsBlobTx(t):this.deployAsCreateTx(t)}async deployAsCreateTx(t={}){const n=this.getAccount(),{consensusParameters:s}=await n.provider.getChain(),a=s.contractParameters.contractMaxSize.toNumber();if(this.bytecode.length>a)throw new l(w.CONTRACT_SIZE_EXCEEDS_LIMIT,"Contract bytecode is too large. Please use `deployAsBlobTx` instead.");const{contractId:r,transactionRequest:o}=await this.prepareDeploy(t),i=await n.sendTransaction(o);return{contractId:r,waitForResult:ge(async()=>{const h=await i.waitForResult();return{contract:new tn(r,this.interface,n),transactionResult:h}},"waitForResult"),waitForPreConfirmation:ge(async()=>{const h=await i.waitForPreConfirmation();return{contract:new tn(r,this.interface,n),transactionResult:h}},"waitForPreConfirmation"),waitForTransactionId:ge(()=>Promise.resolve(i.id),"waitForTransactionId")}}async deployAsBlobTx(t={chunkSizeMultiplier:La}){const n=this.getAccount(),{configurableConstants:s,chunkSizeMultiplier:a}=t;s&&this.setConfigurableConstants(s);const r=await this.getMaxChunkSize(t,a),o=Wh(v(this.bytecode),r).map(E=>{const W=this.blobTransactionRequest({...t,bytecode:E.bytecode});return{...E,transactionRequest:W,blobId:W.blobId}}),i=o.map(({blobId:E})=>E),c=zh(i),{contractId:d,transactionRequest:h}=this.createTransactionRequest({bytecode:c,...t}),f=[...new Set(i)],b=await n.provider.getBlobs(f),g=f.filter(E=>!b.includes(E));let I=u(0);const m=await n.provider.getChain(),y=await n.provider.estimateGasPrice(10),C=m.consensusParameters.feeParameters.gasPriceFactor;for(const{transactionRequest:E,blobId:W}of o){if(g.includes(W)){const ee=E.calculateMinGas(m),Ie=Ve({gasPrice:y,gas:ee,priceFactor:C,tip:E.tip}).add(1);I=I.add(Ie)}const D=h.calculateMinGas(m),Y=Ve({gasPrice:y,gas:D,priceFactor:C,tip:h.tip}).add(1);I=I.add(Y)}if(I.gt(await n.getBalance()))throw new l(w.FUNDS_TOO_LOW,"Insufficient balance to deploy contract.");let T;const A=new Promise(E=>{T=E});return{waitForResult:ge(async()=>{const E=[];for(const{blobId:ee,transactionRequest:Ie}of o)if(!E.includes(ee)&&g.includes(ee)){const Wt=await this.assembleTx(Ie,t);let rt;try{rt=await(await n.sendTransaction(Wt)).waitForResult()}catch(Ln){if(Ln.message.indexOf(`BlobId is already taken ${ee}`)>-1){E.push(ee);continue}throw new l(w.TRANSACTION_FAILED,"Failed to deploy contract chunk")}if(!rt.status||rt.status!==Fo.success)throw new l(w.TRANSACTION_FAILED,"Failed to deploy contract chunk");E.push(ee)}await this.assembleTx(h,t),T(h.getTransactionId(await n.provider.getChainId()));const D=await(await n.sendTransaction(h)).waitForResult();return{contract:new tn(d,this.interface,n),transactionResult:D}},"waitForResult"),contractId:d,waitForTransactionId:ge(()=>A,"waitForTransactionId")}}setConfigurableConstants(t){try{if(!Object.keys(this.interface.configurables).length)throw new l(w.CONFIGURABLE_NOT_FOUND,"Contract does not have configurables to be set");Object.entries(t).forEach(([s,a])=>{if(!this.interface.configurables[s])throw new l(w.CONFIGURABLE_NOT_FOUND,`Contract does not have a configurable named: '${s}'`);const{offset:r}=this.interface.configurables[s],o=this.interface.encodeConfigurable(s,a),i=v(this.bytecode);i.set(o,r),this.bytecode=i})}catch(n){throw new l(w.INVALID_CONFIGURABLE_CONSTANTS,`Error setting configurable constants on contract: ${n.message}.`)}}getAccount(){if(!this.account)throw new l(w.ACCOUNT_REQUIRED,"Account not assigned to contract.");return this.account}async prepareDeploy(t){const{configurableConstants:n}=t;n&&this.setConfigurableConstants(n);const{contractId:s,transactionRequest:a}=this.createTransactionRequest(t);return await this.assembleTx(a,t),{contractId:s,transactionRequest:a}}blobTransactionRequest(t){const{bytecode:n}=t;return new hn({blobId:Te(n),witnessIndex:0,witnesses:[n],...t})}async getMaxChunkSize(t,n=La){if(n<0||n>1)throw new l(w.INVALID_CHUNK_SIZE_MULTIPLIER,"Chunk size multiplier must be between 0 and 1");const s=this.getAccount(),{consensusParameters:a}=await s.provider.getChain(),r=a.contractParameters.contractMaxSize.toNumber(),o=a.txParameters.maxSize.toNumber(),i=64e3,c=o<r?o:r,d=c<i?c:i,h=this.blobTransactionRequest({...t,bytecode:we(32)}).addResources(s.generateFakeResources([{assetId:await s.provider.getBaseAssetId(),amount:u(1)}])),f=(d-h.byteLength()-V)*n;return Math.round(f/V)*V}},Kh=Object.defineProperty,$i=(e,t)=>Kh(e,"name",{value:t,configurable:!0}),ka={programType:"contract",specVersion:"1",encodingVersion:"1",concreteTypes:[{type:"()",concreteTypeId:"2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"},{type:"enum standards::src5::AccessError",concreteTypeId:"3f702ea3351c9c1ece2b84048006c8034a24cbc2bad2e740d0412b4172951d3d",metadataTypeId:1},{type:"enum standards::src5::State",concreteTypeId:"192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c",metadataTypeId:2},{type:"enum std::option::Option<struct std::contract_id::ContractId>",concreteTypeId:"0d79387ad3bacdc3b7aad9da3a96f4ce60d9a1b6002df254069ad95a3931d5c8",metadataTypeId:4,typeArguments:["29c10735d33b5159f0c71ee1dbd17b36a3e69e41f00fab0d42e1bd9f428d8a54"]},{type:"enum sway_libs::ownership::errors::InitializationError",concreteTypeId:"1dfe7feadc1d9667a4351761230f948744068a090fe91b1bc6763a90ed5d3893",metadataTypeId:5},{type:"enum sway_libs::upgradability::errors::SetProxyOwnerError",concreteTypeId:"3c6e90ae504df6aad8b34a93ba77dc62623e00b777eecacfa034a8ac6e890c74",metadataTypeId:6},{type:"str",concreteTypeId:"8c25cb3686462e9a86d2883c5688a22fe738b0bbc85f458d2d2b5f3f667c6d5a"},{type:"struct std::contract_id::ContractId",concreteTypeId:"29c10735d33b5159f0c71ee1dbd17b36a3e69e41f00fab0d42e1bd9f428d8a54",metadataTypeId:9},{type:"struct sway_libs::upgradability::events::ProxyOwnerSet",concreteTypeId:"96dd838b44f99d8ccae2a7948137ab6256c48ca4abc6168abc880de07fba7247",metadataTypeId:10},{type:"struct sway_libs::upgradability::events::ProxyTargetSet",concreteTypeId:"1ddc0adda1270a016c08ffd614f29f599b4725407c8954c8b960bdf651a9a6c8",metadataTypeId:11}],metadataTypes:[{type:"b256",metadataTypeId:0},{type:"enum standards::src5::AccessError",metadataTypeId:1,components:[{name:"NotOwner",typeId:"2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"}]},{type:"enum standards::src5::State",metadataTypeId:2,components:[{name:"Uninitialized",typeId:"2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"},{name:"Initialized",typeId:3},{name:"Revoked",typeId:"2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"}]},{type:"enum std::identity::Identity",metadataTypeId:3,components:[{name:"Address",typeId:8},{name:"ContractId",typeId:9}]},{type:"enum std::option::Option",metadataTypeId:4,components:[{name:"None",typeId:"2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"},{name:"Some",typeId:7}],typeParameters:[7]},{type:"enum sway_libs::ownership::errors::InitializationError",metadataTypeId:5,components:[{name:"CannotReinitialized",typeId:"2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"}]},{type:"enum sway_libs::upgradability::errors::SetProxyOwnerError",metadataTypeId:6,components:[{name:"CannotUninitialize",typeId:"2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d"}]},{type:"generic T",metadataTypeId:7},{type:"struct std::address::Address",metadataTypeId:8,components:[{name:"bits",typeId:0}]},{type:"struct std::contract_id::ContractId",metadataTypeId:9,components:[{name:"bits",typeId:0}]},{type:"struct sway_libs::upgradability::events::ProxyOwnerSet",metadataTypeId:10,components:[{name:"new_proxy_owner",typeId:2}]},{type:"struct sway_libs::upgradability::events::ProxyTargetSet",metadataTypeId:11,components:[{name:"new_target",typeId:9}]}],functions:[{inputs:[],name:"proxy_target",output:"0d79387ad3bacdc3b7aad9da3a96f4ce60d9a1b6002df254069ad95a3931d5c8",attributes:[{name:"doc-comment",arguments:[" Returns the target contract of the proxy contract."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Returns"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" * [Option<ContractId>] - The new proxy contract to which all fallback calls will be passed or `None`."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Number of Storage Accesses"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" * Reads: `1`"]},{name:"storage",arguments:["read"]}]},{inputs:[{name:"new_target",concreteTypeId:"29c10735d33b5159f0c71ee1dbd17b36a3e69e41f00fab0d42e1bd9f428d8a54"}],name:"set_proxy_target",output:"2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d",attributes:[{name:"doc-comment",arguments:[" Change the target contract of the proxy contract."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Additional Information"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" This method can only be called by the `proxy_owner`."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Arguments"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" * `new_target`: [ContractId] - The new proxy contract to which all fallback calls will be passed."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Reverts"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" * When not called by `proxy_owner`."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Number of Storage Accesses"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" * Reads: `1`"]},{name:"doc-comment",arguments:[" * Write: `1`"]},{name:"storage",arguments:["read","write"]}]},{inputs:[],name:"proxy_owner",output:"192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c",attributes:[{name:"doc-comment",arguments:[" Returns the owner of the proxy contract."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Returns"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" * [State] - Represents the state of ownership for this contract."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Number of Storage Accesses"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" * Reads: `1`"]},{name:"storage",arguments:["read"]}]},{inputs:[],name:"initialize_proxy",output:"2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d",attributes:[{name:"doc-comment",arguments:[" Initializes the proxy contract."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Additional Information"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" This method sets the storage values using the values of the configurable constants `INITIAL_TARGET` and `INITIAL_OWNER`."]},{name:"doc-comment",arguments:[" This then allows methods that write to storage to be called."]},{name:"doc-comment",arguments:[" This method can only be called once."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Reverts"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" * When `storage::SRC14.proxy_owner` is not [State::Uninitialized]."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Number of Storage Accesses"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" * Writes: `2`"]},{name:"storage",arguments:["write"]}]},{inputs:[{name:"new_proxy_owner",concreteTypeId:"192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c"}],name:"set_proxy_owner",output:"2e38e77b22c314a449e91fafed92a43826ac6aa403ae6a8acb6cf58239fbaf5d",attributes:[{name:"doc-comment",arguments:[" Changes proxy ownership to the passed State."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Additional Information"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" This method can be used to transfer ownership between Identities or to revoke ownership."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Arguments"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" * `new_proxy_owner`: [State] - The new state of the proxy ownership."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Reverts"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" * When the sender is not the current proxy owner."]},{name:"doc-comment",arguments:[" * When the new state of the proxy ownership is [State::Uninitialized]."]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" # Number of Storage Accesses"]},{name:"doc-comment",arguments:[""]},{name:"doc-comment",arguments:[" * Reads: `1`"]},{name:"doc-comment",arguments:[" * Writes: `1`"]},{name:"storage",arguments:["write"]}]}],loggedTypes:[{logId:"4571204900286667806",concreteTypeId:"3f702ea3351c9c1ece2b84048006c8034a24cbc2bad2e740d0412b4172951d3d"},{logId:"2151606668983994881",concreteTypeId:"1ddc0adda1270a016c08ffd614f29f599b4725407c8954c8b960bdf651a9a6c8"},{logId:"2161305517876418151",concreteTypeId:"1dfe7feadc1d9667a4351761230f948744068a090fe91b1bc6763a90ed5d3893"},{logId:"4354576968059844266",concreteTypeId:"3c6e90ae504df6aad8b34a93ba77dc62623e00b777eecacfa034a8ac6e890c74"},{logId:"10870989709723147660",concreteTypeId:"96dd838b44f99d8ccae2a7948137ab6256c48ca4abc6168abc880de07fba7247"},{logId:"10098701174489624218",concreteTypeId:"8c25cb3686462e9a86d2883c5688a22fe738b0bbc85f458d2d2b5f3f667c6d5a"}],messagesTypes:[],configurables:[{name:"INITIAL_TARGET",concreteTypeId:"0d79387ad3bacdc3b7aad9da3a96f4ce60d9a1b6002df254069ad95a3931d5c8",offset:13368},{name:"INITIAL_OWNER",concreteTypeId:"192bc7098e2fe60635a9918afb563e4e5419d386da2bdbf0d716b4bc8549802c",offset:13320}]},Jh=[{key:"7bb458adc1d118713319a5baa00a2d049dd64d2916477d2688d76970c898cd55",value:"0000000000000000000000000000000000000000000000000000000000000000"},{key:"7bb458adc1d118713319a5baa00a2d049dd64d2916477d2688d76970c898cd56",value:"0000000000000000000000000000000000000000000000000000000000000000"},{key:"bb79927b15d9259ea316f2ecb2297d6cc8851888a98278c0a2e03e1a091ea754",value:"0000000000000000000000000000000000000000000000000000000000000000"},{key:"bb79927b15d9259ea316f2ecb2297d6cc8851888a98278c0a2e03e1a091ea755",value:"0000000000000000000000000000000000000000000000000000000000000000"}],Ua=class extends tn{static{$i(this,"Src14OwnedProxy")}static abi=ka;static storageSlots=Jh;constructor(e,t){super(e,ka,t)}},Ga=mc("H4sIAAAAAAAAA9Vbe3Abx3lfgCAFvayz+TAFSjaUUjJkRwosUQ4ly9IhIATSEM2DSVpUGBhg64c0cSyIlVQ5tsccN001aSZlHcdlO06GrtOp6z4GAB+C7T7YR2bUiTtlZhxbTeMWmiatFAst60YZqm6j/r5v93DHw4GOJ84f0QznFne73+5+j9/32FVgISxOCOEV/K/Dn7o259GuXRO/JcSQ8c6CML4nwkZJF8HFnWLovZLXeK/kOyG89+JbGN9C+BZe+q2uEfRE4LIBGiv1VHThdi0i5gJdGTHa7TW0WNNY4JLmoFfXE4jPi3T5ep/q112j337Vr8WIF3PV373nAol5YfTls6OG8Id6m9E3+DG0tVB5F96/onG7b0akejWh9XaMpWNhYcSnL44exPv49JzLnNtoTtDMpMvaR0FvmxHPaaPd6B/rGDMSxRCP7WmaMxJ5I10Wt47qYg2etxnR/CJ/i7Tj29nuSr/42Tlux3yYLygC36+aMxiIzotTuuck+LeD+If9hoxEIQS6MdDX8DxgRAudNvrzNvql96Hvl/TFJdDfaaPfDbo9oL8az7tBf8hGf8GiXxTL0/cuKPpPg36Hjf4R0O1V678H9E9b9IuaRX+m9X3on1f0HwD9XTb6Z0A3Cfrr8LwX9Ccs+jOWnOIzkm+16c8p+juXvl/9f0Z0GnonHP19CeqfigmR6hGeVER4jb5Z7FH7a+jL32Atf2tEp84ELoUxV9XYQzQWOnVO6pRvzIi+AhugdTehPVtpV8/r/TyPTcxWdIv246CfIf3dHNGEES0GjXihRHSq9+z5slrHBOYLy3XkJ7nN6zg7brar17F6c0AXYjP+lr5fNWW+x/4nqsc1PK3mHLLmLGatOaddxtSxboHPsGHF6/7Zc6MDGJNs1o347CJ4/i/pcrgEvl/AvOcCl3Teb+CCk5b/tmq5zVyE3P4cNP4C4/8S40+7y63uklr7GUtuReKXktuMfxm5tSq5ST10lVvdu6bcoON3KB0PGokpjTAq8H1nf8/vME4lcoRlQann+TFux9rnHLTfgQ2QzuCbbw57PgJcDIZ660lOYab/PejIBez77aq1vyH3nfdjfDePjxaL3I5gzmh+Pn1Z22P0Cr+kuRnYOTuEdjfhMeQziXYoFKsXkq9OPVxxCnbrH+3C2Eg75Dnt5geO0V5TPeBNr+ZJxTTowNkh6EAwlKzXoaunIb//hA4sQJb/ZcSnFqUO0J6ctPyHXXRgHuNeBY3XoAN/Bj08X0MHjigd6LZ0oPCSKXfIbX0qnhtMJXL3dXh891q2MA0ZOmmt/JaiFcR48If1qZPb0haOuNjCtiW2kBTe1CDah9U+0oXiaAbjUy0C6/A1xjRxqktsT0VzhxojQge+ebHGwB28pkLRiAi/EX8lyHyMgY/xmUnwYBp8nEmX9VkjMW0ELpLukS059c/7lotMNJtMwqD1b6D17+DtRcgEOFRLJit+6JQJYgoN6wG+G/l0OVOAXKbAk87ARYll1bbtnXKRaxFzn8U68BSvYDywwU2u3neVLM7bbDtj2fb0Ym3b9mxStl3xN9W27X3PtO2vCHHzc34zXhKTgeikCMTHRSAxJgJ9JWH052CP5h6dcZgI8B4jAnGOWIv1HjGiuU6JD851iTbqC7sKh8o+yCOX5XZ02mr3+PTAD4V4htZxNSwmsK7fxvruXhS0zhXmOuUasb5ESaTB38AVzHc1aPZfofo/Ze3Lc5HHDGNfh0qw+6q1fZL40QjdOdUt7sZTx3M1/Li3MdJEfthzB2JKrHMB6/RChjch1jpjrhnjd5PfAu40utCOUkzY2BsUpw6KGxt7gkRb0kvkzmHMesR2uuRx2Dm2i2XZB5s08TESlLgWoXgyn8EaQ6HedoqhbwC9bPqyuA7vgzXohVkGhLtl4CbRonZ0Ghhs0TIiGvkO2D3Fl9inTvtsIswtcjvG89WDHzrmg83ivfKf/P1wE2SSgRzB96uGKZenlFwq+iblWJL40RMkDBEUN2u9u0Q6Aru4gtjoqubUA7u+ZphGAnKFrpKtMW/KhPM5ndtxxNrqvRZDPM5xCPhJ+A7d4yfpHeaC3mVc9M4+H3x/lX1ka9nHSSH+2GYfrZgXtrhUP9AnyrqXhO4ZogUYqQMjpX4A16EfKzEHYgCao4r+J1ievGfSDciN2tEZWtcEyzPZZMoqCFn5+H0XvWcbPMftSJfVtmxwwYUXdVWyw94CV/BnyanOaa/gm2b2Z9wq+8YC0VxlLObSbONN+91vG29YfAcNwjXob+CdXLV+98Fe+pEfDaAP4jHCeEefWwL9ZI+78AcdMwTZ5QbYWJhzM9gYYbJjzK2Krr4M3U0c//RDt7hPvVsfznu2JjuMwBWd9m3YcGv/B+CbZxm+fYh8rzsXOITx/ZBzdOHjMgbMXwQtituADYiTONajGCxvWHEb7LYqbhMPKfzvlvg/NcZtxv9Cd6Udz8MnuuUHvqwt1pHzRwuUE9A4Fz/oOy79YIH8oBmPIp6nfMvN54tBRf+IlQtMEQ6qXGAqo74Beym2yl2PmOYG+t3WA9w7KPxtPR1jW7pBuzsLbJ7K7O7xzcN3NJDfgO3BZxTO23zGdYQHsG/KNf1tsQ5diyHeTMA+D5IdYr0xxLDURvxsHwteE35hXe2ob+SGVSylfFQ+KOOoKRm7ESaTXQ8SxhmQOWR6VXfqnN3WupdiXJblz3FUuV6H7/Nh3SEzPgbGdIf6pqFPYdKnbhfa12x+2MLPYdCGL8Yawbcm4l9I62mnusTN6ll/s3z61qea5jAfeHRC534x/KZ+8ll/M56w35zpI7EmrLWDeEE1CenfIANT9g6575R6Aru1dFnlOFV9Q8ofS9/C+UqecAO8QJ6RyMs19LBvzr7Y63uB7IJ1BjqK71m8H8f7SV4b6xJ8bDRntRO5jLWOnMyfUD8A35vS5Wwzy/0wyZL9KzC64l+vKX6vs8lSt+Mm4T/+6vHXAH+0gv2gigWYZ3GSo0Zy1G24tK46nhLjLn7wNHSklbARa2wNleFT4oypreyDh3MNqUO5FbAZ8lF+LdksmpMxHT7PQ/4J77xtg4NiywCYvPEBPTCUFVryAT2dhO/W0R9xGPvDcmYlYvBVWP9qrL+V6UfY32e4jbwO/VspXlE+fdzmx8wYxM4jpe+kiz5h2W+uFXF6Hb3Dk/kGGWFfLKMw+NYaSkyT/mH+9jmFp9D/Cp6afLPbFvI1Sx6Yw+A1S50l2hSbEF61ks6m+nL1sGWN/A7yFr/Rq/vBY9QVKZ/B3rm21GXV8qTsjnz4PsVjs2H/PNktchCOSRx5xXa2jzTHyeFQClg1nA8D47YcBz4Bo6j+cx68HKY8H+8fOt5NeZFpu2RDs0XLhmaGpM06/XHdE7LOCrsxx/WofJ/G9SAOYgwlGzpLORRjOHKjuxzr/W/269H8ONa0g2p4JmZSXNAC3mLN7ci9QqgD6Oa3VDRfrzB3DfD3DNqUI9hy2akh7O3T+DuGuuWQGVdBz9eCb7rE5yL5FunH4lN+zD+i1i1tn8ZR/MZx91mKq8kPUCyHmtL0S2bu6tjPd5SPJblCR4qEm5r0sVMU33Ebaxamz6DaO35/Vu1hFdqP2b7V0TfKeRojPs7XtaSuI+6MEW2su5KfgietDppPKJoRtB930HzCheYnZT7suq+vK99MMlD58BTlHKrOkfM76J+20Yf/RV32skiCp1TXMWVxI+Regoz2jsQ+EYHeTaBWAd63YJ4Z5LCuddl/VjUuo9KXfDS1Y1vw3qIPmYVtMtuFvRVr7O0zam+qpk97m6Y4w9wb9rGEr19SfKV9ZbCvg1h7ybGvIvb1ceyrDt9O2/bVWmNfL6l9Bd33ZdG37ws6QLVaVR8iG5mi2HCJjQS6eK2eQBfXfr5CY1CDq9iZrG25+doKX6geq+I9qrHPEu+xlgbCINTV3Hy6937l08flfqjvzEVuR4gPs5W9uceagmurWPfDdMYBXsbB5wTbYWXdUxR78t4hkwUlo1a0R13wYFzZ/GnL5gtk89C7Qg7P+4xelddzjq/wS557vGTm31jXKkULOIrzoMvaR4EZ5C/8CjMqfRn3VIwI7CLd4pgW63tPrU/Fi9OaWhvFKXJvsYzM/3mfM7LOETlB9TiV5z/A8bYL3zg+MvdPeSTe3YQzBML8f8J4lcdW1VPvUzVdqj2a9k28NuuYbYgbsqhjHqc6Jn5vIL5K3PCg5kQ6ZWG3ev/oM+SrKvGRx4yPbPm8p1TxxxTj0t7gD+Fbw1bcD9/UJTI1cHOD+t2EdovJV9s3wXqP8yz6bsMkE6c2mO9UP9gJ8yxK80q54BnTwvjzq9hQ+rVIkORO+sfxKugYKh9Y41jHLer3BrQ/4lg/favYKNeQQEvOi2dMC8l5cQ5jxcYUb1AOpM6uqmLkAGHJMrRs8a06H6hNawXRknENZGXlFmY9omasW6lxmTEu5nghOh1UMY5bfGvPexdteW+nzHuR61p5r8opeQ+o/9TOe08q3bblvaRPZt57xJb3XqxhUwWXvDdXO+8VXHems1Rb3gvfUzPv3eeS99r0H3jzwfLecSvvzVPOgTOjwiL22WnLe7nu6ZL3EnaZeS/VGSnvrYwFvU5uSz1PO/LeTpX3Up1c1iIJt6y8d/GnyE3DP2FuGv4wc1PozuhPmpui75M/T7lpla2q/MXFLt1qjr73qzkGoiUxgjqqqunX2+uqhLXQQ8Za9b1Bfa/47JEuTx31AY16uS7hrJPZ68LIoaz9OGq07ZRjNCd9c5TrNsrntpGIF/VHrj0G8dTxbAIfyBdQzkE1I1lb70esSfkdxhEekm+C7TRQX+SEK+zfIXuq4aOG2UX7Ixqo+WrIXbV6/qbqm1Sz5n7JDrOfhj5ezFfH3xQ97hPrYvxFP8qBSX/pnopZJxizycsNkxEPLJFziDCZ6o9LbRc1AZsOgG7IRQ/sdHE/pRrrHTWM4PI1DJu9Uz5LfKT4IQnMg79ifGWsz827nXdDrgXyTWwbZR5Ddwh4jPO8GH1zCmMXuD/OlEF30rRj51nmSeF73XYW63IXIj+vvpmY7Acmr6yNyfn53T0dhDcW3vYhRxqi857YmDwPBy7E8/N3xnzjsv6/xH7NuokNL71WTT4NvBy24iclX4opvmCLmW6kNvqQjo8tjY8RE1BthfYWz1GM6a3lr8CbF1zOZo+RDgHD6O6BjI8SeaqPUB0I/g9nNHxuDJrV9Gaqz40R/w2QLtSTn2lQe6Fza2o7zq1zYfY7/QUaI8+a+/OoUwW3wj5vBTbehvkn5fzI/6rn/3b1/MDqyrk17jOUg3tA607Q2gtaiBNqnVuLAy68CdnWaJ2H96MuUw5uAd1bQBe5W+6MPMt2XeOPXdZI9T5zjROgtRO0OkBrF2jBZmqucaPLGtdRrGDTgSG5Fjf51/P5tn18OqWJdCroSaegN1ey0F3o5tWM0/fYdFfI8+Cl9ctWaz/QQaplRsxaJp+VGdymPGA4twq1TIrp11AdXIv59OZYM/sXrmXCj7QNDuiqlimolskx1KcI42JzqGsKbiebKXYIaoj/if+obV6P2uYNqG020jm6rbZJd1a4tsn+2HxPbVqTdX6J89ZKrdPct73+uMRPAQNCzrMu8PcA+atUMixSg2FPqjfstdmzXe9x11BHHdbAXb3wGtDSLJlV0fwSywz+DndE5F2IQzncxQuvBY3rsF/IP4fzMvjtqrimvk+dWfOZ3zL+x4zpbBjvteIMC+NxT4vxmvDTxHjcBXHDeO9tDoynOLgGxnu3qhxW9pcYz3dE3THe+zUXjKe43sT40gfE+JILxo8B48MK4zEHY3zJwnjwZ5nzefhI1IoRb8UXdmsxDZiawx0g5z5WrKZarPTtFK9TjV5bCb1sw3MV363j+jR/O8/9UDfHeuncGvEI67c6l8N5bDVebFe1Kds5HuxT3SujGo/7fTTRoPwY6tmV2M3tTF/FEuy/KI7gengYdxICB6lgnRTPoha8Q4d8dKFvge6nN8I29KwIRurEvYhF78Y7GW9U3VWwxxvFKswZ5lhdCx0GD/rhryyf8wvKz9yv2g7bk/dFlsqhoYPthM8ouIZR4jbH9nxWQDhBcTvdeeUzC2DYuhTOyimnQx95V1jyl843TJmNm++hf42UE9HdaIV5VNOzMC/ZpW8Br0IbB0RggDFP3kdEvUiLDQicZzTzfWfUAVDLaWL68EvAP5ozByxpAR7cqO5KkK2a/oDupgL/2EaoLiTfo61s0vyG8wK33KgB90QqOa6qL+H+oFVf2oy9bcKaPkL1JZVPtqraxQTnTYy9aC+5LwKZLn+2pGIkyBr662I737HbDseflNPLGgV8WNVZkh3bcFcLdBGrVmORb4fCLcRjzD+ZS+B+OOfV0v4kJsD+3M5YQOPv+F6KvLO3AxiwhzAglVi4U+sJ4mxqYa/WG55L9S/chXrbHPA8C6wJhgabxzDXDUbMCPHv2OYxo0sPc/45BOzsGRwzDuFeOsWe6CvnBoOXYuMlFQdiPO7IXxZtqs4J3nfNGd068A41mMqdzgLdtwe+bXa904la4OdULbIFtRO6B9MFvqk7V1V9v6l0hWogpq5U7kBDV7ZDV4LQlU32WiSwFHfWKjhj6oJNXnXynBFxskM33yS9xJrWgkeEj3TGD/mg3rSsfOpvN+WjZPQpyGifxGlVVyNb7kPewPUAxlnEjqBVuVvr3Lvfo7CW7sJDVoQFU6Sf8Hmw1XjhTKWdKJCv4bW6+07PBcddbr5H6ND/keq71Pg/BZW71HRfP9iLOOEeYEKftG/3u9Sof2ypvm+Zp9pEJ2jsxvg9GN/tdt8S6zDv0VIOp2Su7l5KmX8MMm+DzDfwPVqpS83QJdJNA7pUuQPm0GM+h7DO4/iOlTqDWwiD5nrQDCzVI+iJFbsu55P31/bJ/oWfpU+GbDln+qA+GePeruWTf1b/sqPHTj+WPjEy+vCD9N+CxC8/eCJtf/f49NCf/NW3Wo/vXP/7r06u2ub76pu9W1viT24589bR7LmJvx+UfY/9yqMPjjK9o48ePXF05JGjn31QkrHoyT4bv7vq7RduWeV5nf8J7/7s9hd3bXj+pmv8T4jXHnvm8eZ/3Py1F1vevVzY+uQj536t9cwfPn167vdK+wIrb/qDgQMjjzzyiyO/9OnY6Oix0T17BniR9xw70S+XL764+Zt3fP7A9t/N/+ZE57Nf/vrLvkvPvzZ7cNOb//qZYwfLl18+uv/V/5j8h4eu+8Ku/xk+uePbe3/06xf23ZVr+sG7/m8Uv9HxR0fvemvl2vu9D6f3bfzxUz/47sbnHn7u7V/9ja6rX/3i3kfH/9To/dHLkms7/1c+d7yuns+r50H5vF19335ePtvfkM8W9X3lEfn0qff1n1PPDvV8Vj7rJuXT88b/AzdExjYINgAA");(class zi extends jh{static{$i(this,"Src14OwnedProxyFactory")}static bytecode=Ga;constructor(t){super(Ga,Ua.abi,t,Ua.storageSlots)}static deploy(t,n={}){return new zi(t).deploy(n)}});var Yh=Object.defineProperty,Xh=(e,t)=>Yh(e,"name",{value:t,configurable:!0});function Zh(e){return e}Xh(Zh,"createConfig");const op="FuelBackgroundScript",ip="FuelPopUpScript",cp="FuelVaultScript",dp="FuelConnectorScript",up="FuelContentScript",lp="message";var Qh=(e=>(e.ping="ping",e.uiEvent="uiEvent",e.event="event",e.request="request",e.response="response",e.removeConnection="removeConnection",e))(Qh||{}),je={},Be={},xt={},$a;function Mn(){return $a||($a=1,function(e){var t=xt&&xt.__extends||function(){var g=function(I,m){return g=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(y,C){y.__proto__=C}||function(y,C){for(var T in C)Object.prototype.hasOwnProperty.call(C,T)&&(y[T]=C[T])},g(I,m)};return function(I,m){if(typeof m!="function"&&m!==null)throw new TypeError("Class extends value "+String(m)+" is not a constructor or null");g(I,m);function y(){this.constructor=I}I.prototype=m===null?Object.create(m):(y.prototype=m.prototype,new y)}}();Object.defineProperty(e,"__esModule",{value:!0}),e.createJSONRPCNotification=e.createJSONRPCRequest=e.createJSONRPCSuccessResponse=e.createJSONRPCErrorResponse=e.JSONRPCErrorCode=e.JSONRPCErrorException=e.isJSONRPCResponses=e.isJSONRPCResponse=e.isJSONRPCRequests=e.isJSONRPCRequest=e.isJSONRPCID=e.JSONRPC=void 0,e.JSONRPC="2.0";var n=function(g){return typeof g=="string"||typeof g=="number"||g===null};e.isJSONRPCID=n;var s=function(g){return g.jsonrpc===e.JSONRPC&&g.method!==void 0&&g.result===void 0&&g.error===void 0};e.isJSONRPCRequest=s;var a=function(g){return Array.isArray(g)&&g.every(e.isJSONRPCRequest)};e.isJSONRPCRequests=a;var r=function(g){return g.jsonrpc===e.JSONRPC&&g.id!==void 0&&(g.result!==void 0||g.error!==void 0)};e.isJSONRPCResponse=r;var o=function(g){return Array.isArray(g)&&g.every(e.isJSONRPCResponse)};e.isJSONRPCResponses=o;var i=function(g,I,m){var y={code:g,message:I};return m!=null&&(y.data=m),y},c=function(g){t(I,g);function I(m,y,C){var T=g.call(this,m)||this;return Object.setPrototypeOf(T,I.prototype),T.code=y,T.data=C,T}return I.prototype.toObject=function(){return i(this.code,this.message,this.data)},I}(Error);e.JSONRPCErrorException=c,function(g){g[g.ParseError=-32700]="ParseError",g[g.InvalidRequest=-32600]="InvalidRequest",g[g.MethodNotFound=-32601]="MethodNotFound",g[g.InvalidParams=-32602]="InvalidParams",g[g.InternalError=-32603]="InternalError"}(e.JSONRPCErrorCode||(e.JSONRPCErrorCode={}));var d=function(g,I,m,y){return{jsonrpc:e.JSONRPC,id:g,error:i(I,m,y)}};e.createJSONRPCErrorResponse=d;var h=function(g,I){return{jsonrpc:e.JSONRPC,id:g,result:I??null}};e.createJSONRPCSuccessResponse=h;var f=function(g,I,m){return{jsonrpc:e.JSONRPC,id:g,method:I,params:m}};e.createJSONRPCRequest=f;var b=function(g,I){return{jsonrpc:e.JSONRPC,method:g,params:I}};e.createJSONRPCNotification=b}(xt)),xt}var At={},za;function Wi(){return za||(za=1,Object.defineProperty(At,"__esModule",{value:!0}),At.DefaultErrorCode=void 0,At.DefaultErrorCode=0),At}var Wa;function ep(){if(Wa)return Be;Wa=1;var e=Be&&Be.__awaiter||function(o,i,c,d){function h(f){return f instanceof c?f:new c(function(b){b(f)})}return new(c||(c=Promise))(function(f,b){function g(y){try{m(d.next(y))}catch(C){b(C)}}function I(y){try{m(d.throw(y))}catch(C){b(C)}}function m(y){y.done?f(y.value):h(y.value).then(g,I)}m((d=d.apply(o,i||[])).next())})},t=Be&&Be.__generator||function(o,i){var c={label:0,sent:function(){if(f[0]&1)throw f[1];return f[1]},trys:[],ops:[]},d,h,f,b;return b={next:g(0),throw:g(1),return:g(2)},typeof Symbol=="function"&&(b[Symbol.iterator]=function(){return this}),b;function g(m){return function(y){return I([m,y])}}function I(m){if(d)throw new TypeError("Generator is already executing.");for(;b&&(b=0,m[0]&&(c=0)),c;)try{if(d=1,h&&(f=m[0]&2?h.return:m[0]?h.throw||((f=h.return)&&f.call(h),0):h.next)&&!(f=f.call(h,m[1])).done)return f;switch(h=0,f&&(m=[m[0]&2,f.value]),m[0]){case 0:case 1:f=m;break;case 4:return c.label++,{value:m[1],done:!1};case 5:c.label++,h=m[1],m=[0];continue;case 7:m=c.ops.pop(),c.trys.pop();continue;default:if(f=c.trys,!(f=f.length>0&&f[f.length-1])&&(m[0]===6||m[0]===2)){c=0;continue}if(m[0]===3&&(!f||m[1]>f[0]&&m[1]<f[3])){c.label=m[1];break}if(m[0]===6&&c.label<f[1]){c.label=f[1],f=m;break}if(f&&c.label<f[2]){c.label=f[2],c.ops.push(m);break}f[2]&&c.ops.pop(),c.trys.pop();continue}m=i.call(o,c)}catch(y){m=[6,y],h=0}finally{d=f=0}if(m[0]&5)throw m[1];return{value:m[0]?m[1]:void 0,done:!0}}};Object.defineProperty(Be,"__esModule",{value:!0}),Be.JSONRPCClient=void 0;var n=Mn(),s=Wi(),a=function(){function o(i,c){this._send=i,this.createID=c,this.idToResolveMap=new Map,this.id=0}return o.prototype._createID=function(){return this.createID?this.createID():++this.id},o.prototype.timeout=function(i,c){var d=this;c===void 0&&(c=function(b){return(0,n.createJSONRPCErrorResponse)(b,s.DefaultErrorCode,"Request timeout")});var h=function(b,g){var I=setTimeout(function(){b.forEach(function(m){var y=d.idToResolveMap.get(m);y&&(d.idToResolveMap.delete(m),y(c(m)))})},i);return g().then(function(m){return clearTimeout(I),m},function(m){return clearTimeout(I),Promise.reject(m)})},f=function(b,g){var I=(Array.isArray(b)?b:[b]).map(function(m){return m.id}).filter(r);return h(I,function(){return d.requestAdvanced(b,g)})};return{request:function(b,g,I){var m=d._createID();return h([m],function(){return d.requestWithID(b,g,I,m)})},requestAdvanced:function(b,g){return f(b,g)}}},o.prototype.request=function(i,c,d){return this.requestWithID(i,c,d,this._createID())},o.prototype.requestWithID=function(i,c,d,h){return e(this,void 0,void 0,function(){var f,b;return t(this,function(g){switch(g.label){case 0:return f=(0,n.createJSONRPCRequest)(h,i,c),[4,this.requestAdvanced(f,d)];case 1:return b=g.sent(),b.result!==void 0&&!b.error?[2,b.result]:b.result===void 0&&b.error?[2,Promise.reject(new n.JSONRPCErrorException(b.error.message,b.error.code,b.error.data))]:[2,Promise.reject(new Error("An unexpected error occurred"))]}})})},o.prototype.requestAdvanced=function(i,c){var d=this,h=Array.isArray(i);Array.isArray(i)||(i=[i]);var f=i.filter(function(I){return r(I.id)}),b=f.map(function(I){return new Promise(function(m){return d.idToResolveMap.set(I.id,m)})}),g=Promise.all(b).then(function(I){return h||!I.length?I:I[0]});return this.send(h?i:i[0],c).then(function(){return g},function(I){return f.forEach(function(m){d.receive((0,n.createJSONRPCErrorResponse)(m.id,s.DefaultErrorCode,I&&I.message||"Failed to send a request"))}),g})},o.prototype.notify=function(i,c,d){var h=(0,n.createJSONRPCNotification)(i,c);this.send(h,d).then(void 0,function(){})},o.prototype.send=function(i,c){return e(this,void 0,void 0,function(){return t(this,function(d){return[2,this._send(i,c)]})})},o.prototype.rejectAllPendingRequests=function(i){this.idToResolveMap.forEach(function(c,d){return c((0,n.createJSONRPCErrorResponse)(d,s.DefaultErrorCode,i))}),this.idToResolveMap.clear()},o.prototype.receive=function(i){var c=this;Array.isArray(i)||(i=[i]),i.forEach(function(d){var h=c.idToResolveMap.get(d.id);h&&(c.idToResolveMap.delete(d.id),h(d))})},o}();Be.JSONRPCClient=a;var r=function(o){return o!=null};return Be}var zn={},Va;function tp(){return Va||(Va=1,Object.defineProperty(zn,"__esModule",{value:!0})),zn}var ue={},qa;function np(){if(qa)return ue;qa=1;var e=ue&&ue.__assign||function(){return e=Object.assign||function(m){for(var y,C=1,T=arguments.length;C<T;C++){y=arguments[C];for(var A in y)Object.prototype.hasOwnProperty.call(y,A)&&(m[A]=y[A])}return m},e.apply(this,arguments)},t=ue&&ue.__awaiter||function(m,y,C,T){function A(R){return R instanceof C?R:new C(function(M){M(R)})}return new(C||(C=Promise))(function(R,M){function E(Y){try{D(T.next(Y))}catch(ee){M(ee)}}function W(Y){try{D(T.throw(Y))}catch(ee){M(ee)}}function D(Y){Y.done?R(Y.value):A(Y.value).then(E,W)}D((T=T.apply(m,y||[])).next())})},n=ue&&ue.__generator||function(m,y){var C={label:0,sent:function(){if(R[0]&1)throw R[1];return R[1]},trys:[],ops:[]},T,A,R,M;return M={next:E(0),throw:E(1),return:E(2)},typeof Symbol=="function"&&(M[Symbol.iterator]=function(){return this}),M;function E(D){return function(Y){return W([D,Y])}}function W(D){if(T)throw new TypeError("Generator is already executing.");for(;M&&(M=0,D[0]&&(C=0)),C;)try{if(T=1,A&&(R=D[0]&2?A.return:D[0]?A.throw||((R=A.return)&&R.call(A),0):A.next)&&!(R=R.call(A,D[1])).done)return R;switch(A=0,R&&(D=[D[0]&2,R.value]),D[0]){case 0:case 1:R=D;break;case 4:return C.label++,{value:D[1],done:!1};case 5:C.label++,A=D[1],D=[0];continue;case 7:D=C.ops.pop(),C.trys.pop();continue;default:if(R=C.trys,!(R=R.length>0&&R[R.length-1])&&(D[0]===6||D[0]===2)){C=0;continue}if(D[0]===3&&(!R||D[1]>R[0]&&D[1]<R[3])){C.label=D[1];break}if(D[0]===6&&C.label<R[1]){C.label=R[1],R=D;break}if(R&&C.label<R[2]){C.label=R[2],C.ops.push(D);break}R[2]&&C.ops.pop(),C.trys.pop();continue}D=y.call(m,C)}catch(Y){D=[6,Y],A=0}finally{T=R=0}if(D[0]&5)throw D[1];return{value:D[0]?D[1]:void 0,done:!0}}},s=ue&&ue.__spreadArray||function(m,y,C){if(C||arguments.length===2)for(var T=0,A=y.length,R;T<A;T++)(R||!(T in y))&&(R||(R=Array.prototype.slice.call(y,0,T)),R[T]=y[T]);return m.concat(R||Array.prototype.slice.call(y))};Object.defineProperty(ue,"__esModule",{value:!0}),ue.JSONRPCServer=void 0;var a=Mn(),r=Wi(),o=function(){return(0,a.createJSONRPCErrorResponse)(null,a.JSONRPCErrorCode.ParseError,"Parse error")},i=function(m){return(0,a.createJSONRPCErrorResponse)((0,a.isJSONRPCID)(m.id)?m.id:null,a.JSONRPCErrorCode.InvalidRequest,"Invalid Request")},c=function(m){return(0,a.createJSONRPCErrorResponse)(m,a.JSONRPCErrorCode.MethodNotFound,"Method not found")},d=function(){function m(y){y===void 0&&(y={});var C;this.mapErrorToJSONRPCErrorResponse=g,this.nameToMethodDictionary={},this.middleware=null,this.errorListener=(C=y.errorListener)!==null&&C!==void 0?C:console.warn}return m.prototype.hasMethod=function(y){return!!this.nameToMethodDictionary[y]},m.prototype.addMethod=function(y,C){this.addMethodAdvanced(y,this.toJSONRPCMethod(C))},m.prototype.removeMethod=function(y){delete this.nameToMethodDictionary[y]},m.prototype.toJSONRPCMethod=function(y){return function(C,T){var A=y(C.params,T);return Promise.resolve(A).then(function(R){return b(C.id,R)})}},m.prototype.addMethodAdvanced=function(y,C){var T;this.nameToMethodDictionary=e(e({},this.nameToMethodDictionary),(T={},T[y]=C,T))},m.prototype.receiveJSON=function(y,C){var T=this.tryParseRequestJSON(y);return T?this.receive(T,C):Promise.resolve(o())},m.prototype.tryParseRequestJSON=function(y){try{return JSON.parse(y)}catch{return null}},m.prototype.receive=function(y,C){return Array.isArray(y)?this.receiveMultiple(y,C):this.receiveSingle(y,C)},m.prototype.receiveMultiple=function(y,C){return t(this,void 0,void 0,function(){var T,A=this;return n(this,function(R){switch(R.label){case 0:return[4,Promise.all(y.map(function(M){return A.receiveSingle(M,C)}))];case 1:return T=R.sent().filter(h),T.length===1?[2,T[0]]:T.length?[2,T]:[2,null]}})})},m.prototype.receiveSingle=function(y,C){return t(this,void 0,void 0,function(){var T,A;return n(this,function(R){switch(R.label){case 0:return T=this.nameToMethodDictionary[y.method],(0,a.isJSONRPCRequest)(y)?[3,1]:[2,i(y)];case 1:return[4,this.callMethod(T,y,C)];case 2:return A=R.sent(),[2,I(y,A)]}})})},m.prototype.applyMiddleware=function(){for(var y=[],C=0;C<arguments.length;C++)y[C]=arguments[C];this.middleware?this.middleware=this.combineMiddlewares(s([this.middleware],y,!0)):this.middleware=this.combineMiddlewares(y)},m.prototype.combineMiddlewares=function(y){return y.length?y.reduce(this.middlewareReducer):null},m.prototype.middlewareReducer=function(y,C){return function(T,A,R){return y(function(M,E){return C(T,M,E)},A,R)}},m.prototype.callMethod=function(y,C,T){var A=this,R=function(E,W){return y?y(E,W):E.id!==void 0?Promise.resolve(c(E.id)):Promise.resolve(null)},M=function(E){return A.errorListener('An unexpected error occurred while executing "'.concat(C.method,'" JSON-RPC method:'),E),Promise.resolve(A.mapErrorToJSONRPCErrorResponseIfNecessary(C.id,E))};try{return(this.middleware||f)(R,C,T).then(void 0,M)}catch(E){return M(E)}},m.prototype.mapErrorToJSONRPCErrorResponseIfNecessary=function(y,C){return y!==void 0?this.mapErrorToJSONRPCErrorResponse(y,C):null},m}();ue.JSONRPCServer=d;var h=function(m){return m!==null},f=function(m,y,C){return m(y,C)},b=function(m,y){return m!==void 0?(0,a.createJSONRPCSuccessResponse)(m,y):null},g=function(m,y){var C,T=(C=y?.message)!==null&&C!==void 0?C:"An unexpected error occurred",A=r.DefaultErrorCode,R;return y instanceof a.JSONRPCErrorException&&(A=y.code,R=y.data),(0,a.createJSONRPCErrorResponse)(m,A,T,R)},I=function(m,y){return y||(m.id!==void 0?(0,a.createJSONRPCErrorResponse)(m.id,a.JSONRPCErrorCode.InternalError,"Internal error"):null)};return ue}var Me={},Ha;function sp(){if(Ha)return Me;Ha=1;var e=Me&&Me.__awaiter||function(a,r,o,i){function c(d){return d instanceof o?d:new o(function(h){h(d)})}return new(o||(o=Promise))(function(d,h){function f(I){try{g(i.next(I))}catch(m){h(m)}}function b(I){try{g(i.throw(I))}catch(m){h(m)}}function g(I){I.done?d(I.value):c(I.value).then(f,b)}g((i=i.apply(a,r||[])).next())})},t=Me&&Me.__generator||function(a,r){var o={label:0,sent:function(){if(d[0]&1)throw d[1];return d[1]},trys:[],ops:[]},i,c,d,h;return h={next:f(0),throw:f(1),return:f(2)},typeof Symbol=="function"&&(h[Symbol.iterator]=function(){return this}),h;function f(g){return function(I){return b([g,I])}}function b(g){if(i)throw new TypeError("Generator is already executing.");for(;h&&(h=0,g[0]&&(o=0)),o;)try{if(i=1,c&&(d=g[0]&2?c.return:g[0]?c.throw||((d=c.return)&&d.call(c),0):c.next)&&!(d=d.call(c,g[1])).done)return d;switch(c=0,d&&(g=[g[0]&2,d.value]),g[0]){case 0:case 1:d=g;break;case 4:return o.label++,{value:g[1],done:!1};case 5:o.label++,c=g[1],g=[0];continue;case 7:g=o.ops.pop(),o.trys.pop();continue;default:if(d=o.trys,!(d=d.length>0&&d[d.length-1])&&(g[0]===6||g[0]===2)){o=0;continue}if(g[0]===3&&(!d||g[1]>d[0]&&g[1]<d[3])){o.label=g[1];break}if(g[0]===6&&o.label<d[1]){o.label=d[1],d=g;break}if(d&&o.label<d[2]){o.label=d[2],o.ops.push(g);break}d[2]&&o.ops.pop(),o.trys.pop();continue}g=r.call(a,o)}catch(I){g=[6,I],c=0}finally{i=d=0}if(g[0]&5)throw g[1];return{value:g[0]?g[1]:void 0,done:!0}}};Object.defineProperty(Me,"__esModule",{value:!0}),Me.JSONRPCServerAndClient=void 0;var n=Mn(),s=function(){function a(r,o,i){i===void 0&&(i={});var c;this.server=r,this.client=o,this.errorListener=(c=i.errorListener)!==null&&c!==void 0?c:console.warn}return a.prototype.applyServerMiddleware=function(){for(var r,o=[],i=0;i<arguments.length;i++)o[i]=arguments[i];(r=this.server).applyMiddleware.apply(r,o)},a.prototype.hasMethod=function(r){return this.server.hasMethod(r)},a.prototype.addMethod=function(r,o){this.server.addMethod(r,o)},a.prototype.addMethodAdvanced=function(r,o){this.server.addMethodAdvanced(r,o)},a.prototype.removeMethod=function(r){this.server.removeMethod(r)},a.prototype.timeout=function(r){return this.client.timeout(r)},a.prototype.request=function(r,o,i){return this.client.request(r,o,i)},a.prototype.requestAdvanced=function(r,o){return this.client.requestAdvanced(r,o)},a.prototype.notify=function(r,o,i){this.client.notify(r,o,i)},a.prototype.rejectAllPendingRequests=function(r){this.client.rejectAllPendingRequests(r)},a.prototype.receiveAndSend=function(r,o,i){return e(this,void 0,void 0,function(){var c,d;return t(this,function(h){switch(h.label){case 0:return(0,n.isJSONRPCResponse)(r)||(0,n.isJSONRPCResponses)(r)?(this.client.receive(r),[3,4]):[3,1];case 1:return(0,n.isJSONRPCRequest)(r)||(0,n.isJSONRPCRequests)(r)?[4,this.server.receive(r,o)]:[3,3];case 2:return c=h.sent(),c?[2,this.client.send(c,i)]:[3,4];case 3:return d="Received an invalid JSON-RPC message",this.errorListener(d,r),[2,Promise.reject(new Error(d))];case 4:return[2]}})})},a}();return Me.JSONRPCServerAndClient=s,Me}var ja;function ap(){return ja||(ja=1,function(e){var t=je&&je.__createBinding||(Object.create?function(s,a,r,o){o===void 0&&(o=r);var i=Object.getOwnPropertyDescriptor(a,r);(!i||("get"in i?!a.__esModule:i.writable||i.configurable))&&(i={enumerable:!0,get:function(){return a[r]}}),Object.defineProperty(s,o,i)}:function(s,a,r,o){o===void 0&&(o=r),s[o]=a[r]}),n=je&&je.__exportStar||function(s,a){for(var r in s)r!=="default"&&!Object.prototype.hasOwnProperty.call(a,r)&&t(a,s,r)};Object.defineProperty(e,"__esModule",{value:!0}),n(ep(),e),n(tp(),e),n(Mn(),e),n(np(),e),n(sp(),e)}(je)),je}var hp=ap();export{op as B,up as C,lp as E,Qh as M,ip as P,cp as V,dp as a,Pa as b,hp as d};
//# sourceMappingURL=index-Djgr9AUB.js.map
